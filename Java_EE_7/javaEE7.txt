---
Ресурсы:

// оф сайт
- [    ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- книга [EE 7]




1) далее конспект книги:

---

# Глава 1.
# Что такое EJB 3

1.1. Обзор EJB

EJB – это коллекция «фиксированных» решений типовых проблем, возникающих 
при разработке серверных приложений, а также проверенная временем схема 
реализации серверных компонентов. Эти фиксированные решения, или службы, 
предоставляются контейнером EJB. Для доступа к этим службам необходимо 
создать специализированные компоненты, используя декларативные и 
программные EJB API, и развернуть их в контейнере.

1.1.1. EJB как модель компонентов

Чтобы воспользоваться службами EJB, ваш компонент должен быть объявлен с
типом, распознаваемым фреймворком EJB. EJB распознает два конкретных типа
компонентов: сеансовые компоненты (session beans) и компоненты, управляемые
сообщениями (message-driven beans). Сеансовые компоненты в свою очередь под-
разделяются на сеансовые компоненты без сохранения состояния (stateless session
beans), сеансовые компоненты с сохранением состояния (stateful session beans) и
компоненты-одиночки (синглтоны – singletons).

1.1.2. Службы компонентов EJB

Фиксированные службы являются наиболее ценной
частью EJB. Некоторые службы автоматически подключаются зарегистрирован-
ным компонентам, так как специально предназначены для использования ком-
понентами на уровне прикладной логики. В число этих служб входят: внедрение
зависимостей, транзакции, поддержка многопоточной модели выполнения и ор-
ганизация пулов. В большинстве случаев для подключения служб разработчик
явно должен объявить о своих намерениях с использованием аннотаций/XML
или обращением к EJB API во время выполнения.

1.1.3. Многоуровневые архитектуры и EJB

Существует две основные разновидности многоуровневых архитектур: 
традиционная четырехуровневая архитектура и проблемно-ориентированная 
архитектура (Domain-Driven Design, DDD).

- Традиционная четырехуровневая архитектура
1) уровень представления отвечает за отображение графического интерфейса поль-
зователя (Graphical User Interface, GUI) и обработку ввода пользователя.
2) Уровень представления передает все запросы уровню прикладной логики. Этот 
уровень является сердцем приложения и содержит основную логику обработки. 
Иными словами, прикладная логика – это уровень, где находятся компоненты, 
выполняющие различные прикладные операции, такие как учет, поиск и упорядочение 
данных, а также обслуживание учетных записей пользователей.Уровень прикладной 
логики извлекает данные и сохраняет их в базе данных, используя для этого уровень
хранения. 
3) Уровень хранения обеспечивает высокоуровневые, объектно-ориенти-
рованные абстракции поверх уровня базы данных. 
4) Уровень базы данных обычно включает систему управления реляционными базами 
данных (Relational Database Management System, RDBMS), такую как Oracle, DB2
или SQL Server.

- Проблемно-ориентированная архитектура
Архитектура DDD подчеркивает, что объекты предметной области не должны служить прос-
той заменой записей базы данных, и должны содержать прикладную логику. Эти
объекты могут быть реализованы как сущности в JPA. В архитектуре DDD, объ-
ект Catalog в приложении электронной торговли, помимо хранения всех данных
из таблицы каталога в базе данных, мог бы уметь анализировать и не возвращать
записи из каталога, соответствующие отсутствующим на складе товарам.

1.1.4. Почему стоит выбрать EJB 3?

- Простота в использовании
- Полный интегрированный стек решений
- Открытый стандарт Java EE
- Широкая поддержка производителей
- Кластеризация, балансировка нагрузки и отказоустойчивость
- Производительность и масштабируемость

--//--

1.2. Основы типов EJB

EJB делит зерна (то бишь, компоненты) на два типа, исхо-
дя из их предназначения:
- сеансовые компоненты ;
- компоненты, управляемые сообщениями .

1.2.1. Сеансовые компоненты

Сеансовый компонент может реализовать любую
прикладную логику. Всего существует три разновидности сеансовых компонен-
тов: с сохранением состояния, без сохранения состояния и «одиночки» (singleton).

1.2.2. Компоненты, управляемые сообщениями

Подобно сеансовым компонентам, компоненты, управляемые сообщениями, (Mes-
sage-Driven Bean, MDB) также реализуют некоторую прикладную логику, но име-
ют одно важное отличие: клиенты никогда не вызывают методы MDB непосредс-
твенно. Вместо этого компоненты MDB вызываются для обработки сообщений,
отправленных на сервер сообщений, что открывает возможность организовать
асинхронный обмен сообщениями между частями системы.

--//--

1.3. Связанные спецификации

1.3.1. Сущности и Java Persistence API

ORM – это процесс отображения полей Java-объектов в таблицы базы данных, 
определяемые с применением конфигурационных файлов или аннотаций.

- Сущности
Сущности (entities) – это Java-объекты, хранимые в базе данных.

- Диспетчер сущностей
Сущности сообщают провайдеру JPA, как они должны отображаться в базу
данных, но не занимаются сохранением самих себя. Интерфейс EntityManager
предусматривает методы чтения метаданных ORM для сущности и выполнения
операций по сохранению. EntityManager знает, как добавлять сущности в базу
данных, обновлять хранящиеся сущности, а также удалять и извлекать их из базы
данных.

- Язык запросов Java Persistence Query Language
JPA поддерживает специализированный SQL-подобный язык запросов Java
Persistence Query Language (JPQL) для поиска сущностей, хранящихся в базе дан-
ных.

1.3.2. Контексты и внедрение зависимостей для Java EE

В Java EE 5 имелась поддержка простейшей формы внедрения зависимостей, ко-
торую можно было бы использовать в EJB. Она называлась внедрением ресурсов
(resource injection) и позволяла внедрять контейнеры ресурсов, такие как источ-
ники данных, очереди, ресурсы JPA и контейнеры EJB, с использованием анно-
таций @EJB , @Resource и @PersistenceContext .

В отличие от многих других более старых решений внедрения зави-
симостей, CDI является компактным и футуристическим механизмом, управля-
емым с помощью аннотаций и полностью поддерживающим типы компонентов.

--//--

1.4. Реализации EJB

Согласно спецификации EJB 3 контейнер предоставляет
службы, применимые только к сеансовым компонентам и MDB. Операция добав-
ления компонента EJB 3 в контейнер называется развертыванием (deployment).

1.4.1. Серверы приложений

Серверы приложений – традиционная среда для развертывания EJB. Серверы
приложений по сути являются контейнерами Java EE, включающими поддержку
всех Java EE API, а также средства администрирования, развертывания, мони-
торинга, масштабирования, балансировки нагрузки, безопасности и так далее

1.4.2. EJB Lite

С практической точки зрения важно отме-
тить, что из EJB 3.2 Lite полностью исключена поддержка обратной совместимос-
ти с EJB 2. Благодаря этому контейнеры EJB получаются более легковесными, так
как нет необходимости включать в них устаревшие API, в довесок к легковесной
модели EJB.

1.4.3. Встраиваемые контейнеры

Традиционные серверы приложений выполняются в виде отдельных процессов,
в которых вы можете развертывать свои приложения. Встраиваемые контейнеры
EJB, напротив, можно запускать программно, с использованием Java API, внутри
своих приложений.

1.4.4. Использование EJB 3 в Tomcat

Apache Tomcat – популярный и легковесный контейнер сервлетов – не поддержи-
вает EJB 3, потому что в отличие от серверов приложений, контейнеры сервлетов
не требуют этого.

--//--

1.5. Превосходные инновации

1.5.1. Пример «Hello User»

  --- 

1.5.2. Аннотации и XML

Формат XML
чересчур многословен, трудно читаем и в нем очень легко допустить ошибку. Кроме
того, XML никак не поддерживает одну из сильнейших сторон Java – строгий конт-
роль типов.

рекомендуем начинать с аннотаций и добавлять переопределяющие настройки в
файлах XML, только когда это действительно необходимо.

1.5.3. Значения по умолчанию и явные настройки

В дополнение к упро-
щению настройки с применением аннотаций, EJB 3 также уменьшает общий объ-
ем конфигураций, подставляя наиболее рациональные значения по умолчанию.

1.5.4. Внедрение зависимостей и поиск в JNDI

Версия EJB 3 была полностью переработана для обеспечения поддержки внедре-
ния зависимостей. Благодаря чему теперь имеется возможность внедрять компо-
ненты EJB в компоненты Java EE, а компоненты Java EE в компоненты EJB.

@EJB // Внедрение компонента EJB
private HelloUserBean helloUser;

  void hello() {
    helloUser.sayHello(“Curious George”);
}

ннотация @EJB проверяет тип и
имя компонента, и отыскивает его с помощью механизма JNDI. Все компоненты
EJB автоматически регистрируются в JNDI в момент развертывания.

1.5.5. CDI и механизм внедрения в EJB

CDI можно использо-
вать для внедрения практически чего угодно. Механизм внедрения EJB, напротив,
можно применять только к объектам, хранящимся в JNDI, таким как компоненты
EJB, а также к некоторым другим объектам, управляемым контейнером, таким как
контексты EJB.

@Inject // Внедрение компонента EJB с помощью CDI
private HelloUserBean helloUser;

void hello(){
  helloUser.sayHello(“Curious George”);
}

1.5.6. Тестируемость компонентов POJO

Так как все компоненты EJB в действительности являются обычными Java-объек-
тами, они легко поддаются модульному тестированию с помощью JUnit .

--//--

1.6. Новшества в EJB 3.2

1.6.1. Поддержка EJB 2 теперь является необязательной

1.6.2. Усовершенствования в компонентах, управляемых сообщениями

1.6.3. Усовершенствования в сеансовых компонентах с сохранением состояния

- Отключение пассивации
До версии EJB 3.2 компоненты с сохранением состояния требовали реализации
интерфейса Serializable во всех объектах, составляющих их, чтобы контейнер
EJB мог пассивировать (сохранять в дисковой памяти) их. Если какой-то объект
в компоненте с сохранением состояния не поддерживал сериализацию, операция
пассивации терпела неудачу и контейнер EJB мог уничтожить такой компонент,
с потерей информации о его состоянии.

- Поддержка транзакций в методах обратного вызова,
используемых механизмом управления жизненным
циклом

1.6.4. Упрощение локальных интерфейсов компонентов без сохранения состояния

1.6.5. Усовершенствования в TimerService API

метод getAllTimers() , возвращающий список всех
активных таймеров в модуле EJB. Это дает возможность из любой точки в коде
просматривать и изменять любые таймеры.

1.6.6. Усовершенствования в EJBContainer API

1.6.7. Группы EJB API

Не все корпоративные приложения нуждаются во всех
службах EJB. Чтобы облегчить жизнь разработчикам, в EJB 3.2 были определены
группы EJB API. Эти группы четко ограничивают подмножества функций EJB.

--//--

1.7. В заключение

--//-------------------------------------------------------------------------

# Глава 2.
# Первая проба EJB

В этой главе мы приступим к решению задачи, которое продолжится в осталь-
ных главах, – созданию приложения ActionBazaar. Это воображаемая система, на
примере которой мы будем пояснять различные аспекты.

2.1. Введение в приложение ActionBazaar

ActionBazaar – это простой интернет-аукцион, по образу и подобию eBay . Про-
давцы сдувают пыль с сокровищ, хранящихся у них в подвалах, делают несколько
размытых фотографий и посылают их в приложение ActionBazaar.

2.1.1. Архитектура

Претендент предлагает
цену за желаемый товар, выигрывает, заказывает и немедленно получает
подтверждение. В процессе подтверждения заказа пользователь вносит
информацию о способе оплаты. После подтверждения получения денег
продавец организует доставку покупки

2.1.2. Решение на основе EJB 3

--//--

2.2. Реализация прикладной логики с применением EJB 3

Напомним, что существует три разновидности сеансовых компонентов: с сохра-
нением состояния, без сохранения состояния и компоненты-одиночки (singleton).

2.2.1. Использование сеансовых компонентов без сохранения состояния

@Stateless // Пометить POJO как сеансовый компонент без сохранения состояния
public class DefaultBidService implements BidService {
  @Inject // Внедрить объект DAO
  private BidDao bidDao;
  ...
  public void addBid(Bid bid) {
    bidDao.addBid(bid);
  }
  ...
}

@Local // Пометить интерфейс как локальный
public interface BidService {
  ...
  public void addBid(Bid bid);
  ...
}

@Stateless – Аннотация @Stateless сообщает контейнеру EJB, что
DefaultBidService является сеансовым компонентом без сохранения со-
стояния. Встретив такую аннотацию, контейнер автоматически добавит в
компонент поддержку многопоточной модели выполнения, транзакций и
возможность размещения в пулах. Поддержка многопоточности и транзак-
ций гарантируют возможность использования любых ресурсов, таких как
база данных или очередь сообщений, без необходимости вручную писать код
для обслуживания конкуренции или транзакций.

@Local – Аннотация @Local , отмечающая интерфейс BidService сообща-
ет контейнеру, что реализация BidService может быть доступна локально,
посредством интерфейса. Так как компоненты EJB и компоненты, исполь-
зующие их, обычно находятся в одном и том же приложении, в этом есть
определенный смысл. При желании аннотацию @Local можно опустить и
интерфейс все равно будет интерпретироваться контейнером как локаль-
ный. Как вариант, интерфейс можно пометить аннотацией @Remote или
@WebService . В случае применения аннотации @Remote , к компоненту бу-
дет предоставлен удаленный доступ через механизм Java Remote Method
Invocation (RMI), идеально подходящий для организации удаленного до-
ступа со стороны Java-клиентов.

@Inject заставляет контейнер «иници-ализировать» переменную bidDao 
соответствующей реализацией DAO до
того, как произойдет первое обращение к ней.

2.2.2 Использование сеансовых компонентов с сохранением состояния

Во-первых, контейнер гарантирует клиенту возможность повторно обращаться
к выделенному для него компоненту и вызывать разные его методы.

Во-вторых, контейнер гарантирует сохранность переменных экземпляра на про-
тяжении всего сеанса, не требуя от разработчика писать какой-то дополнительный
код для этого.

Аннотация @Asynchronous p перед методом placeOrder обеспечивает воз-
можность асинхронного выполнения метода. Это означает, что компонент будет
возвращать управление клиенту немедленно, а метод продолжит выполнение в
фоновом легковесном процессе. Это важная особенность в данном случае, потому
что процесс оплаты потенциально может занять продолжительное время. Вместо
того, чтобы заставлять пользователя ждать завершения процесса оплаты, благода-
ря аннотации @Asynchronous пользователь немедленно получит подтверждение о
приеме заказа, а заключительный этап процесса оформления заказа сможет завер-
шиться в фоновом режиме.

Обратите также внимание на аннотацию @Remove q перед методом placeOrder .
Хотя эта аннотация является необязательной, она играет важную роль в обес-
печении высокой производительности в серверных приложениях. Аннотация
@Remove отмечает окончание процедуры, моделируемой компонентом с сохранени-
ем состояния. В данном случае код сообщает контейнеру, что после вызова метода
placeOrder нет необходимости продолжать поддерживать сеанс с клиентом.

2.2.3. Модульное тестирование компонентов EJB 3

  --- 

--//--

2.3. Использование CDI с компонентами EJB 3

<!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”
“http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”>
<html xmlns=”http://www.w3.org/1999/xhtml”
xmlns:h=”http://java.sun.com/jsf/html”
xmlns:f=”http://java.sun.com/jsf/core”
xmlns:ui=”http://java.sun.com/jsf/facelets”>
<h:body>
  ...
  <h:form id=”bid-form”>
  ...
  <!-- Выражения, осуществляющие связывание с компонентами,
       внедренными с помощью CDI -->
  <h:inputText id=”input-bid” value=”#{bid.amount}”/>
  ...
  <h:commandButton id=”place-bid-button”
                   value=”Place Bid!”
                   action=”#{bidManager.placeBid}”/>
    ...
  </h:form>
  ...
</h:body>
</html>


Как можно видеть, оба элемента страницы, поле ввода inputText и кнопка
commandButton , связаны с компонентами посредством выражений связывания n.
Поле inputText связано с полем amount компонента bid . Это означает, что тек-
стовое поле отображает значение связанного с ним поля компонента, а любое
значение, введенное в текстовое поле, автоматически будет записано в поле ком-
понента. Кнопка Place Bid (Сделать ставку) связана с методом placeBid компо-
нента bidManager . Это означает, что связанный метод будет вызван автоматичес-
ки в случае щелчка на кнопке.


@Named          // Присвоить имя компоненту BidManager при внедрении посредством CDI
@RequestScoped  // Область видимости компонента ограничена запросом
public class BidManager {
  @Inject // Внедрение компонента BidService
  private BidService bidService;

  @Inject   // Внедрение текущего
  @LoggedIn // зарегистрированного пользователя
  private User user;

  @Inject       // Внедрение текущего
  @SelectedItem // выбранного товара
  private Item item;

  private Bid bid = Bid();

  @Produces            // Производит компонент,
  @Named               // управляемый посредством CDI,
  @RequestScoped       // с именем bid
  public Bid getBid() {
    return bid;
}
 
 
  public String placeBid() {
    bid.setBidder(user);
    bid.setItem(item);
    bidService.addBid(bid);
  
    return “bid_confirm.xhtml”;
  }
}


Компонент BidManager не является компонентом EJB – это простой компонент,
управляемый механизмом CDI. То есть, данному компоненту недоступны никакие
корпоративные службы EJB, такие как управление транзакциями, – только средст-
ва внедрения зависимостей, управления жизненным циклом и контекстом. Но в
данном случае этого вполне достаточно, потому что BidManager выступает всего
лишь в роли связующего звена между страницей JSF и уровнем служб EJB.

CDI-аннотация @Named n присваивает компо-
ненту BidManager имя при внедрении. По умолчанию компоненту присваивается
имя, совпадающее с именем класса, в котором первый символ замещается сим-
волом нижнего регистра. В данном случае компонент BidManager получит имя
bidManager . Такое именование компонентов необходимо для ссылки на них из JSF
EL.

CDI-аннота-
ция @RequestScoped o определяет область видимости компонента BidManager .
Так как область видимости BidManager ограничивается рамками запроса, компо-
нент будет создаваться при загрузке страницы JSF и уничтожаться после перехода
на другую страницу.

Аннотации
@LoggedIn и @SelectedItem – это CDI-квалификаторы, определяемые пользова-
телем. Подробнее о квалификаторах CDI рассказывается в главе 12. А пока просто
запомните, что квалификаторы – это метаданные, определяемые пользователем,
используемые для определения конкретной характеристики внедряемого компо-
нента. Программный код предполагает, что CDI имеет
ссылку на подходящий экземпляр класса User в доступной области видимости.

Также интерес для нас представляют аннотации @Produces , @RequestScoped и
@Named перед методом getBid . Как можно догадаться, аннотация @Produces яв-
ляется ключевой. Она сообщает механизму CDI, что метод getBid возвращает объ-
ект Bid , которым он должен управлять. Аннотации @Named и @RequestScoped перед
методом getBid сообщают механизму CDI, что возвращаемому объекту Bid должно
быть присвоено имя bid и для него должна быть установлена область видимости
запроса. Благодаря присвоению имени объекту Bid , на него можно сослаться из EL,
как если бы он находился внутри страницы JSF.

2.3.2. Использование CDI с EJB 3 и JPA 2

public class DefaultBidDao implements BidDao {
  @PersistenceContext // Внедрить диспетчер сущностей JPA 2
  private EntityManager entityManager;
  ...
  public void addBid(Bid bid) {
  entityManager.persist(bid);
  }
  ...
  }

  public interface BidDao {
  ...
  public void addBid(Bid bid);
  ...
}

Когда
CDI обнаруживает аннотацию @Inject в компоненте BidService , он отыскива-
ет объект, реализующий интерфейс BidDao и внедряет его. Важно отметить, что
объект BidDao является «безымянным» – он не отмечен аннотацией @Named . Ее
отсутствие объясняется отсутствие ссылок на объект DAO по имени. Для объекта
DAO также не определяется область видимости. Механизм CDI предполагает, что
компонент принадлежит области видимости по умолчанию. Если не указано иное,
CDI создает совершенно новый экземпляр компонента и внедряет его в завися-
щий компонент, действуя практически так же, как оператор «new».

--//--

2.4. Использование JPA 2 с EJB 3

2.4.1. Отображение сущностей JPA 2 в базу данных

@Entity              // Пометить POJO как сущность
@Table(name=”BIDS”)  // Таблица для отображения
public class Bid {
  private Long id;
  private Item item;
  private Bidder bidder;
  private Double amount;

  @Id             // Определить поле-идентификатор ID
  @GeneratedValue // Значение поля генерируется автоматически
  @Column(name=”BID_ID”) // Определить имя поля для отображения
  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  @ManyToOne // Определить отношение "многие-к-одному"
             // Определить отображение отношения
  @JoinColumn(name=”BIDDER_ID”, referencedColumnName=”USER_ID”)
  public Bidder getBidder() {
    return bidder;
  }

  public void setBidder(Bidder bidder) {
    this.bidder = bidder;
  }

  @ManyToOne  // Определить отношение "многие-к-одному"
              // Определить отображение отношения
  @JoinColumn(name = “ITEM_ID”, referencedColumnName = “ITEM_ID”)
  public Item getItem() {
    return item;
  }

  public void setItem(Item item) {
    this.item = item;
  }

  @Column(name=”BID_AMOUNT”) // w Определить имя поля для отображения
  public Double getAmount() {
    return amount;
  }

  public void setAmount(Double amount) {
    this.amount = amount;
  }
}


Аннотация @Entity отмечает тот факт, что класс Bid представляет сущность
JPA.

Аннотация @Table сообщает JPA, что сущность Bid отображается в таб-
лицу BIDS.

Аналогично, аннотации @Column определяют, в какие поля
таблицы BIDS должны отображаться отмеченные ими свойства Bid.

Аннотация @Id играет особую роль. Она отмечает свойство Id как первичный 
ключ сущности Bid.

Аннотация @GeneratedValue указывает, что первичный ключ должен генерироваться 
автоматически, в момент сохранения сущности в базу данных.

Аннотации @ManyToOneи @JoinColumn. В обоих
случаях аннотация @ManyToOne указывает на природу отношений между сущнос-
тями. В терминах реляционных баз данных это означает, что таблица BIDS хра-
нит внешние ключи, связывающие ее с таблицами, где хранятся сущности Item и
Bidder . Аннотация @JoinColumn определяет фактическую реализацию связи по
внешнему ключу. В случае отношения «ставка-товар», внешний ключ хранится
в таблице BIDS с именем ITEM_ID , и ссылается на ключ с именем ITEM_ID , кото-
рый, вероят но, является первичным ключом таблицы ITEMS .


2.4.2. Использование EntityManager

Возможно вы обратили внимание, что сущность Bid не имеет метода для сохра-
нения самой себя в базе данных. Эту работу берет на себя диспетчер сущностей
JPA EntityManager который, опираясь на настройки объектно-реляционного
отображения, предоставляет сущностям прикладной интерфейс с операциями со-
хранения. Класс EntityManager знает, как сохранять сущности в базе данных в
виде реляционных записей, как читать данные из базы и превращать их в сущнос-
ти, как изменять данные, хранимые в базе, и как удалять эти данные. Диспетчер
EntityManager имеет методы, соответствующие полному комплекту CRUD-опе-
раций (Create (Создать), Read (Читать), Update (Изменить), Delete (Удалить)),
а также поддерживает надежный язык запросов Java Persistence Query Language
(JPQL).

public class DefaultBidDao implements BidDao {
  @PersistenceContext // Внедряет EntityManager
  private EntityManager entityManager;

  public void addBid(Bid bid) {
    entityManager.persist(bid); // Сохранить экземпляр сущности
  }

  public Bid getBid(Long id) {
    return entityManager.find(Bid.class, id); // Извлечь экземпляр
  }

  public void updateBid(Bid bid) {
    entityManager.merge(bid);  // Изменить экземпляр
  }

  public void deleteBid(Bid bid) {
  entityManager.remove(bid);  // Удалить экземпляр
  }
}


Настоящее волшебство здесь заключено в интерфейсе EntityManager . Инте-
ресно отметить, что интерфейс EntityManager играет роль переводчика между
объектно-ориентированным и реляционным мирами. Диспетчер читает аннотации
объектно-реляционного отображения, такие как @Table и @Column , указанные в
исходном коде сущности Bid , и по ним определяет, как сохранять ее в базе данных.

2.5. В заключение

  --- 

--//-------------------------------------------------------------------------

# Глава 3.
# Реализация прикладной
# логики с помощью сеансовых
# компонентов

С этой точки зрения
наиболее важной частью технологии EJB составляют сеансовые компоненты, по-
тому что цель всей их жизни заключается в моделировании бизнес-процессов.

3.1. Знакомство с сеансовыми компонентами

В основе сеансовых компонентов лежит идея обработки каждого запроса кли-
ента в рамках отдельной логической процедуры, выполняемой в пределах сеанса.

Проще говоря, сеанс – это соединение
между клиентом и сервером, которое длится конечный промежуток времени.

3.1.1. Когда следует использовать сеансовые компоненты

Сеансовые компоненты – это нечто большее, чем простая абстракция, позволяю-
щая разделить прикладную логику на отдельные процедуры. Контейнер управля-
ет сеансовыми компонентами и предоставляет им множество жизненно важных
служб. В число этих служб входят внедрение зависимостей, управление транзак-
циями, обеспечение безопасности, удаленные взаимодействия, отложенные вы-
числения (таймеры) и интерцепторы.

3.1.2. Состояние компонента и типы сеансовых компонентов

Как уже говорилось выше, состояние – это фундаментальная характеристика
классификации сеансовых компонентов на три разновидности.
- @Stateless   :  без сохранения состояния
- @Stateful    :  с сохранением состояния
- @Singleton   :  одиночки

--//--

3.2. Сеансовые компоненты без сохранения состояния

Как уже отмечалось, сеансовые компоненты без сохранения состояния не поддер-
живают какую-либо информацию о состоянии беседы, а задача, стоящая перед
службой, должна быть решена за один вызов метода.

3.2.1. Когда следует использовать сеансовые компоненты без сохранения состояния

Очевидным случаем использования сеансовых компонентов без сохранения со-
стояния являются прикладные службы, выполняемые за одно действие.

3.2.2. Организация компонентов в пулы

Основная идея состоит в том,
чтобы повторно использовать предопределенное число экземпляров компонента
для обслуживания входящих запросов. Когда поступает очередной запрос к ком-
поненту, контейнер создает его. Когда выполнение метода компонента заверша-
ется, компонент помещается в пул. То есть, компонент может либо обрабатывать
запрос, либо находиться в режиме ожидания. Пулы имеют верхнюю границу. Если
число параллельных запросов к сеансовому компоненту без сохранения состоя-
ния превысит размер пула, приложение оказывается не в состоянии обработать их
немедленно и помещает запросы в очередь. Как только в пуле появляется свобод-
ный экземпляр, ему передается запрос из очереди. Ни один экземпляр не может
находиться в режиме ожидания «вечно» – по истечении некоторого периода без-
действия они автоматически удаляются. Пулы могут также иметь нижнюю грани-
цу, определяющую минимальное число экземпляров.

Поддержка пулов не является стандартной особенностью, утвержденной в спе-
цификации EJB. Как и поддержка кластеров, поддержка пулов остается необяза-
тельной возможностью, но поддерживаемой большинством серверов приложений.

3.2.3. Пример BidService

В листинге 3.1 представлен компонент
DefaultBidService с методами, осуществляющими добавление, извлечение и
удаление ставок. По сути, это расширенная версия простого компонента PlaceBid ,
который мы видели ранее.


@Stateless(name = “BidService”) // Cеансовый компонент без сохранения состояния
public class DefaultBidService implements BidService {

private Connection connection;

@Resource(name = “jdbc/ActionBazaarDB”) // Внедрить источник данных
private DataSource dataSource;

@PostConstruct // Вызывать по событию PostConstruct
public void initialize() {
  try {
  connection = dataSource.getConnection();
  } catch (SQLException sqle) {
  sqle.printStackTrace();
  }
}

public void addBid(Bid bid) {
  Long bidId = getBidId();
  try {
    Statement statement = connection.createStatement();
    statement.execute(“INSERT INTO BIDS “
      + “ (BID_ID, BIDDER, ITEM_ID, AMOUNT) VALUES( “
      + bidId
      + “, “
      + bid.getBidder().getUserId()
      + “, “
      + bid.getItem().getItemId()
      + “, “
      + bid.getBidPrice() + “)”);
  } catch (Exception sqle) {
    sqle.printStackTrace();
  }
}

private Long getBidId() {
  ...Код, генерирующий уникальный ключ...
}

public void cancelBid(Bid bid) {
  ...
}

public List<Bid> getBids(Item item) {
  ...
}

@PreDestroy  // Вызывать по событию PreDestroy
public void cleanup() {
  try {
    connection.close();
    connection = null;
  } catch (SQLException sqle) {
    sqle.printStackTrace();
  }
}
}

... 

@Remote // Интерфейс удаленных взаимодействий
public interface BidService {
  void addBid(Bid bid);
  void cancelBid(Bid bid);
  List<Bid> getBids(Item item);
}


Как вы уже знаете, аннотация @Stateless превращает POJO в сеансовый
компонент без сохранения состояния. Класс DefaultBidService реализу-
ет интерфейс BidService , помеченный аннотацией @Remote. Аннотация
@Resource используется для внедрения источника данных JDBC. Аннотации
@PostConstruct и @PreDestroy отмечают методы обратного вызова, которые
управляют JDBC-соединением с базой данных, полученным в результате внедре-
ния источника данных. На случай, если потребуется обслуживание удаленных
клиентов, с помощью аннотации @Remote определяется интерфейс удаленных
взаимодействий.


3.2.4. Применение аннотации @Stateless

Аннотация @Stateless превращает простой Java-объект DefaultBidService в
сеан совый компонент без сохранения состояния.

@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
  public @interface Stateless {
  public String name() default “”;
  public String mappedName() default “”;
  public String description() default “”;
}

Параметр name определяет имя компонента. Контейнеры используют этот пара-
метр для включения компонента EJB в глобальное дерево JNDI. JNDI по сути яв-
ляется реестром, ресурсов, управляемым сервером приложений. Все компоненты
EJB автоматически включаются в JNDI после обнаружения их контейнером.

3.2.5. Прикладные интерфейсы компонентов

Клиенты могут использовать сеансовые компоненты тремя разными способами.
Первый: через локальный интерфейс, внутри той же виртуальной машины JVM.
Второй: через удаленный интерфейс с использованием механизма RMI. Третий:
посредством веб-службы SOAP или REST. К одному и тому же компоненту можно
обратиться любым из этих способов.
Поддержка этих трех методов доступа к компоненту включается с помощью ан-
нотаций. Каждая аннотация должна быть помещена перед интерфейсом, реализу-
емым компонентом. Рассмотрим эти аннотации поближе.


Локальный интерфейс предназначен для использования клиентами, находя-
щимися в том же экземпляре контейнера (JVM). Определение локального при-
кладного интерфейса осуществляется с помощью аннотации @Local .

@Local
public interface BidLocalService {
  void addBid(Bid bid);
  void cancelBid(Bid bid);
  List<Bid> getBids(Item item);
}

Локальные интерфейсы являются самыми простыми в определении и использо-
вании. Они также являются наиболее распространенным типом интерфейсов EJB
и типом по умолчанию. То есть, вы можете опустить аннотацию @Local , но интер-
фейс все равно будет интерпретироваться как локальный.

Клиенты, находящиеся за пределами виртуальной машины JVM, где выпол-
няется экземпляр контейнера, должны использовать некоторую разновидность
удаленного интерфейса. Если клиент так же написан на Java, наиболее логичным
выглядит выбор RMI – удаленного интерфейса доступа к компонентам EJB. RMI –
высокоэффективный API, основанный на использовании протокола TCP/IP
и осуществляющий обмен данными в компактном двоичном виде, автоматизирую-
щий большую часть операций, которые необходимо выполнить для вызова метода
Java-объекта по сети. В EJB 3 имеется поддержка доступа к компонентам через
механизм RMI, реализованная в виде аннотации @Remote . Прикладной интерфейс
BidService в нашем примере использует эту аннотацию, чтобы сделать компо-
нент доступным удаленно

@Remote
public interface BidService extends Remote {
  ...
}

Удаленные прикладные интерфейсы должны выполнять одно обяза-
тельное требование: все параметры и возвращаемые значения методов удаленного
интерфейса должны поддерживать интерфейс Serializable . Это обусловлено
тем, что с помощью RMI по сети могут передаваться только объекты, реализую-
щие интерфейс Serializable .

Помимо локального и удаленного интерфейсов, сеансовые компоненты могут
также поддерживать интерфейсы веб-служб. В Java EE 7 поддерживается две
различные технологии организации веб-служб: SOAP, посредством JAX-WS, и
REST, посредством JAX-RS . В обоих случаях соответствующие аннотации могут
быть помещены либо перед отдельным интерфейсом, либо непосредственно перед
классом компонента.


Ниже приводится версия REST-службы для работы со ставками. Класс опре-
деляет сеансовый компонент без сохранения состояния и делегирует выполнение
фактических операций внедренному экземпляру BidService :


@Stateless
// Пометить сеансовый компонент без сохранения состояния как
// экспортируемый через REST с корневым URI /bid
@Path(“/bid”)
public class BidRestService {
  @EJB
  private BidService bidService;
  ...
  // При получении запроса HTTP GET будет вызван метод getBid
  @GET
  // Метод getBid должен вернуть объект ставки в формате XML
  @Produces(“text/xml”)
  // Идентификатор ставки извлекается из параметра HTTP-запроса
  public Bid getBid(@QueryParam(“id”) Long id) {
    return bidService.getBid(id);
  }
  ...
  // При получении запроса HTTP DELETE будет вызван метод deleteBid
  @DELETE
  public void deleteBid(@QueryParam(“id”) Long id) {
    Bid bid = bidService.getBid(id);
    bidService.deleteBid(bid);
  }
}


Веб-служба REST вызывается обращением по адресу http://<hostname>:
<port>/actionbazaar/rest/bid. Параметры запроса передаются по мере необходи-
мости. Например, адрес URL для извлечения информации о ставке имеет вид:
http://<hostname>:<port>/actionbazaar/rest/bid?id=1010.


Для организации традиционных веб-служб на основе SOAP, в состав Java EE 6
входит JAX-WS. Как и JAX-RS, включение механизма JAX-WS выполняется с помо-
щью аннотаций. Чтобы экспортировать существующий компонент в виде веб-служ-
бы, достаточно просто создать новый экземпляр и добавить аннотацию @javax.jws.
WebService .

@WebService
public interface BidSoapService {
  List<Bid> getBids(Item item);
}

Как видно из этого фрагмента, имеется возможность выборочно скрывать мето-
ды, которые не должны быть доступны в веб-службе.


3.2.6. События жизненного цикла

1. Создает экземпляр компонента вызовом конструктора по умолчанию.
2. Внедряет ресурсы, такие как провайдеры JPA и соединения с базами дан-
ных.
3. Помещает экземпляр компонента в управляемый пул (если поддерживает-
ся).
4. Когда от клиента поступает запрос, извлекает простаивающий компонент
из пула. В этот момент контейнер может создавать дополнительные компо-
ненты для обработки запросов. Если контейнер не поддерживает пулы, он
просто создает экземпляр компонента.
5. Вызывает запрошенный метод посредством прикладного интерфейса.
6. Когда метод вернет управление, компонент помещается обратно в пул
(если поддерживается). Если контейнер не поддерживает пулы, он просто
уничтожает компонент.
7. При необходимости контейнер удаляет из пула ненужные компоненты.


Сеансовые компоненты без сохранения состояния поддерживают два метода
обработки событий жизненного цикла с помощью следующих аннотаций:

- @PostConstruct – метод, отмеченный этой аннотацией, будет вызываться
сразу после создания экземпляра и внедрения всех ресурсов;
- @PreDestroy – метод, отмеченный этой аннотацией, будет вызываться не-
посредственно перед уничтожением экземпляра.

*Если потребуется, этими аннотациями можно пометить несколько методов.

Событие PostConstruct
После внедрения всех ресурсов, контейнер проверяет наличие в классе ком-
понента методов с аннотацией @PostConstruct . Если такие методы имеются, он
вызывает их перед тем, как передать экземпляр компонента в работу.

Событие PreDestroy
В некоторый момент контейнер может решить, что экземпляр компонента дол-
жен быть уничтожен. Метод обратного вызова с аннотацией @PreDestroy дает
компоненту возможность освободить занятые им ресурсы перед уничтожением.


3.2.7. Эффективное использование сеансовых
компонентов без сохранения состояния

- Настраивайте пул под свои нужды
- Не злоупотребляйте поддержкой удаленного доступа
- Используйте интерфейсы
- Особое внимание уделяйте проектированию удаленных интерфейсов
- Удаленные объекты не должны передаваться по ссылке
    Например, если удаленному сеансовому компоненту без сохранения 
    состояния передать список объектов, вы не увидите изменения в списке, 
    произведенные этим компонентом, если только он не будет возвращен
    удаленным методом.
- Избегайте слишком мелкого дробления удаленных вызовов
    Удаленный вызов является весьма дорогостоящей операцией – локальные ком-
    поненты могут позволить себе мелкое дробление вызовов, тогда как удаленные
    должны выполнять максимальный объем работы в одном вызове.
  
--//--

3.3. Сеансовые компоненты с сохранением состояния

Напомним, что в отличие от сеансовых компонентов без сохранения состояния,
компоненты с сохранением состояния поддерживают хранение промежуточного
состояния между вызовами методов.

Контейнер гарантирует, что каждый вызов метода будет
передаваться одному и тому же экземпляру компонента, хоть удаленному, хоть
локальному.

Экземпляры компонентов не могут сохраняться в пуле и повторно использо-
ваться другими клиентами. Вместо этого экземпляр должен постоянно храниться
в памяти и ожидать других запросов от клиента, пока тот не закроет сеанс. Как
результат, экземпляры сеансовых компонентов с сохранением состояния, удер-
живаемые большим числом одновременно обслуживаемых пользователей, могут
занимать значительные объемы памяти. Однако и для этой ситуации существует
прием оптимизации, который называется пассивацией (passivation).

3.3.1. Когда следует использовать сеансовые компоненты с сохранением состояния

3.3.2. Пассивация компонентов

Одно из больших преимуществ сеансовых компонентов с сохранением состояния
заключается в поддержке контейнером возможности их архивирования, когда они
долго не используются.

Под пассивацией подразумевается перемещение экземпляра компонента из
оперативной памяти на диск. Эта задача решается контейнером путем сериали-
зации всего экземпляра компонента. Активация – это процедура, обратная пас-
сивации и она выполняется, когда появляется необходимость вновь задейство-
вать экземпляр компонента

Как следствие, все переменные экземпляра в компоненте должны
быть либо простыми значениями Java, либо объектами, реализующими интер-
фейс java.io.Serializable , либо должны быть помечены как перемещаемые
( transient ).

@PrePasivate  // вызовется метод перед пассивацией
@PostActivate // вызовется метод после депассивации

3.3.3. Сеансовые компоненты с сохранением состояния в кластере

Хотя спецификация EJB и не требует этого, большинство серверов приложений все
же поддерживают выполнение сеансовых компонентов с сохранением состояния в
кластерах.

3.3.4. Пример реализации создания учетной записи

  --- 

3.3.5. Применение аннотации @Stateful

определение аннотации @Stateful в точности совпадает с опреде-
лением аннотации @Stateless .

3.3.6. Прикладные интерфейсы компонентов

Сеансовые компоненты с сохране-
нием состояния так же поддерживают локальные и удаленные взаимодействия с
помощью аннотаций @Local и @Remote . Но они не поддерживают интерфейс ко-
нечных точек веб-служб. Это означает, что сеансовые компоненты с сохранением
состояния не могут экспортироваться с использованием JAX-RS или JAX-WS.

Прикладной интерфейс всегда должен включать метод с аннотацией @Remove .
Допускается применять эту аннотацию к нескольким методам. Она сообщает кон-
тейнеру, что клиент завершил работу с компонентом.

3.3.7. События жизненного цикла

1. В начале нового сеанса контейнер всегда создает новый экземпляр компо-
нента, используя для этого конструктор по умолчанию.
2. После вызова конструктора контейнер внедряет ресурсы, такие как контек-
сты JPA, источники данных и другие компоненты.
3. Экземпляр хранится в памяти, в ожидании обращений.
4. Клиент вызывает прикладной метод через прикладной интерфейс.
5. Контейнер ожидает очередных запросов на вызовы методов и выполняет
их.
6. Если клиент достаточно долго бездействует, контейнер пассивирует экзем-
пляр компонента (если эта операция поддерживается). Компонент сериа-
лизуется и сохраняется на диск.
7. Если клиент возобновит работу и обратится к пассивированному компо-
ненту, экземпляр будет активирован (прочитан с диска в память).
8. Если клиент продолжает долго бездействовать, компонент уничтожается.
9. Если клиент затребовал удалить экземпляр компонента, находящийся в
этот момент в пассивированном состоянии, он


 - @PostConstruct – метод, отмеченный этой аннотацией, будет вызываться
сразу после вызова конструктора по умолчанию и внедрения всех ресурсов;
 - @PrePassivate – метод, отмеченный этой аннотацией, будет вызываться
перед пассивацией компонента, то есть, непосредственно перед его сериа-
лизацией и сохранением на диск;
 - @PostActivate – метод, отмеченный этой аннотацией, будет вызываться
сразу после того, как компонент будет прочитан в память, но перед вызовом
любых прикладных методов;
- @PreDestroy – метод, отмеченный этой аннотацией, будет вызываться пос-
ле истечения таймаута или явного вызова клиентом одного из методов с ан-
нотацией @Remove ; после этого экземпляр будет передан сборщику мусора
для утилизации.

Важно отметить, что вы не должны восстанавливать соединения с внедренными
ресурсами. В момент активации контейнер сам повторно внедрит все необходи-
мые ресурсы. Также автоматически будут восстановлены ссылки на любые другие
внедренные сеансовые компоненты с сохранением состояния. В методах-обработ-
чиках следует создавать или уничтожать только ресурсы, которыми вы управляе-
те вручную.


3.3.8. Эффективное использование сеансовых
компонентов с сохранением состояния

Так как информация о
сеансе сохраняется контейнером в оперативной памяти, то при попытке одновре-
менно обслужить тысяч пользователей с помощью компонентов с сохранением
состояния можно столкнуться с проблемой исчерпания памяти или чрезмерного
количества дисковых операций, связанных с пассивацией/активацией компонен-
тов.

Когда сеансовые компоненты с сохранением состояния используются в клас-
терном окружении, информация о состоянии копируется между разными экзем-
плярами контейнера EJB.

Правила пассивации обычно зависят от конкретной реализации. Неправиль-
ное использование политик пассивации (когда дается возможность настраивать
пассивацию) может вызывать проблемы производительности. Например, Oracle
Application Server пассивирует экземпляры компонентов, когда истекает макси-
мальное время простоя, по достижении числа активных экземпляров компонентов
некоторого порогового значения, а также по достижении верхней границы исполь-
зуемой памяти JVM.

Вы можете существенно облегчить проблему нехватки памяти, явно удаляя
ставшие ненужными экземпляры компонентов и не полагаясь, что контейнер уда-
лит их автоматически по истечении таймаута. Для этого каждый сеансовый ком-
понент с сохранением состояния должен иметь хотя бы один метод, отмеченный
аннотацией @Remove , который будет вызываться в конце многоходовой процеду-
ры, реализуемой компонентом .

--//--

3.4. Сеансовые компоненты-одиночки

Компоненты-одиночки близко напоминают компоненты без сохранения состоя-
ния. Они поддерживают обработку тех же событий жизненного цикла, но имеют и
свои, уникальные особенности, включая возможность управления параллельным
доступом, а также возможность определять цепочки для создания компонентов-
одиночек в определенной последовательности. Поддержка таких цепочек позво-
ляет одним компонентам зависеть от других. Как уже упоминалось, компоненты-
одиночки можно пометить, чтобы обеспечить их создание на этапе развертывания
приложения. В этом случае запуск приложения не будет считаться выполненным,
пока все отмеченные компоненты не будут успешно созданы.

3.4.1. Когда следует использовать сеансовые компоненты-одиночки

Компоненты-одиночки используются, когда требуется иметь некоторое общее
состояние, глобальное для всего приложения или для определенной задачи.

Компонент-одиночка,
настроенный на создание во время инициализации приложения, мог бы в цикле
осуществлять проверку готовности LDAP и тем самым гарантировать недоступ-
ность приложения, пока све внешние службы не запустятся и не будут готовы при-
нимать запросы.

Хотя создание централизованных пунктов обмена информацией противоречит
принципам создания масштабируемых приложений, иногда все же они бывают
необходимы.

3.4.2. Пример реализации «товара дня» в ActionBazaar

Так как эта ин-
формация по сути является статической, нет никакого смысла вновь и вновь из-
влекать ее из базы данных при каждом посещении веб-сайта. Обращение к базе
данных каждый раз создает ненужную нагрузку на саму базу данных и сеть. Один
из способов избежать этого заключается в том, чтобы кэшировать часто исполь-
зуемые данные.
Каждый из клиентов получает информацию о товаре дня из компонента-оди-
ночки. Этот компонент запоминает значение на запуске и затем обновляет его
в полночь.


@Singleton  // Пометить как сеансовый компонент-одиночку
@Startup     // Создает компонент на запуске
@DependsOn(“SystemInitializer”) // Определяет зависимость компонента
public class DefaultFeaturedItem implements FeaturedItem {
  private Connection connection;

  @Resource(name = “jdbc/ActionBazaarDataSource”)
  private DataSource dataSource;

  private Item featuredItem;
  
  @PostConstruct //  Этот метод вызывается сразу после создания
  public void init() {
    try {
      connection = dataSource.getConnection(); 
 
    } catch (SQLException sqle) {
    sqle.printStackTrace();
    }
    loadFeaturedItem();
  }


  // Запланировать обновление товара дня кажду полночь
  @Schedule(dayOfMonth=”*”,dayOfWeek=”*”,hour=”0”,minute=”0”,second=”0”)
  private void loadFeaturedItem() {
    featuredItem = ... загрузка информации о товаре из базы данных ...
  }

  @Override
  public Item getFeaturedItem() {
    return featuredItem;
  }
}

...

@Remote
public interface FeaturedItem {
  public Item getFeaturedItem();
}


Аннотация @Singleton превращает этот POJO в компонент-одиночку. Он
реализует прикладной интерфейс FeaturedItem. Аннотация @Startup сообщает
контейнеру, что компонент должен быть создан на этапе запуска приложения.
При этом компонент не должен создаваться раньше, чем будет создан компо-
нент-одиночка SystemInitializer. Экземпляр DefaultFeaturedItem будет
создан только после создания экземпляра SystemInitializer, затем контейнер
выполнит внедрение ресурсов и вызовет метод init, отмеченный аннотацией
@PostConstruct. Контейнер EJB также создаст таймер, который будет срабаты-
вать каждую полночь и вызывать метод, осуществляющий загрузку товара дня.
Таймеры EJB не являются особенностью компонентов-одиночек и будут обсуж-
даться в главе 5.

3.4.3. Применение аннотации @Singleton

Определение аннотации @Singleton ничем не отличается от определения аннотаций
@Stateless и @Stateful.

3.4.4. Управление конкуренцией в компоненте-одиночке

Так как к компоненту-одиночке может обратиться сразу несколько клиентов,
возникает проблема разграничения доступа. Существует две разновидности под-
держки конкуренции в компонентах-одиночках: на уровне контейнера и на уров-
не компонента. По умолчанию (если не указано иное) управление конкуренци-
ей осуществляется на уровне контейнера.

- @ConcurrencyManagement (ConcurrencyManagementType.BEAN) – управ-
ление конкуренцией осуществляется на уровне компонента;
- @ConcurrencyManagement(ConcurrencyManagementType.CONTAINER) –
управление конкуренцией осуществляется на уровне контейнера.

Аннотация @ConcurrencyManagement должна помещаться в определение клас-
са компонента, а не в прикладной интерфейс:

@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
  public @interface ConcurrencyManagement {
  public ConcurrencyManagementType value() default
    ConcurrencyManagementType.CONTAINER;
}


*. Управление конкуренцией на уровне контейнера

По умолчанию используется управление конкуренцией на уровне контейне-
ра – доступ ко всем методам компонента упорядочивается посредством блокиро-
вок для записи.

В спецификации EJB определяется
две аннотации, с помощью которых можно сообщить контейнеру о желаемом по-
ведении блокировки:

 - @Lock (LockType.READ) – метод, отмеченный этой аннотацией будет одно-
временно доступен множеству клиентов, пока кто-то не приобретет блоки-
ровку для записи;
 - @Lock(LockType.WRITE) – при вызове метода будет устанавливаться бло-
кировка для записи, поэтому метод всегда будет выполняться только в кон-
тексте одного потока.
Если не указана ни одн

Так как
вызов метода компонента-одиночки может привести к блокировке вызывающего
кода, предусмотрен механизм разблокировки по таймауту, чтобы исключить воз-
можность блокировки навечно. По истечении таймаута возбуждается исключение
javax.ejb.ConcurrentAccessTimeoutException . Это исключение времени вы-
полнения, соответственно вызывающий код не сможет перехватить его. Для опре-
деления величины таймаута служит аннотация @AccessTimeout . Она определена,
как показано ниже:

@Target(value = {ElementType.METHOD, ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface AccessTimeout {
  public long value();
  public TimeUnit unit() default TimeUnit.MILLISECONDS;
}


*. Управление конкуренцией на уровне компонента

Выбирая способ управления конкуренцией на уровне компонента, все хлопоты,
связанные с этим, вы берете на себя. При этом вы можете использовать примити-
вы управления конкуренцией, имеющиеся в языке Java, такие как synchronized ,
volatile , wait , notify и так далее, или легендарный API java.util.concurrent

На практике предпочтение
управлению конкуренцией на уровне компонента следует отдавать, только если
необходимо организовать более тонкое разделение, чем позволяют механизмы на
уровне контейнера, что случается очень редко.


3.4.5. Прикладной интерфейс компонента

Сеансовые компоненты-одиночки поддерживает те же возможности для приклад-
ных интерфейсов, что и сеансовые компоненты без сохранения состояния. Можно
определять удаленные и локальные интерфейсы, а также интерфейсы веб-служб
(SOAP и REST) с помощью аннотаций @Local , @Remote или @WebService , соот-
ветственно.

Единственное существенное отличие между прикладными интерфейсами ком-
понентов-одиночек и сеансовых компонентов без сохранения состояния состоит
в возможности применения следующих аннотаций к объявлениям методов в ин-
терфейсах:
 - @Lock (LockType.READ) ;
 - @Lock(LockType.WRITE) ;
 - @AccessTimeout .
Все три эти аннотации производят эффект, только при управлении конкуренци-
ей на уровне контейнера

3.4.6. События жизненного цикла

Сеансовые компоненты-одиночки имеют самый простой жизненный цикл среди
всех компонентов. После создания они не уничтожаются до завершения прило-
жения. Сложности в их жизненном цикле возникают, только когда между ними
имеются зависимости.


1. Контейнер создает новый экземпляр компонента-одиночки на этапе запус-
ка приложения, если этот компонент помечен аннотацией @Startup или
указан в виде зависимости ( @DependsOn ) другого компонента. Обычно со-
здание компонентов-одиночек откладывается до момента первого обраще-
ния к ним.
2. Когда конструктор компонента завершится, контейнер внедряет ресурсы,
такие как контексты JPA, источники данных и другие компоненты.
3. Вызывается метод, отмеченный аннотацией @PostConstruct . Компонент
остается недоступным, пока этот метод не завершится успехом.
4. Экземпляр компонента хранится в памяти, ожидая обращений к его методам.
5. Клиент вызывает прикладной метод посредством прикладного интерфейса.
6. Контейнер информируется, что он должен прекратить работу.
7. Перед завершением он вызывает метод компонента, отмеченный аннотаци-
ей @PreDestroy .


Компонент-одиночку можно пометить аннотацией @DependsOn . Эта аннотация
определяет зависимость одного компонента от другого. Когда создается экземп-
ляр компонента, предварительно создаются все его зависимости. Как предпола-
гается, когда один компонент зависит от другого, этот другой компонент должен
выполнить какие-то настройки окружения. Ниже приводится определение анно-
тации @DependsOn :

@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface DependsOn {
  public String[] value();
}

Эта аннотация помещается перед объявлением класса компонента и принима-
ет одно или более имен компонентов-одиночек, которые должны быть созданы
перед этим компонентом.


3.4.7. Аннотация @Startup

Одной из ключевых особенностей компонентов-одиночек является возможность
их автоматического запуска в процессе развертывания приложения. Для этого120
Глава 3. Реализация прикладной логики с помощью сеансовых...
компонент-одиночка должен быть отмечен аннотацией @Startup . Эта аннотация
определена, как показано ниже:

@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
  public @interface Startup {
}

Сама аннотация не имеет параметров. Она просто устанавливает признак, кото-
рый будет проверен контейнером.

3.4.8. Эффективное использование сеансовых компонентов-одиночек

*. Выбор типа конкуренции

Управление конкуренцией на уровне контейнера является наиболее предпочти-
тельным для подавляющего большинства компонентов. В этом случае задача син-
хронизации полностью возлагается на контейнер. Сделав выбор в пользу контей-
нера, вы получаете возможность отмечать методы аннотациями @Lock (LockType.
READ) и @Lock(LockType.WRITE) .

*. Настройка управления конкуренцией на уровне контейнера

компонент-одиночка должен разделять операции записи ( @Lock(LockType.
WRITE) ) и чтения ( @Lock(LockType.READ) ). Метод, осуществляющий запись, из-
меняет данные и потому должен выполняться под защитой исключительной бло-
кировки. Метод, осуществляющий чтение, не требует такой строгой меры и может
одновременно обслуживать множество клиентов. Если операция записи требует
значительного времени, соответствующий метод должен быть отмечен аннотаци-
ей @AccessTimeout , чтобы избежать возможности блокирования кода на неопре-
деленное время.

*. Управление автозапуском компонентов-одиночек

Если отметить класс компонента-одиночки аннотацией
@Startup , экземпляр этого компонента будет создаваться автоматически в ходе
развертывания приложения. Следует особенно подчеркнуть, что экземпляр со-
здается во время развертывания приложения. Контейнеры, такие как GlassFish,
возбуждают исключение java.lang.IllegalAccessException , если компо-
нент-одиночка пытается обратиться к сеансовому компоненту с сохранением или
без сохранения состояния из метода, отмеченного аннотацией @PostConstruct .
В этот момент другие компоненты могут быть еще не доступны, но вы можете
пользоваться услугами JPA и выполнять операции с базой данных.

*. Обработка исключений

Если приложение может работать неделями, необходимо пре-
дусмотреть обработку вероятных ошибок. Если компонент открывает соединение
с другой системой, в какой-то момент это соединение может оказаться разорван-
ным – отнеситесь с особым вниманием к таймаутом.

--//--

3.5. Асинхронные сеансовые компоненты

В EJB 3.1 появилась поддержка асинхронных компонентов в виде аннотации
@Asynchronous . Это не какой-то новый тип сеансовых компонентов, а скорее но-
вая функциональная возможность, которую можно добавлять в любые сеансовые
компоненты. Эта новая особенность позволяет методам прикладного интерфейса,
вызываемым клиентами действовать асинхронно, в отдельных потоках выполне-
ния.

Название «асинхронные сеансовые компоненты» является несколько неточ-
ным. Сами компоненты не являются асинхронными – асинхронными являются
их методы. Аннотацией @Asynchronous можно отмечать отдельные методы или
весь класс. Когда вызывается асинхронный метод или метод асинхронного класса,
контейнер запускает отдельный поток выполнения.

3.5.1. Основы асинхронного вызова

Значения, возвращаемые асинхронными методами,
могут иметь тип void или java.util.concurrent.Future<V> . Вследствие этого
имеется два варианта использования: «запустить и забыть» ( void ) или «запустить
и проверить ответ позднее» ( Future<V> ). Только методы, возвращающие значение
типа Future<V> , могут декларировать исключения. Когда асинхронный метод воз-
буждает исключение, оно перехватывается и повторно возбуждается при вызове
метода get() объекта Future . Оригинальное исключение при этом будет заверну-
то в ExecutionException . Если исключение возбуждается асинхронным методом
не имеющим возвращаемого значения ( void ), оно будет потеряно и вызывающий
код никогда не узнает о нем.

Важно отметить, что транзакции не распространяют свое действие на асин-
хронные методы – при вызове асинхронного метода запускается новая транзак-
ция. Напротив, действие механизма поддержки безопасности распространяется и
на асинхронные методы

3.5.2. Когда следует использовать асинхронные сеансовые компоненты

Асинхронные сеансовые компоненты следует использовать только в двух ситуа-
циях :
 - когда операция выполняется продолжительное время и желательно иметь
возможность запустить ее и продолжить заниматься другими делами, не за-
висящими от того, что произойдет в процессе выполнения этой операции;
 - когда операция выполняется продолжительное время и желательно иметь
возможность запустить ее, а позже проверить результат или отменить опе-
рацию на полпути;

Асинхронные сеансовые компоненты, как предполагалось, должны быть мак-
симально легковесными, поэтому они не дают никаких гарантий надежности. Из
этого следует, что если контейнер потерпит аварию в тот момент, когда выпол-
няется асинхронный метод, этот метод не сможет восстановиться после ошибки.

3.5.3. Пример компонента ProcessOrder


@Stateless(name = “processOrder”)
public class OrderService {

  private String CONFIRM_EMAIL = “actionbazaar/email/confirmation.xhtml”;

  @EJB
  private EmailService emailService;

  @EJB
  private BillingService billingService;

  public void processOrder(Order order) {
    String content;
    try {
      URL resource = OrderService.class.getResource(CONFIRM_EMAIL);
      content = resource.getContent().toString();

      // Асинхронно отправить подтверждение на электронную почту
      emailService.sendEmail(order.getEmailAddress(), “Winning Bid Confirmation”,content);

      // Асинхронно перевести деньги с кредитной карты
      Future<Boolean> success = billingService.debitCreditCard(order);
        // Выполнить другие операции, такие как запись в базу данных
        if(!success.get()) {
          // обработать ошибку 
        }
      } catch (IOException ex) {
        Logger.getLogger(OrderService.class.getName()).log(Level.SEVERE,
                         null, ex);
      }
  }
}



@Stateless(name = “emailService”)
public class EmailService {

  Logger logger = Logger.getLogger(AuthenticateBean.class.getName());

  @Resource(name=”config/emailSender”)
  private String emailSender;

  @Resource(name = “mail/notification”)
  private Session session;

  // Сообщить контейнеру, что метод должен выполняться в отдельном потоке
  @Asynchronous
  // Ничего не возвращает – “запустил и забыл”
  public void sendEmail(String emailAddress, String subject,
    String htmlMessage) {
    try {
      MimeMessage message = new MimeMessage(session);
      message.setFrom(new InternetAddress(emailSender));
      InternetAddress[] toAddress = new InternetAddress[] {
        new InternetAddress(emailAddress) 
      };
      message.setRecipients(Message.RecipientType.TO, toAddress);
      message.setSubject(subject);
      message.setContent(createHtmlMessage(htmlMessage));
      Transport.send(message);
    } catch (Throwable t) {
      logger.log(Level.SEVERE, null,t);
    }
  }
  ...
}



@Stateless(name=”billingService”)
@Asynchronous // Пометить класс как асинхронный
public class BillingService {

  // Внедрить SessionContext для регистрации отмены операции
  @Resource
  private SessionContext sessionContext;

  // Возвращаемое значение типа Future<Boolean>
  public Future<Boolean> debitCreditCard(Order order) {
    boolean processed = false;
    // Проверить факт отмены операции
    if(sessionContext.wasCancelCalled()) {
      return null;
    }
    // Выполнить операцию с кредитной картой
    // Завернуть результат в реализацию Future
    return new AsyncResult<Boolean>(processed);
  }
}


3.5.4. Применение аннотации @Asynchronous

Аннотация @Asynchronous является одной из самых простых, среди рассматри-
вавшихся в этой главе. Она не имеет параметров и может применяться и к классу,
и к отдельным методам. Если аннотация применяется к классу, все методы этого
класса будут вызываться асинхронно.

Данную аннотацию можно исполь-
зовать с любыми компонентами, представленными в этой главе: с сохранением
состояния, без сохранения состояния и одиночкам. Она имеет следующее опре-
деление:

@Target(value = {ElementType.METHOD, ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Asynchronous {
}

3.5.5. Применение интерфейса Future

Чтобы иметь возможность получить результат асинхронного метода, из него 
следует вернуть объект, реализующий интерфейс java. util.concurrent.Future. 
Интерфейс Future имеет следующие методы:
 - boolean cancel(boolean mayInterruptIfRunning) – отменяет операцию;
 - V get() – возвращает значение и блокируется, пока результат не станет доступен;
 - V get(long timeout, TimeUnit unit) – возвращает результат или null , если 
 результат оказался недоступен в течение указанного интервала времени;
 - boolean isCancelled() – возвращает true , если операция была отменена;
 - boolean isDone() – возвращает true , если метод завершился.

3.5.6. Эффективное использование асинхронных сеансовых компонентов

Обратите особое внимание на утечки потоков – если поток терпит
ошибку при попытке завершиться, он может продолжать крутиться вхолостую до
завершения приложения.

Асинхронные операции, возвращающие результат, должны поддерживать
возможность отмены. Это позволяет клиентам прервать выполнение операции
на полпути, что особенно важно для продолжительных операций. Внутри асин-
хронного метода компонента можно вызвать метод wasCancelCalled() объекта
SessionContext , чтобы определить, не отменили ли операцию клиент посредст-
вом объекта Future . Этот метод следует вызывать в цикле и перед вызовом бло-
кирующих методов .

В ситуациях, когда требуется знать,
преуспела ли асинхронная операция, она должна возвращать объект Future , а
вызывающий код должен проверять его и обрабатывать ошибки.

--//--

2.6. В заключение

  --- 

--//-------------------------------------------------------------------------

# Глава 4.
# Обмен сообщениями
# и разработка компонентов MDB

Сначала
мы познакомим вас с базовыми понятиями обмена сообщениями и займемся ис-
следованием основ Java Messaging Service (JMS) на примере создания компонента,
посылающего сообщения. Затем мы перейдем к компонентам MDB и посмотрим,
как EJB 3 упрощает задачу создания компонентов-приемников сообщений.


4.1. Концепции обмена сообщениями

Большинство
взаимодействий между компонентами – например, между сеансовыми компонен-
тами без сохранения состояния – являются синхронными и образующими тесные
связи. Компонент-отправитель непосредственно вызывает метод компонента-по-
лучателя и ожидает завершения метода. Для успешного взаимодействия должны
присутствовать обе стороны. В случае обмена сообщениями дело обстоит иначе:
отправитель не знает, когда сообщение будет получено, и даже не может указать,
какой компонент должен обработать то или иное сообщение. Зато механизм об-
мена сообщениями в Java EE обеспечивает надежную доставку и гарантирует, что
сообщение не будет потеряно на пути от отправителя к получателю.

4.1.1. Промежуточное ПО передачи сообщений

MOM (Message-Oriented Middleware) – это программное обеспечение, гаранти-
рующее надежную доставку сообщений между разными системами.

Когда выполняется от-
правка сообщения, программное обеспечение MOM сохраняет его в месте, извест-
ном отправителю и получателю. Отправитель сообщения называется производи-
телем (producer), а местоположение, где будет храниться сообщение – адресом
(destination). Позднее любой программный компонент, заинтересованный в полу-
чении сообщений, по указанному адресу сможет получить непрочитанные сооб-
щения. Программные компоненты, принимающие сообщения, называются потре-
бителями (consumers).

4.1.2. Обмен сообщениями в ActionBazaar

системы MOM повышают надежность, поддерживая транзакции
и подтверждения о приеме и доставке сообщений.

4.1.3. Модели обмена сообщениями

Модель обмена сообщениями – это шаблон, определяющий порядок обмена сооб-
щениями между отправителями и получателями. Механизм JMS поддерживает
две стандартные модели: точка–точка (Point-To-Point, PTP) и издатель–подпис-
чик (publish–subscribe). Приложение может использовать какую-то одну или обе
модели сразу – в зависимости от того, как должен протекать обмен сообщениями.

*. Точка–точка

В схеме точка–точка (PTP), единственное сообщение передается от единствен-
ного производителя (точка А) единственному потребителю (точка Б). В системе
может существовать множество производителей и потребителей, но только один
потребитель сможет обработать каждое конкретное сообщение. Адреса в схеме
PTP называют очередями (queues). Производитель записывает сообщение в оче-
редь, а потребитель извлекает его из очереди. Схема PTP не гарантирует доставку
сообщений в каком-то определенном порядке – термин очередь здесь носит чисто
символический характер.

*. Издатель–подписчик

Модель издатель–подписчик напоминает традиционную службу доставки га-
зет. Как показано на рис. 4.5, единственный производитель генерирует сообщение,
которое может принять любое число потребителей, которые подключены в этот
момент к адресу. Адреса сообщений в данной модели называют темами (topics),
а потребители – подписчиками .

Каждый подписавшийся на тему получит свою копию сообщения

*. Модель запрос–ответ

Возможно у вас появится желание реализовать в приложении ActionBazaar прием под-
тверждения от службы Turtle, как только она извлечет сообщение из очереди.

В таких ситуациях удобно использовать модель запрос–ответ. В этой модели требуется
включить в сообщение дополнительную информацию, чтобы потребитель знал, куда и
как послать подтверждение. Такую модель часто называют многоуровневой, потому что
обычно она реализуется поверх одной из двух моделей, описанных выше.

Например, в модели PTP отправитель указывает очередь, куда следует послать ответ
(в JMS такая очередь называется очередью для ответа), а также уникальный идентифи-
катор, общий для исходящего и входящего сообщений (в JMS называется согласующим
идентификатором (correlation ID)). Получатель принимает исходное сообщение и от-
правляет ответ в очередь для ответов, копируя согласующий идентификатор. Отправи-
тель принимает сообщение из очереди для ответов и по согласующему идентификатору
определяет, в ответ на какое сообщение было получено подтверждение.

--//--

4.2. Введение в JMS


@Inject // Простая аннотация CDI
        // Используемая фабрика очередей
@JMSConnectionFactory(“jms/QueueConnectionFactory”)
private JMSContext context;  // Упрощенный интерфейс JMS

@Resource(name=”jms/ShippingRequestQueue”) // Используемая очередь
private Destination destination;

ShippingRequest shippingRequest = new ShippingRequest();       // Запрос
shippingRequest.setItem(“item”);                               // ShippingRequest 
ShippingRequest shippingRequest.setShippingAddress(“address”); // посылаемый
shippingRequest.setShippingMethod(“method”);                   // в
shippingRequest.setInsuranceAmount(100.50);                    // сообщении

ObjectMessage om = context.createObjectMessage(); // JMSObjectMessage для
om.setObject(shippingRequest);                    // отправки ShippingRequest 

JMSProducer producer = context.createProducer();  // JMSProducer,
producer.send(destination, om);                   // выполняющий отправку


о мере описания каждого этапа, выполняемого этим кодом, мы познакомимся
со значительной частью JMS API и и шаблонами использования. Для простоты из
этого примера мы удалили код, осуществляющий обработку исключений.

*. Получение фабрики соединений и адреса

JMS ресурсы сервера сообщений напоминают объекты javax.sql.DataSource
в JDBC. Эти ресурсы хранятся в реестре JNDI, они создаются и настраиваются за
пределами программного кода, обычно посредством конфигурационных файлов
XML или административной консоли.

В JMS имеется два основных типа ресур-
сов: javax.jms.JMSContext  и javax.jms.Destination , которые оба исполь-
зуются в листинге 4.1. Ссылка на объект JMSContext приобретается с помощью
механизма внедрения зависимостей, с помощью CDI-аннотации @Inject , а
настройка JMSContext на соединение с фабрикой выполняется с помощью ан-
нотации @JMSConnectionFactory . Объект JMSContext обертывает javax.jmx.
ConnectionFactory и javax.jmx.Session в один объект. Класс JMSContext был
введен в состав EE 7 для упрощения JMS-операций и для ослабления ограниче-
ния «один-сеанс-на-соединение» в окружениях EE (это ограничение отсутствует
в приложениях SE). Далее с помощью аннотации @Resource выполняется внед-
рение очереди для отправки сообщений, имя которой ShippingRequestQueue в
точности соответствует назначению.
Этот пример кода взят из сервлета, использующего аннотации для внедре-
ния зависимостей. Контейнер сервлета автоматически отыскивает ресурсы, заре-
гистрированные в JNDI, и внедряет их.

*. Подготовка сообщения

В этом примере требуется отправить компании Turtle сериализуемый Java-объ-
ект ShippingRequest . Для этого создается новый экземпляр объекта и заполня-
ется необходимыми данными r. После этого требуется указать тип JMS-сообще-
ния, чтобы отправить этот объект. Наиболее подходящим типом является javax.
jms.ObjectMessage . С помощью JMSContext мы создаем объект ObjectMessage
и включаем в него объект ShippingRequest s. Теперь, когда сообщение готово к
отправке, остается только отправить его.

*. Отправка сообщения

Отправка сообщения осуществляется с помощью JMSProducer . В процессе
подготовки сообщения мы получили JMSContext , который предоставляет воз-
можность создания объекта-производителя. Достаточно просто вызвать метод
createProducer и отправить только что созданное сообщение

*. Освобождение ресурсов

Самое замечательное в механизме внедрения зависимостей, поддерживаемом
управляемым окружением, состоит в том, что контейнер автоматически решает
многие важнейшие задачи. Освобождение ресурсов – одна из них. Предыдущий
фрагмент кода взят из сервлета, соответственно JMSContext является ресурсом,
управляемым контейнером. Это означает, что контейнер автоматически закроет ре-
сурс.

4.2.1. Интерфейс JMS Message

Интерфейс Message стандартизует разные типы сообщений, которые могут пере-
даваться между разными провайдерами JMS. Как показано на рис. 4.6, сообщение
JMS состоит из следующих элементов: заголовок сообщения, свойства сообщения
и тело сообщения. Все эти составляющие описываются в следующих разделах.

*. Заголовки сообщения

Заголовки – это пары имя/значение, общие для всех сообщений.
Например, аналогом штемпеля на сообщении
JMS является заголовок JMSTimestamp . Система MOM сохраняет в этом заголов-
ке время отправки сообщения.
Ниже перечислены некоторые наиболее часто используемые заголовки JMS:
 - JMSCorrelationID;
 - JMSReplyTo;
 - JMSMessageID.

*. Свойства сообщений

Свойства сообщений схожи с заголовками, но в отличие от последних не явля-
ются стандартными и должны явно устанавливаться приложением.

пример:

Message.setBooleanProperty(“Fragile”, true);

Свойства могут иметь тип boolean , byte , double , float , int , long , short ,
String или Object .

*. Тело сообщения

Тело сообщения содержит содержимое конверта – это «полезный груз» сообще-
ния. Содержимое тела сообщения определяет тип этого сообщения.

В листинге ранее
использовался тип javax.jms.ObjectMessage , потому что требовалось отправить
Java-объект ShippingRequest . Можно также использовать типы BytesMessage ,
MapMessage , StreamMessage и TextMessage . Каждый из этих типов сообщений
имеет свой интерфейс и шаблон использования. Не существует каких-то жест-
ких правил, определяющих тип сообщения. Исследуйте все возможные варианты,
прежде чем сделать выбор

--//--

4.3. Использование компонентов MDB

MDB – это компоненты EJB, предназначенные для приема асинхронных сооб-
щений. Хотя компоненты MDB способны обрабатывать самые разные виды сооб-
щений (см. врезку «Соединители JCA и обмен сообщениями» ниже), мы в первую
очередь сосредоточимся на применении компонентов MDB для обработки сооб-
щений JMS, потому что именно для этого они используются чаще всего.

4.3.1. Когда следует использовать обмен сообщениями и компоненты MDB

Компоненты MDB следует ис-
пользовать, только если действительно необходима асинхронная обработка, слабая
связанность и высокая надежность.

В случае с MDB, сообщение JMS не удаляется из промежуточ-
ного хранилища, пока компонент MDB не завершит его обработку. Если во время
обработки в компоненте MDB возникнет исключение, сообщение может быть об-
работано повторно, когда контейнер будет готов к этому.

4.3.2. Почему следует использовать MDB?

*. Многопоточность

Вашему бизнес-приложению могут потребоваться многопоточные потребители
сообщений, способные параллельно обрабатывать по нескольку сообщений и тем
самым обеспечить максимальную пропускную способность. Компоненты MDB
помогут избежать лишних сложностей, потому что они изначально поддержи-
вают многопоточность, без необходимости писать дополнительный код.

*. Простота использования

Компоненты MDB избавляют от механического кодирования типовых опера-
ций с сообщениями JMS, таких как: получение фабрик соединений или адресов,
создание соединений, открытие сеансов, создание потребителей и регистрация
приемников.

*. Надежность обработки сообщений

Все компоненты MDB по умолчанию пользуются транзакциями и подтверждают
окончание обработки сообщений. Как следствие, сообщения не удаляются сервером
сообщений, пока метод компонента MDB, вызванный для обработки сообщения,
не завершится благополучно. Если в процессе обработки возникнет ошибка, будет
выполнен откат транзакции и получение сообщения не будет подтверждено. Так как
компоненты MDB пользуются транзакциями JTA, любые изменения в базе данных,
произведенные в ходе обработки сообщения, также автоматически будут отменены.

Как результат, неподтвержденное сообщение может быть повторно передано для
обработки другому компоненту MDB. В случае успешной обработки изменения в
базе данных будут подтверждены, а сообщение будет удалено сервером сообщений,
причем все эти операции будут выполнены атомарно, в рамках одной транзакции.

*. Запуск механизма приема сообщений

Чтобы запустить механизм приема сообщений из очереди с запросами на до-
ставку, кто-то должен вызвать соответствующий метод в вашем коде. Не совсем
понятно, как этого добиться в промышленном окружении.
Будет описание этой проблемы дальше в книге.

4.3.3. Разработка потребителя сообщений с применением MDB

Давайте теперь займемся созданием компонента MDB и реализуем сервер при-
ема сообщений для транспортной компании Turtle. В листинге 4.2 приводится
код реализации компонента MDB, который извлекает из очереди запросы на
доставку и сохраняет каждый запрос в базе данных компании Turtle, в таблице
SHIPPING_REQUEST .


// Это, мега аннотация для класса [ TurtleShippingRequestMessageBean ]
@MessageDriven(activationConfig = {                             // Настройка
  @ActivationConfigProperty(propertyName = “destinationType”,   // очереди
    propertyValue = “javax.jms.Queue”),                         // сообщений
  @ActivationConfigProperty(propertyName = “destinationLookup”, // в
    propertyValue = “jms/ShippingRequestQueue”)                 // компоненте
})

// Реализует интерфейс MessageListener для обработки сообщений JMS
public class TurtleShippingRequestMessageBean implements MessageListener{

  @PersistenceContext()         // Внедрение диспетчера EntityManager      
  EntityManager entityManager;  // для сохранения данных в базе

  @Override
  public void onMessage(Message message){ // Реализация метода onMessage
    try {
      ObjectMessage om = (ObjectMessage) message;                        // Извлечение
      Object o = om.getObject();                                         // данных, отправленных
      ActionBazaarShippingRequest sr = (ActionBazaarShippingRequest) o;  // из ActionBazaar

      Logger.getLogger(TurtleShippingRequestMessageBean.class.getName())
            .log(Level.INFO, String.format(“Got message: %s”, sr));

      // Преобразование данных из ActionBazaar в данные Turtle
      TurtleShippingRequest tr = new TurtleShippingRequest();
      tr.setInsuranceAmount(sr.getInsuranceAmount());
      tr.setItem(sr.getItem());
      tr.setShippingAddress(sr.getShippingAddress());
      tr.setShippingMethod(sr.getShippingMethod());

      // Сохранение запроса в базе данных Turtle
      entityManager.persist(tr);
    } catch (JMSException ex) {
      Logger.getLogger(TurtleShippingRequestMessageBean.class.getName())
            .log(Level.SEVERE, null, ex);
    }
  }
}


Аннотация @MessageDriven превращает данный объект в компонент MDB
и определяет его настройки, включая тот факт, что он подключается к очереди
jms/ShippingRequestQueue . Вспомните, как во врезке «Соединители JCA и об-
мен сообщениями» (выше) говорилось, что компоненты MDB могут принимать и
другие типы уведомлений, отличные от сообщений JMS. Но в данном примере, как
видно из листинга, компонент MDB реализует интерфейс MessageListener.
Для реализации интерфейса MessageListener необходимо определить ме-
тод onMessage. Сам метод достаточно прост. Сначала он извлекает объект
ActionBazaarShippingRequest из сообщения ObjectMessage. Напомним, что
объект ActionBazaarShippingRequest содержит данные, отправленные прило-
жением ActionBazaar транспортной компании Turtle, составляющие запрос на
доставку. Затем данные в объекте ActionBazaarShippingRequest преобразуются
в объект TurtleShippingRequest. Преобразование данных, как в данном при-
мере, часто используется на практике с целью сохранить их в базе данных для
последующей обработки. В заключение в работу включается EntityManager для
сохранения данных в базу.


4.3.4. Применение аннотации @MessageDriven

Компоненты MDB являются одними из самых простых компонентов
EJB с точки зрения разработчика, и поддерживают самое маленькое чис-
ло аннотаций. Аннотация @MessageDriven и вкладываемая в нее аннотация
@ActivationConfigProperty являются единственными, имеющими отношение к
компонентам MDB. Аннотация @MessageDriven определена следующим образом:


@Target(value = {ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface MessageDriven {
  String name() default “”;
  Class messageListenerInterface default Object.class;
  ActivationConfigProperty[] activationConfig() default {};
  String mappedName();
  String description();
}


Первый параметр, name , определяет имя компонента MDB на случай, если по-
требуется явно связать его. Если аргумент name отсутствует, по умолчанию исполь-
зуется имя класса, в данном случае: TurtleShippingRequestMessageBean . Второй
параметр, messageListenerInterface , определяет, какой интерфейс приемника
сообщений реализует компонент MDB. Третий параметр, activationConfig , ис-
пользуется для определения настроек приемника конкретного типа.


4.3.5. Реализация интерфейса MessageListener

Контейнер использует интерфейс MessageListener , реализованный компо-
нентом MDB, для регистрации этого компонента MDB с помощью провайде-
ра JMS. После регистрации провайдер сможет передавать входящие сообще-
ния компоненту, вызывая его методы. Параметр messageListenerInterface
аннотации @ MessageDriven – это единственный способ определить интерфейс
MessageListener . Следующий фрагмент демонстрирует, как это делается:
@MessageDriven(
messageListenerInterface=”javax.jms.MessageListener”)
public class ShippingRequestProcessor {
Но на практике этот параметр используется редко, а интерфейс определяется с по-
мощью ключевого слова interface , как это сделано в примере выше где мы просто 
реализовывали в классе этот интерфейс.

Интерфейс MessageListener можно также объявить в дескрипторе разверты-
вания и убрать упоминание о нем из программного кода:
<ejb-jar...>
  <enterprise-beans>
    <message-driven>
      ...
      <messaging-type> javax.jms.MessageListener</messaging-type>
    </message-driven>
  </enterprise-beans>
</ejb-jar>


4.3.6. Использование параметра ActivationConfigProperty

Параметр ActivationConfigProperty аннотации @MessageDriven дает возмож-
ность включать дополнительные настройки для провайдера в виде массива эк-
земпляров ActivationConfigProperty . Интерфейс ActivationConfigProperty
определен, как показано ниже:


@Target(value = {})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface ActivationConfigProperty {
  String propertyName();
  String propertyValue();
}


Каждый экземпляр представляет собой пару имя/значение, используемую про-
вайдером для настройки компонента MDB. Проще всего объяснить, как действуют
эти настройки, на простом примере. Ниже мы определяем две наиболее типичные
настройки активации JMS: destinationType и destinationLookup :

@MessageDriven(activationConfig = {

  @ActivationConfigProperty(propertyName = “destinationType”,
    propertyValue = “javax.jms.Queue”),

  @ActivationConfigProperty(propertyName = “destinationLookup”,
    propertyValue = “jms/ShippingRequestQueue”)

})


Первая настройка, свойство destinationType , сообщает контейнеру, что этот
компонент MDB принимает сообщения из очереди. Если бы вместо очереди ком-
понент подключался к теме, в качестве значения следовало бы указать javax.jms.
Topic . Настройка destinationLookup определяет адрес, с которого принимаются
сообщения, с JNDI-именем jms/ShippingRequestQueue .

Важно помнить, что эти настройки определены в спецификации JMS 2.0 для
потребителей сообщений JMS. Если вы создаете компоненты MDB для потреб-
ления разнотипных сообщений, настройки активации, специфичные для одного
провайдера, могут быть несовместимы с другим провайдером.


*. Режим подтверждения

Сообщения остаются в очереди JMS, пока потребитель не подтвердит их полу-
чение. Существует множество «режимов» подтверждения сообщений. По умолча-
нию используется режим Auto-acknowledge , который подразумевает автомати-
ческое подтверждение сообщений. Именно такой режим будет выбран в примере
выше, потому что в нем отсутствует явное определение иного значения настрой-
ки acknowledgeMode .

@ActivationConfigProperty {
  propertyName=”acknowledgeMode”
  propertyValue=”Dups-ok-acknowledge”


*. Длительность подписки

Если компонент MDB принимает сообщения из темы, можно указать, будет ли
эта подписка долговременной или краткосрочной.
Напомним, что в схеме «издатель–подписчик» каждое сообщение передается
всем потребителям, подписанным в данный момент на тему.

кто не подклю-
чен к теме в момент появления сообщения, не получит его копию. Исключением
из этого правила являются подписчики, оформившие продолжительную подписку
(durable subscription).
Если потребитель оформил продолжительную подписку на тему, все сообще-
ния, отправленные в эту тему, гарантированно будут доставлены ему. Если такой
подписчик не был подключен к теме в момент доставки сообщения, система MOM
будет хранить копию, пока подписчик не подключится и не получит сообщение.
Ниже показано, как оформить продолжительную подписку:

MessageConsumer orderSubscriber = session.createDurableSubscriber(
  orderTopic, “OrderProcessor”);

Аннулировать подписку можно
следующим способом:
session.unsubscribe(“OrderProcessor”);


*. Селектор сообщений

Параметр messageSelector позволяет определять селекторы сообщений в
компонентах MDB, действующие параллельно низкоуровневым селекторам JMS.
В нашем примере потребитель получает все сообщения, поступающие на указан-
ный адрес. При желании вы можете организовать фильтрацию сообщений с помо-
щью селектора сообщений (message selector) – критерии, указанные в селекторе,
применяются к заголовкам и свойствам сообщений и определяют желаемые ха-
рактеристики.


@ActivationConfigProperty
  propertyName=”messageSelector”
  propertyValue=”Fragile is TRUE”)


Как вы наверняка заметили, синтаксис селекторов практически идентичен
предложению WHERE в языке SQL, только в роли имен столбцов таблиц в базе
данных здесь выступают имена заголовков и свойств сообщений. Выражения в
селекторах могут быть сколько угодно сложными. Они могут включать литералы,
идентификаторы, пробелы, выражения, стандартные скобки, логические опера-
торы и операторы сравнения, арифметические операторы и сравнение с пустым
значением (null).


4.3.7. События жизненного цикла

Как и сеансовые компоненты без сохранения состояния, о которых рассказыва-
лось в главе 3, компоненты MDB имеют простой жизненный цикл (см. рис. 4.8).
Для каждого компонента MDB контейнер:

 - создает экземпляры MDB;
 - внедряет ресурсы, включая контекст, управляемый сообщениями (message-
driven context), о котором подробно рассказывается в главе 5;
 - помещает экземпляры в управляемый пул (если поддерживается контей-
нером; в противном случае новые экземпляры создаются по мере необхо-
димости);
 - извлекает простаивающий компонент из пула по прибытии сообщения
(в этот момент контейнер может увеличить размер пула);
 - вызывает метод обработки сообщения – например, метод onMessage ;
 - когда метод onMessage завершится, экземпляр компонента помещается об-
ратно в пул;
 - по мере необходимости удаляет компоненты из пула (и уничтожает их).

Но теперь возника-
ет другой вопрос: а может ли компонент MDB отправлять сообщения? Ответ: да.


4.3.8. Отправка сообщений JMS из компонентов MDB

По иронии, одна из задач, которую вам снова и снова придется выполнять в компо-
нентах MDB – это отправка сообщений JMS.


К счастью, вы уже знаете, как послать сообщение JMS (см.
листинг 4.1). Для этого нужно внедрить очередь с именем jms/ShippingErrorQueue
и фабрику соединений с именем jms/QueueConnectionFactory :

@Inject
@JMSConnectionFactory(“jms/QueueConnectionFactory”)
private JMSContext context;

@Resource(name=”jms/ShippingErrorQueue”)
private Destination errorQueue;

После этого система компании Turtle сможет посылать сообщения приложению
ActionBazaar:

Message m = context.createTextMessage(
  String.format(“Item in error %s”,tr.getItem()));
JMSProducer producer = context.createProducer();
producer.send(destination, om);

Хотя мы явно не показали это в примере, тем не менее, компоненты MDB об-
ладают еще одной особенностью: они способны управлять транзакциями MDB.


4.3.9. Управление транзакциями MDB

По умолчанию, перед вызовом метода onMessage , контейнер запускает транзак-
цию, а когда метод вернет управление – подтверждает ее, если транзакция не была
помечена для отката через контекст, и в ходе выполнения метода onMessage не
возникло необработанное исключение.

--//--

4.4. Приемы использования компонентов MDB

С особым вниманием выбирайте модель обмена сообщениями. Прежде чем по-
грузиться с головой в код, тщательно обдумайте свой выбор модели обмена сооб-
щениями. В 9 случаях из 10 вы можете прийти к выводу, что модель PTP («точка–
точка») лучше всего решает ваши проблемы.

Не злоупотребляйте компонентами MDB. Многие задачи могут с успехом ре-
шаться с помощью асинхронных методов сеансовых компонентов или событий
CDI. Если вам просто нужно запустить еще одну задачу для выполнения некото-
рых операций, механизм сообщений JMS может оказаться чересчур тяжеловес-
ным.

Не забывайте о преимуществах модульной архитектуры. Так как компоненты
MDB очень похожи на сеансовые компоненты, вполне естественным кажется раз-
мещение прикладной логики непосредственно в методах обработки сообщений.
Помните, что прикладная логика не должна переплетаться с операциями, имею-
щими отношение к обмену сообщениями. Наиболее удачным приемом (следова-
ние которому, впрочем, могло бы усложнить эту главу) считается размещение при-
кладной логики в сеансовых компонентах и вызывать ее из метода onMessage .

Не забывайте о фильтрах сообщений . Существует масса вполне обоснованных
причин использования единственного адреса для самых разных целей.

Внимательно подходите к выбору типа сообщения. Выбор типа сообщения не
всегда очевиден, как кажется. Например, часто весьма привлекательной выгля-
дит идея использовать в качестве сообщений строки в формате XML. Кроме все-
го прочего, такое решение позволяет добиться еще большего ослабления связей
между системами.
Однако размер сообщения в формате XML обычно многократно превосходит
размер того же сообщения в двоичном формате, что может отрицательно сказать-
ся на производительности MOM. При определенных условиях правильнее будет
использовать двоичный формат, чтобы уменьшить нагрузку на систему MOM и
снизить потребление памяти.


Остерегайтесь отравленных сообщений. Представьте, что вам было передано
сообщение, «переварить» которое ваш компонент MDB не смог. Продемонстри-
руем это на примере: пусть принято сообщение, не являющееся объектом типа
ObjectMessage . Как видно из следующего фрагмента кода, в этом случае по-
пытка приведения типа в методе onMessage возбудит исключение java.lang.
ClassCastException :

try {
  // Неправильный тип сообщения вызовет исключение
  // при попытке выполнить приведение типа
  ObjectMessage om = (ObjectMessage) message;
  Object o = om.getObject();
  ActionBazaarShippingRequest sr = (ActionBazaarShippingRequest) o;
  ...
} catch (JMSException ex) {
  Logger.getLogger(TurtleShippingRequestMessageBean.class.getName())
        .log(Level.SEVERE, null, ex);
}

Из-за того, что onMessage не может завершиться нормально, контейнер будет
принудительно откатывать транзакцию и возвращать сообщение в очередь, вместо
того, чтобы подтвердить его. Это большая проблема, потому что вы снова и снова
будете извлекать одно и то же сообщение из очереди, сталкиваться с ошибкой и
вновь возвращать его в очередь, и так до бесконечности! Сообщения, вызывающие
такой эффект, называются отравленными сообщениями (poisoned messages).

К счастью многие системы MOM и контейнеры EJB имеют механизмы для об-
работки отравленных сообщений, включая подсчет возвратов и очереди для «мер-
твых» сообщений. Если настроить учет количества возвратов и очередь «мертвых»
сообщений для адреса, куда направляются запросы на доставку, попытка доставить
сообщение будет выполнена не более указанного числа раз. Когда счетчик попы-
ток превысит установленное значение, сообщение будет помещено в специаль ную
очередь для отравленных сообщений, которую называют очередью мертвых сооб-
щений (dead-message queue). Единственная проблема – этот механизм не стандар-
тизован и в некоторых реализациях может отсутствовать.

Не пренебрегайте настройкой размера пула MDB .
Если установить размер пула компонентов MDB слишком маленьким, сообщения
будут обрабатываться медленно. В то же время, желательно установить разумные
ограничения на размер пула MDB, чтобы не растрачивать вычислительные ресур-
сы системы на переключение между множеством параллельно выполняющихся
экземпляров MDB.

--//--

4.5. В заключение

  --- 

--//-------------------------------------------------------------------------

# Глава 5.
# Контекст EJB времени
# выполнения, внедрение
# зависимостей и сквозная логика


В двух предыдущих главах мы занимались разработкой сеансовых компонентов и
компонентов, управляемых сообщениями (MDB). В этой главе мы познакомимся
с некоторыми продвинутыми понятиями, касающимися сеансовых компонентов
и компонентов MDB. Сначала мы рассмотрим, как контейнеры предоставляют
доступ к своим службам и как обращаться к окружению времени выполнения. За-
тем мы исследуем более сложные приемы использования механизма внедрения
зависимостей, реестра JNDI и интерцепторов EJB.


5.1. Контекст EJB


Компоненты EJB вообще мало зависят от конкретной реализации контейнера.
Это означает, что в идеальном случае компоненты EJB должны содержать лишь
прикладную логику и никогда напрямую не обращаться к контейнеру или к его
службам. Но иногда в прикладном коде все же бывает необходимо явно вызывать
службы контейнера. Например, может потребоваться вручную откатить транзак-
цию или создать таймер, чтобы запустить бизнес-процесс в некоторый момент
времени в будущем. Для обслуживания всех этих ситуаций предназначен контекст
EJB. Интерфейс javax.ejb.EJBContext – это потайная дверь в закулисный мир
контейнера.


5.1.1. Основы контекста EJB

Как показано в листинге 5.1, интерфейс EJBContext открывает прямой доступ
к таким службам, как транзакции, поддержка безопасности и таймеры, которые
обычно настраиваются через конфигурацию и находятся под полным управлени-
ем контейнера.

public interface EJBContext {
  public Principal getCallerPrincipal();        // Поддержка
  public boolean isCallerInRole(String roleName); // безопасности

  public boolean getRollbackOnly();               // Управление
  public UserTransaction getUserTransaction();    // транзакциями
  public void setRollbackOnly();                  //

  public TimerService getTimerService();          // Доступ к службе таймеров

  public Object lookup(String name);              // Поиск в реестре JNDI
  public Map<String, Object> getContextData();    // Доступ к контекстным
                                                // данным из интерцепторов

  public EJBHome getEJBHome();                    // Для совместимости
  public EJBLocalHome getEJBLocalHome();          // с EJB 2
}


[ getCallerPrincipal, isCallerInRole ]
Эти методы могут пригодиться для обеспечения безопасности на
уровне компонента.

[ getEJBHome, getEJBLocalHome ]
Эти методы используются для получения «удаленного» и «локально-
го» домашнего интерфейсов соответственно. Оба являются необяза-
тельными для контейнеров EJB 3

[ getRollbackOnly, setRollbackOnly, getUserTransaction ]
Эти методы применяются для управления транзакциями на уровне
контейнера EJB.

[ getTimerService ]
Этот метод используется для получения доступа к службе таймеров
EJB.

[ lookup ]
Этот метод используется для получения ссылок на объекты, храня-
щиеся в реестре JNDI. При использовании механизма внедрения за-
висимостей, прибегать к непосредственному поиску в реестре JNDI
практически не приходится. Но в редких случаях, когда механизм
внедрения зависимостей не может использоваться, этот метод ока-
зывается удобным решением проблемы.

[ getContextData ]
Этот метод позволяет компонентам EJB получить доступ к контекст-
ным данным из интерцепторов.

5.1.2. Интерфейсы контекста EJB

Обе разновидности компонентов, сеансовые и MDB, имеют собственные подклас-
сы, реализующие интерфейс javax.ejb.EJBContext . 
Подкласс сеансовых компонентов называется javax.ejb.SessionContext , а под-
класс компонентов MDB – javax.ejb.MessageDrivenContext .


SessionContext – это реализация, добавляющая методы, специфичные для се-
ансовых компонентов. Эти методы используются редко, описывать не будем.

MessageDrivenContext – это реализация, специфичная для компонентов
MDB. В отличие от SessionContext , данная реализация не добавляет новых ме-
тодов – она переопределяет следующие методы так, что при вызове они возбуж-
дают исключение: isCallerInRole , getEJBHome и getEJBLocalHome . Помните,
что эти методы являются частью интерфейса SessionContext , но они не имеют
смысла для компонентов MDB, потому что у них нет прикладного интерфейса и
они никогда не вызываются клиентом непосредственно.

5.1.3. Доступ к контейнеру через контекст EJB

Получить доступ к EJBContext можно с помощью механизма внедрения зависи-
мостей. Например, объект SessionContext можно внедрить в сеансовый компо-
нент

@Stateless
public class DefaultBidService implements BidService {
  @Resource
  SessionContext context;
  ...
}

В этом фрагменте, обнаружив присутствие аннотации @Resource перед пере-
менной context , контейнер определит, что компонент требует внедрения контек-
ста контейнера. Подробнее об аннотации @Resource рассказывается далее в этой
главе.
Во многом похожий на контекст сеанса, контекст MessageDrivenContext так
же может быть внедрен в компонент MDB, как показано ниже:

@MessageDriven
public class OrderBillingProcessor {
  @Resource
  MessageDrivenContext context;
  ...
}

Примечание. Не допускается внедрять MessageDrivenContext в сеансовые компо-
ненты или SessionContext в компоненты MDB.

--//--

5.2. Использование EJB DI и JNDI

В Java EE 5 была добавлена аннотация @EJB , чтобы упростить компонентам, уп-
равляемым контейнером, получение ссылок на компоненты EJB. Следуя практике
инверсии управления (inversion of control), контейнер использует механизм DI
для связывания компонентов между собой. Хотя JNDI все еще используется за
кулисами, эти тонкости скрыты от разработчика за ширмой аннотации @EJB . До
выхода спецификации EE5, использовался только механизм JNDI. Главное отли-
чие прежних версий состоит в том, что тогда за связывание компонентов отвечал
исключительно разработчик, который вынужден был обращаться к реализации
JNDI, используя шаблон проектирования локатора служб (service locator pattern),
вместо того, чтобы доверить эту работу механизму внедрения зависимостей кон-
тейнера. В этом разделе мы сначала познакомимся с основами JNDI, чтобы полу-
чить представление о том, что происходит за кулисами. Затем займемся детальным
изучением аннотации @EJB , посмотрим, когда и как использовать эту аннотацию,
и как она связана с JNDI.


Инверсия управления

Инверсия управления (Inversion of control, IoC) – важный принцип объектно-ориенти-
рованного программирования. Согласно ему, объекты должны иметь как можно более
слабые связи между собой за счет использования интерфейсов, а выбор конкретной ре-
ализации должен производиться уже во время выполнения. Шаблоны проектирования
«Локатор служб» (Service Locator, SL) и «Внедрение зависимостей» (Dependency Injection)
помогают следовать этому принципу.


Шаблон «Внедрение зависимостей»

Шаблон «Внедрение зависимостей» следует модели «вталкивания» (или «втискива-
ния»). Зависимости объектов определяются некоторой конфигурацией (XML, аннотации
и др.), а контейнер создает конкретные реализации этих зависимостей во время выпол-
нения и втискивает их в объекты. В этом заключена суть технологии CDI (обсуждается
далее в этой главе).


Шаблон «Локатор служб»

Шаблон SL следует модели «вытягивания». Объекты регистрируются внутри централь-
ного хранилища с помощью специальной службы. А затем объекты самостоятельно, с
помощью этой службы, «вытягивают» нужные им зависимости из центрального хранили-
ща. JNDI как раз является реализацией такой службы и объекты могут использовать JNDI
для вытягивания своих зависимостей.

--//--

5.2.1. Пример использования JNDI в EJB

По сути, JNDI – это аналог JDBC для служб имен и каталогов. Так же как JDBC
предоставляет стандартный Java API для доступа к разнообразным базам данных,
JNDI стандартизует доступ к службам имен и каталогов. Если вам когда-либо
приходилось работать с файловой системой компьютера, значит вы уже знае-
те, что такое служба имен и каталогов.

Получив экземпляр контекста JNDI, его можно использовать для поиска
ресурсов в любой службе имен, доступной этому контексту. За кулисами служ-
ба JNDI взаимодействует со всеми доступными ей службами имен, передавая им
имена ресурсов, которые требуется найти и выясняя, где в действительности на-
ходится искомый ресурс.

JNDI предоставляет единый обобщенный API для доступа
к различным службам имен, таким как LDAP, DNS, NDS, NIS, RMI и CORBA.
Любая служба имен, реализующая интерфейс провайдера JNDI SPI,
может быть бесшовно подключена к этому API


JNDI играет важную роль в Java EE, хотя и остается все время за кулисами. JNDI
используется как центральное хранилище для ресурсов, управляемых контейне-
ром. Как результат, все компоненты, управляемые контейнером, автоматически ре-
гистрируются в JNDI.

После получения
ссылки на ресурс из контекста JNDI, вы сможете использовать его как обычный
локальный ресурс.


*. Инициализация контекста JNDI

Чтобы воспользоваться ресурсом, хранящимся в контексте JNDI, клиент дол-
жен инициализировать контекст и найти ресурс. Несмотря на всю сложность са-
мого механизма JNDI, пользоваться им достаточно просто. Это напоминает на-
стройку драйвера JDBC перед подключением к базе данных.

Прежде всего, чтобы подключиться к службе имен или каталогов, необходимо
получить библиотеки JNDI для этой службы. Это мало чем отличается от выбо-
ра правильного драйвера JDBC для подключения к базе данных. Если требуется
подключиться к LDAP, DNS или файловой системе компьютера, необходимо по-
лучить провайдера для LDAP, DSN или файловой системы, соответственно.

При работе в окружении Java EE, сервер приложений уже имеет и загружает
все необходимые библиотеки для доступа к окружению JNDI. В противном случае
вам потребуется настроить свое приложение, указав, какие библиотеки JNDI оно
должно использовать. Сделать это можно, например, создав объект Properties и
передав его конструктору InitialContext :

Properties properties = new Properties();
properties.put(Context.INITIAL_CONTEXT_FACTORY
    ,”oracle.j2ee.rmi.RMIInitialContextFactory”);
properties.put(Context.PROVIDER_URL,
    “ormi://192.168.0.6:23791/appendixa”);
properties.put(Context.SECURITY_PRINCIPAL, “oc4jadmin”);
properties.put(Context.SECURITY_CREDENTIALS, “welcome1”);

Context context = new InitialContext(properties);


В этом примере выполняется настройка объекта Properties для доступа к де-
реву JNDI удаленного сервера приложений Oracle. Обратите внимание, что па-
раметры подключения к JNDI зависят от конкретного производителя и данный
пример не является универсальным, поэтому обращайтесь к документации с опи-
санием своего сервера приложений, чтобы узнать, как организовать удаленное
подключение.

Другой способ выполнить настройки – создать файл jndi.properties , поло-
жить его где-нибудь в пути CLASSPATH приложения, сохранить в этом файле те
же самые пары имя/значение, что помещаются в объект Properties . После этого
данный файл будет использоваться автоматически при создании контекста вызо-
вом InitialContext :

Context context = new InitialContext();

В данном примере предполагается, что файл jndi.properties находится в
пути CLASSPATH . Большинство серверов приложений автоматически создают
файл jndi.properties по умолчанию. Как результат, в большинстве ситуаций код
инициализации контекста JNDI выглядит не сложнее создания простого объекта
с помощью оператора new и конструктора по умолчанию. В табл. 5.3 перечислены
наиболее часто используемые свойства JNDI, необходимые для подключения к
удаленному провайдеру службы JNDI (SDI).

[ java.naming.factory.initial ]
Имя фабричного класса, который будет использоваться для создания контекста.

[ java.naming.provider.url ]
Адрес URL удаленной службы JNDI.

[ java.naming.security.principal ]
Имя пользователя или другая идентификационная информации, позволяющая аутен-
тифицировать вызывающую программу в службе JNDI.


*. Поиск ресурсов в JNDI

После подключения к провайдеру JNDI можно воспользоваться функциональ-
ными возможностями интерфейса Context и получить желаемый ресурс. Здесь
мы сосредоточим все наше внимание на методе lookup , а другие предлагаем вам
изучить самостоятельно.

Метод lookup интерфейса Context
[ Object lookup (String name) ]
Возвращает ресурс с именем name , который следует при-
вести к требуемому типу. Если в аргументе name передать
пустую строку, возвращается новый экземпляр Context .

Итак, чтобы отыскать ресурс, необходимо знать его имя. Допустим, что компо-
нент BidService зарегистрирован в JNDI под именем “/ejb/bid/BidService” .
Чтобы найти его, можно выполнить поиск непосредственно:

Context context = new InitialContext();
BidService service = (BidService) context.lookup(“/ejb/bid/BidService”);
Context newContext = new InitialContext();
Context bidContext = (Context) newContext.lookup(“/ejb/bid/”);
BidService service = (BidService) bidContext.lookup(“BidService”);

В EJB 3 дела обстоят намного лучше, так как за исключением крайне редких слу-
чаев, вам вообще не придется выполнять поиск в JNDI непосредственно. Механика
использования JNDI в EJB 3 скрыта за ширмой механизма внедрения зависимостей.
Этот механизм является настолько высокой абстракцией, что вам даже не нужно
знать, что где-то там в недрах производится поиск в JNDI. Подобная абстракция стала
возможна после стандартизации имен в JNDI, что особенно верно для компонентов
EJB, которые совместимы со всеми серверами EE. В следующем разделе мы познако-
мимся с этим стандартом и посмотрим, как присваиваются имена компонентам EJB.

5.2.2. Как присваиваются имена компонентам EJB

Чтобы обеспечить переносимость операций поиска компонентов EJB в JNDI меж-
ду всеми серверами Java EE, был предложен следующий стандарт именования
компонентов:

java:<пространство-имен>/[имя-приложения]/<имя-модуля>/
     <имя-компонента>[!полное-квалифицированное-имя-интерфейса] ,

где элементы <пространство-имен> , <имя-модуля> и <имя-компонента> являют-
ся обязательными всегда присутствуют в имени, а элементы [имя-приложения]
и [!полное-квалифицированное-имя-интерфейса] считаются необязательными
и могут отсутствовать. Давайте рассмотрим каждый элемент этого переносимого
имени JNDI и посмотрим, как выбираются их значения.


<пространство-имен>
Среда имен сервера Java EE делится на четыре пространства имен, где каждое
пространство имен представляет свою область видимости.

  [ java:comp ]
  Поиск в этом пространстве имен ограничивается областью видимос-
  ти компонента. Например, каждый компонент EJB в JAR-файле получит
  собственное уникальное пространство имен java:comp. Это означает, что
  AccountEJB и CartEJB можно найти в java:comp/LogLevel и получить
  разные значения. Для обратной совместимости, это правило не относится
  к веб-модулю. Все компоненты, развертываемые из WAR-файла, попадают
  в одно общее пространство имен java:comp. Основное его предназначе-
  ние – сохранение обратной совместимости с версиями Java EE 6 и ниже, где
  java:comp было единственным стандартным пространством имен.

  [ java:module ]
  Поиск в этом пространстве имен ограничивается областью видимости мо-
  дуля. Все компоненты в модуле попадут в одно пространство имен java:
  module. Файл EJB-JAR – это модуль, как и файл WAR. Для обратной совмес-
  тимости, пространства имен java:comp и java:module интерпретируются
  в веб-модулях как одно пространство имен. Всегда, когда это возможно,
  вместо java:comp следует использовать java:module.

  [ java:app ]
  Поиск в этом пространстве имен ограничивается областью видимости при-
  ложения. Все компоненты из всех модулей в одном приложении попадут в
  общее пространство имен java:app. Архив EAR может служить примером
  приложения. Все WAR- и EJB-компоненты, развертываемые из EAR-архива
  попадут в это пространство имен.

  [ java:global ]
  Поиск в этом пространстве имен выполняется глобально. Сюда попадают
  все компоненты из всех модулей и всех приложений.


[имя-приложения]
Значение [имя-приложения] является необязательным и присутствует в име-
нах только тех компонентов EJB, которые развертываются на сервере из EAR-ар-
хива. Если архив EAR не использовался, тогда значение [имя-приложения] от-
сутствует в переносимых именах JNDI компонентов EJB.
По умолчанию в качестве значения [имя-приложения] выбирается имя EAR-
файла без расширения .ear . Переопределить это умолчание можно в файле
application.xml .


<имя-модуля>
Значение <имя-модуля> является обязательным и всегда присутствует в имени
ресурса. Это значение зависит от того, как развертываются модули, содержащие
компоненты EJB.
Если компоненты развертываются из отдельных файлов EJB-JAR (JAR-файлы
развертываются непосредственно), в качестве значения <имя-модуля> выбирает-
ся имя EJB-JAR файла без расширения .jar . Это умолчание можно переопреде-
лить с помощью элемента module-name в конфигурационном файле META-INF/
ejb-jar.xml .

  Если развертываются компоненты, являющиеся частью веб-модуля (WAR-
файл), по умолчанию в качестве значения <имя-модуля> выбирается имя WAR-
файла без расширения .war . Это умолчание можно переопределить с помощью
элемента module-name в конфигурационном файле WEB-INF/web.xml .

  Если развертываются компоненты, являющиеся частью веб-модуля (WAR-
файл), по умолчанию в качестве значения <имя-модуля> выбирается имя WAR-
файла без расширения .war . Это умолчание можно переопределить с помощью
элемента module-name в конфигурационном файле WEB-INF/web.xml .

  Если развертываются компоненты, являющиеся частью приложения (EAR-
файл), по умолчанию значение <имя-модуля> определяется в зависимости от того,
являются ли компоненты EJB частью EJB-JAR или WAR в EAR. При развертыва-
нии компонентов из WAR-файла, выбор значения <имя-модуля> выполняется в
соответствии с правилом для веб-модулей. Это правило можно переопределить
в файле WEB-INF/web.xml . При развертывании компонентов из файлов EJB-JAR,
значением <имя-модуля> становится полный путь к каталогу, где находится файл
EJB-JAR внутри EAR, плюс имя файла EJB-JAR без расширения .jar . Это прави-
ло можно переопределить в файле META-INF/ejb-jar.xml .


<имя-компонента>
Значение <имя-компонента> является обязательным и всегда присутствует в
имени ресурса. Для компонентов EJB, объявленных с применением аннотаций
@Stateless , @Stateful или @Singleton , в качестве значения <имя-компонен-
та> по умолчанию выбирается неквалифицированное имя класса компонента. Это
умолчание можно переопределить с помощью атрибута name() аннотации. Для
компонентов EJB, объявленных в файле ejb-jar.xml , значение <имя-компонен-
та> определяется с помощью элемента bean-name .


[!полное-квалифицированное-имя-интерфейса]
Значение [!полное-квалифицированное-имя-интерфейса] является обяза-
тельным, и переносимые имена компонентов EJB с этим элементом всегда будут
присутствовать в JNDI. Но сервер EE также требует, чтобы в JNDI присутствовало
имя без этого значения. Такое «обрезанное» имя может пригодиться, когда доступ
к компоненту осуществляется через единственный интерфейс (или если компо-
нент вообще не имеет интерфейса). Прояснить все вышесказанное помогут сле-
дующие примеры. В качестве значений для [!полное-квалифицированное-имя-
интерфейса] выбираются полные квалифицированные имена всех локальных,
удаленных, локальных домашних (в EJB 2) или удаленных домашних (в EJB 2)
интерфейсов, или полное квалифицированное имя класса компонента, если класс
не реализует никакие интерфейсы.


*. Примеры

Следующий сеансовый компонент без сохранения состояния реализует единст-
венный интерфейс:

package com.bazaar;
@Stateless
public class AccountBean implements Account { ... }


При развертывании из файла accountejb.jar он получит следующие имена в
JNDI:

java:global/accountejb/AccountBean
java:global/accountejb/AccountBean!com.bazaar.Account

java:app/accountejb/AccountBean
java:app/accountejb/AccountBean!com.bazaar.Account

java:module/AccountBean
java:module/AccountBean!com.bazaar.Account


При развертывании из accountejb.jar , находящегося внутри accountapp.
ear , он получит следующие имена в JNDI:

java:global/accountapp/accountejb/AccountBean
java:global/accountapp/accountejb/AccountBean!com.bazaar.Account

java:app/accountejb/AccountBean
java:app/accountejb/AccountBean!com.bazaar.Account

java:module/AccountBean
java:module/AccountBean!com.bazaar.Account


При развертывании из accountweb.war , он получит следующие имена в JNDI:

java:global/accountweb/AccountBean
java:global/accountweb/AccountBean!com.bazaar.Account

java:app/accountweb/AccountBean
java:app/accountweb/AccountBean!com.bazaar.Account

java:module/AccountBean
java:module/AccountBean!com.bazaar.Account


5.2.3. Внедрение зависимостей с применением @EJB

Аннотация @EJB была добавлена с целью поддержки внедрения компонентов EJB
в клиентский код, без необходимости выполнять поиск в JNDI. Несмотря на то,
что выбор переносимых JNDI-имен для компонентов EJB упрощает их поиск,
сама необходимость поиска накладывает значительную долю ответственности на
разработчика за внедрение необходимых зависимостей. Аннотация @EJB перекла-
дывает эту ответственность на сервер EE, и контейнер EJB будет автоматически
внедрять требуемые зависимости.

определение аннотации @EJB .

@Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME)
  public @interface EJB {
    String name() default “”;
    Class beanInterface() default Object.class;
    String beanName() default “”;
    String lookup() default “”;
}

[ name ]
Помимо выполнения операции внедрения, аннотация @EJB неявно создает при-
вязку, ссылающуюся на внедренный компонент EJB в пространстве имен java:
comp. Делается это в основном для обратной совместимости. Данный атрибут
позволяет указать имя для неявной привязки. Этот параметр является эквива-
лентом элемента <ejb-ref-name> в дескрипторе развертывания для EJB 2.

[ beanInterface ]
Этот параметр помогает при необходимости сузить тип ссылок на компо-
нент EJB и может быть локальным прикладным интерфейсом, удаленным
прикладным интерфейсом или классом компонента, если он не реализует
никаких интерфейсов.

[ beanName ]
Соответствует значению параметра name аннотаций @Stateless и
@Stateful или тега <ejb-name> в дескрипторе развертывания в определе-
нии компонента. Подобно параметру beanInterface помогает сузить выбор
компонента для внедрения, когда имеется несколько компонентов, реализу-
ющих один и тот же интерфейс.

[ lookup ]
Имя компонента, поиск которого фактически будет осуществляться в JNDI.
Это наиболее часто используемый параметр.

[ mappedName ]
Используется некоторыми производителями как имя компонента.

[ description ]
Описание компонента.


5.2.4. Когда следует использовать внедрение зависимостей EJB

Было бы совсем неплохо использовать механизм внедрения зависимостей EJB
всегда, когда это возможно. Но дело в том, что аннотация @EJB предназначалась для
внедрения только сеансовых компонентов и только в управляемых окружениях.


5.2.5. Аннотация @EJB в действии

Аннотация @EJB очень легко включается в работу. Кроме того, она является до-
вольно мощным инструментам, благодаря рациональному выбору значений по
умолчанию, и позволяет быстро внедрить компонент EJB с минимальными уси-
лиями.

*. Внедрение с параметрами по умолчанию

Представьте , что имеется следующий локальный интерфейс и реализующие его
компонент:

@Local
public interface AccountLocal {
  public void Account getAccount(String accountId);
}

@Stateless(name=”accountByDatabase”)
public class AccountByDatabaseEjb implements AccountLocal {. . .}

Чтобы внедрить этот компонент в ресурс, управляемый контейнером, например
в сервлет, аннотацию @EJB можно использовать без каких-либо дополнительных
параметров, позволив контейнеру самому определить их значения:

@EJB
AccountLocal accountInfo;

Обнаружив аннотацию @EJB в этом примере, контейнер определит, что тре-
буется внедрить компонент, реализующий интерфейс AccountLocal . Он вы-
полнит поиск среди зарегистрированных компонентов и внедрит экземпляр
AccountByDatabaseEjb , потому что этот компонент реализует требуемый интер-
фейс.


*. Внедрение с параметром beanName

Теперь представьте, что имеется несколько реализаций интерфейсаAccountLocal . 
В предыдущем примере представлена реализация, взаимодейству-
ющая с базой данных; а теперь добавим к ней реализацию, использующую Active
Directory:

@Stateless(name=”accountByActiveDirectory”)
public class AccountByActiveDirectoryEjb implements AccountLocal {. . .}

При наличии нескольких компонентов, реализующих один и тот же интерфейс
AccountLocal , требуется дать аннотации @EJB небольшую подсказку, чтобы кон-
тейнер смог определить, какую из реализаций следует внедрить:

@EJB(beanName=”accountByActiveDirectory”)
AccountLocal accountInfo;

Параметр beanName в этом примере сузит круг поиска реализации для внед-
рения. Контейнер найдет компонент с именем accountByActiveDirectory ,
убедится, что он реализует интерфейс AccountLocal и внедрит экземпляр
AccountByActiveDirectoryEjb в переменную accountInfo .


*. Внедрение с параметром beanInterface

Часто бывает желательно сделать один и тот же интерфейс и локальным, и уда-
ленным. Организовать это можно так:

public interface AccountServices {
  public Account getAccount(String accountId);
}

@Local
public interface AccountLocal extends AccountServices {}

@Remote
public interface AccountRemote extends AccountServices {}

@Stateless
public class AccountEjb implements AccountLocal, AccountRemote {. . .}

С помощью параметра beanInterface аннотации @EJB можно сообщить кон-
тейнеру, какой интерфейс следует внедрить – локальный или удаленный:

@EJB(beanInterface=”AccountLocal.class”)
AccountServices accountServices;

Параметр beanInterface аннотации @EJB в этом примере сузит круг поис-
ка реализации для внедрения. Контейнер найдет компонент с интерфейсом
AccountLocal.class . При внедрении компонента, его тип будет приведен к типу
AccountServices . Аннотация @EJB в данном случае сообщает контейнеру, что вы
желаете использовать локальный компонент, но взаимодействовать с ним через
интерфейс AccountServices . Это отличная возможность для тех, к


*. Внедрение с параметром lookup

Использование параметра lookup позволяет устранить все неоднозначности,
которые только могут возникнуть при внедрении EJB. Если указать этот пара-
метр, контейнер не будет пытаться определить правильный компонент – вы явно
сообщаете ему JNDI-имя компонента, который требуется внедрить:

@EJB(lookup=”java:module/DefaultAccountService”)
AccountServices accountServices;

Параметр lookup в этом примере сузит круг поиска реализации для внедрения.
Вы можете указать любую действительную область видимости.


@EJB является частным случаем механизма внедрения зависимостей, поддерживая
только внедрение компонентов EJB. Однако существуют и другие ресурсы, управ-
ляемые контейнером (такие как источники данных JDBC, очереди JMS и сеансы
JavaMail), которые может потребоваться внедрить в код. Эти ресурсы можно внед-
рять с помощью аннотации @Resource , как описывается в следующем разделе.


***.

Что фактически внедряется при внедрении компонента EJB? Ответ: прокси-объект .
Контейнер создает специальный промежуточный объект, который называют прокси-
объектом (proxy object), и внедряет его, а не сам класс компонента. Делается это для
того, чтобы контейнер мог правильно управлять всеми службами EJB, такими как транз-
акции и поддержка многопоточного выполнения. Кроме того, прокси-объект гарантиру-
ет правильность доступа к соответствующему компоненту. Например, представьте, что
имеется следующий простой сеансовый компонент без сохранения состояния:

@Stateless
public class BidService {
}

Так как всем ссылкам на этот компонент контейнером будет назначена одна и та же
идентичность, прокси-объект гарантирует корректность возвращаемого объекта. Вы
можете использовать метод equals() для проверки, так ли это на самом дел


5.2.6. Внедрение ресурсов с помощью аннотации @Resource

Аннотация @Resource , безусловно, самый универсальный механизм внедрения
ресурсов в EJB 3. В большинстве случаев она используется для внедрения источ-
ников данных JDBC, ресурсов JMS и контекстов EJB. Но эта аннотация может
также применяться для внедрения всего, что только имеется в реестре JNDI.


@Target({TYPE, FIELD, METHOD}) @Retention(RUNTIME)
  public @interface Resource {
    String name() default “”;
    String lookup() default “”;
    Class type() default java.lang.Object.class;
    AuthenticationType authenticationType()
      default AuthenticationType.CONTAINER;
    boolean shareable() default true;
}

Все параметры аннотации @Resource являются необязательными. Как и в слу-
чае с компонентами EJB, сервер EE обычно легко справляется с задачей внедрения
ресурса, зная только его тип. Но так бывает не всегда, и в таких ситуациях пара-
метры помогут сделать правильный выбор. Например, вам может потребоваться
внедрить DataSource , но, если сервер EE настроен на работу с несколькими ис-
точниками данных, вам придется указать значение в параметре name или lookup ,
чтобы сузить круг поиска внедряемого ресурса.

[ name ]
Помимо выполнения операции внедрения, аннотация @Resource
неявно создает привязку, ссылающуюся на внедренный ресурс в
пространстве имен java:comp. Делается это в основном для об-
ратной совместимости. Данный атрибут позволяет указать имя для
неявной привязки. Этот параметр является эквивалентом элемента
<res-ref-name> в дескрипторе развертывания для EJB 2.

[ lookup ]
Имя ресурса, поиск которого фактически будет осуществляться в
JNDI. Это наиболее часто используемый параметр.

[ type ]
Тип ресурса. Если аннотация @Resource применяется к полю, по умол-
чанию используется тип поля. Если аннотация применяется к методу
записи (setter method), используется тип параметра метода.

[ authenticationType ]
Может иметь значение AuthenticationType.CONTAINER или
AuthenticationType.APPLICATION. Используется только для ре-
сурсов, являющихся фабриками соединений, таких как источники
данных.

[ shareable ]
Определяет, может ли ресурс совместно использоваться сразу не-
сколькими компонентами. Используется только для ресурсов, являю-
щихся фабриками соединений, таких как источники данных.

[ mappedName ]
Используется некоторыми производителями как имя ресурса.

[ description ]
Описание ресурса.


5.2.7. Когда следует использовать внедрение ресурсов

Аннотация @Resource применяется для внедрения ресурсов, управляемых кон-
тейнером, в код, так же управляемый контейнером. Данная аннотация действует
только внутри компонентов EJB, MDB, в коде, выполняющемся внутри контей-
нера клиентских приложений (ACC), или в компонентах, зарегистрированных в
веб-контейнере (таком как сервлет или JSF-компонент). Спектр поддерживаемых
ресурсов простирается от простых целочисленных значений, до сложнейших объ-
ектов DataSource : если ресурс управляется контейнером, его можно внедрить с
помощью аннотации @Resource .


5.2.8. Когда следует использовать внедрение ресурсов

*. Внедрение DataSource

Следующий фрагмент внедряет объект DataSource в компонент DefaultBidService :

@Stateless
public class DefaultBidService implements BidService {
  ...
  @Resource(lookup=”java:global/jdbc/ActionBazaarDB”)
  private DataSource dataSource;

Параметр lookup обеспечивает прямой поиск в JNDI и данный пример предпо-
лагает, что сервер EE настроен на использование объекта DataSource , связанного
с этим местоположением. Если имя ресурса изменится или если на другом сервере
EE объект DataSource будет связан с другим местоположением, попытка внедре-
ния потерпит неудачу.

*. Внедрение ресурсов JMS

Вспомните обсуждение темы обмена сообщениями и использования ком-
понентов MDB в главе 4. Если приложение использует механизм обмена сооб-
щениями, ему наверняка понадобятся ресурсы JMS, такие как javax.jms.
Queue , javax.jms.Topic , javax.jms.QueueConnectionFactory и javax.jms.
TopicConnectionFactory . Подобно источникам данных JDBC, эти ресурсы хра-
нятся в реестре JNDI сервера приложений и могут внедряться с помощью аннота-
ции @Resource . Например, следующий фрагмент внедряет очередь Queue с име-
нем “java:global/jms/ActionBazaarQueue” в поле queue :

@Resource(lookup=”java:global/jms/ActionBazaarQueue”)
private Queue queue;

*. Внедрение EJBContext

Выше мы уже знакомились с интерфейсами EJBContext , SessionContext и
MessageDrivenContext . Механизм внедрения ресурсов часто используется для
получения доступа к EJBContext . Следующий фрагмент, взятый из определения
сеансового компонента DefaultBidService , внедряет контекст EJB в переменную
экземпляра context :

@Resource
private SessionContext context;

Обратите внимание, что внедряемый контекст сеанса не хранится в JNDI. Фак-
тически, было бы неправильным указать параметр lookup в данном случае, и сер-
вер просто проигнорировал бы его. Когда контейнер обнаруживает, что аннотация
@Resource применяется к переменной, которая должна хранить ссылку на кон-
текст, он выясняет, какой из контекстов EJB действует для данного экземпляра
компонента, производя поиск по типу данных javax.ejb.SessionContext пере-
менной. Так как DefaultBidService – это сеансовый компонент, результат внед-
рения будет тот же, как если бы в качестве типа переменной был указан родительс-
кий класс, EJBContext . Следующий фрагмент все равно внедрит в переменную
context соответствующий экземпляр javax.ejb.SessionContext , даже при том,
что она объявлена с типом javax.ejb.EJBContext :

@Resource
private EJBContext context;

Такой способ внедрения может пригодиться в сеансовых компонентах, где не пред-
полагается использовать методы, доступные через интерфейс SessionContext .


*. Внедрение элементов окружения

апример, предположим, что в приложении ActionBazaar требуется уста-
навливать признак цензуры для некоторых стран. Если этот флаг установлен,
ActionBazaar будет сверять объявления о продаже со списком запрещенных то-
варов в стране, где развернуто приложение. Внедрить элемент окружения можно,
как показано ниже:

@Resource
private boolean censorship;

Элементы окружения определяются в дескрипторе развертывания и становят-
ся доступны через JNDI. Признак цензуры в приложении ActionBazaar можно оп-
ределить так:

<env-entry>
<env-entry-name>censorship</env-entry-name>
<env-entry-type>java.lang.Boolean</env-entry-type>
<env-entry-value>true</env-entry-value>
</env-entry>

По сути элементы окружения играют роль прикладных констант и поддержи-
вают небольшой диапазон типов данных. В частности, значениями тега <env-en-
try-type> могут быть Java-типы: String , Character , Byte , Short , Integer , Long ,
Boolean , Double и Float . Так как элементы окружения доступны через JNDI, они
могут внедряться по именам. Как вы уже наверняка поняли, типы данных эле-
ментов окружения и переменных, куда производится внедрение, должны быть
совместимыми. Иначе при попытке выполнить внедрение контейнер возбудит ис-
ключение. Отметьте, что если на основе внедрения зависимостей требуется орга-
низовать сложную конфигурацию, вам определенно следует посмотреть в сторону
механизма CDI.


*. Внедрение ресурсов JavaMail

В дополнение к источникам данных JDBC и ресурсам JMS, еще одним важней-
шим ресурсом корпоративных приложений зачастую является ресурс JavaMail
( javax.mail.Session ). Сеансы JavaMail обеспечивают доступ к настройкам поч-
тового сервера и хранятся в реестре JNDI сервера приложений. Объект Session
можно внедрить в компонент EJB с помощью аннотации @Resource и использо-
вать для отправки электронной почты. В приложении ActionBazaar эту возмож-
ность можно задействовать для отправки извещений клиентам, чьи ставки выиг-
рали. Ниже представлен фрагмент кода, внедряющий объект Session :

@Resource(lookup=”java:global/mail/ActionBazaar”)
private javax.mail.Session mailSession;

Оставим определение настроек электронной почты в дескрипторе разверты-
вания как упражнение. Пример непосредственного отображения аннотаций в де-
скрипторы можно найти в приложении A.


*. Внедрение службы таймеров

Служба таймеров контейнера дает компонентам EJB простую возможность пла-
нировать выполнения заданий (подробнее о таймерах рассказывается в главе 7).
Внедрить службу таймеров в компонент EJB также можно с помощью аннотации
@Resource :

@Resource
private javax.ejb.TimerService timerService;

Так же, как и контексты EJB, служба таймеров не зарегистрирована в JNDI, но
контейнер вполне в состоянии определить, какой ресурс требуется внедрить, толь-
ко исходя из типа переменной.
Однако, насколько бы мощный ни была аннотация @Resource , некоторые за-
дачи оказываются ей не по плечу. Существуют ситуации, когда приходится явно
выполнять поиск в JNDI.


5.2.9. Поиск ресурсов и компонентов EJB в JNDI

Для внедрения ресурсов можно использовать аннотации @EJB и @Resource , но
иногда все же приходится вручную выполнять поиск в JNDI. Существует два спо-
соба выполнить поиск программно – либо с помощью EJBContext , либо с помо-
щью InitialContext . Далее мы рассмотрим оба.


*. Поиск с помощью EJBContext

Выше уже говорилось о возможности найти любой объект, хранящийся в JNDI,
с помощью метода EJBContext.lookup() (включая и ссылки на сеансовые компо-
ненты). Этот же прием можно использовать и для решения более сложных задач,
например, для организации динамической смены ресурсов во время выполнения.
Прием внедрения зависимостей, несмотря на все преимущества, вынуждает ис-
пользовать статическую конфигурацию, которую нельзя изменить программно.

Использование возможности поиска для получения разных ресурсов на разных
этапах выполнения напоминает динамическое конструирование инструкций SQL.
Разница лишь в том, что вместо запроса к базе данных выполняется поиск в JNDI.
Все, что для этого необходимо сделать, фактически сводится к динамическому
конструированию имени искомого ресурса. Как результат, программы, управляе-
мые данными и/или вводом пользователя, получают возможность определять
зависимости в процессе выполнения, а не на этапе развертывания. Следующий
фрагмент демонстрирует метод EJBContext.lookup() в действии:


@Stateless
public class DefaultDiscountService implements DiscountService {
  @Resource
  private SessionContext sessionContext;
  ...
  DiscountRateService discountRateService
    = (DiscountRateService) sessionContext.lookup(
      “java:app/ejb/HolidayDiscountRateService”);
  ...
  long discount = discountRateService.calculateDiscount(...);


Этот пример демонстрирует, как найти DiscountRateService с помощью
SessionContext . Примечательно, что строка с JNDI-именем искомого ресурса
является частью кода и, соответственно, легко может быть изменена, если потре-
буется найти другие реализации DiscountRateService , опираясь на некоторые
бизнес-правила. В данном примере искомый компонент EJB должен отображать-
ся в пространство имен java:app с именем /ejb/HolidayDiscountRateService .


*. Поиск с помощью EJBContext


Несмотря на относительное удобство приема поиска с помощью EJBContext ,
проблема в том, что этот способ доступен, только внутри Java EE или контейнера
клиентских приложений. Когда речь заходит о внедрении POJO, находящихся за
пределами контейнера, у вас остается только самый простой способ поиска ссылок
в JNDI – с использованием InitialContext механизма JNDI. Код, реализующий
такой поиск, выглядит довольно шаблонно, зато он достаточно прост:

Context context = new InitialContext();
BidService bidService = (BidService)
context.lookup(“java:app/ejb/DefaultBidService”);
...
bidService.addBid(bid);


*. Поиск с помощью InitialContext

Несмотря на относительное удобство приема поиска с помощью EJBContext ,
проблема в том, что этот способ доступен, только внутри Java EE или контейнера
клиентских приложений. Когда речь заходит о внедрении POJO, находящихся за
пределами контейнера, у вас остается только самый простой способ поиска ссылок
в JNDI – с использованием InitialContext механизма JNDI. Код, реализующий
такой поиск, выглядит довольно шаблонно, зато он достаточно прост:

Context context = new InitialContext();
BidService bidService = (BidService)
context.lookup(“java:app/ejb/DefaultBidService”);
...
bidService.addBid(bid);

Объект InitialContext можно создать в любом коде, имеющем доступ к JNDI
API. Кроме того, этот объект можно использовать для доступа не только к ло-
кальному, но и к удаленному серверу JNDI. Обратите внимание, что хотя этот код
выглядит довольно безобидно, его следует избегать по мере возможности.


5.2.10. Когда следует использовать поиск в JNDI


В большинстве случаев для внедрения ресурсов вполне достаточно аннотаций
@EJB и @Resource и вам вообще не понадобится прибегать к непосредственному
поиску в JNDI. Однако иногда без этого не обойтись.

Классы, не управляемые контейнером, вынуждены использовать поиск в JNDI.
Аннотации @EJB и @Resource доступны только в классах, управляемых Java EE
или контейнером клиентских приложений. В их число входят компоненты EJB,
MDB, сервлеты и JSF-компоненты. Любые неуправляемые классы должны ис-
пользовать поиск в JNDI через InitialContext , чтобы получить доступ к ресур-
сам сервера.


5.2.11. Контейнеры клиентских приложений

К настоящему моменту вы познакомились с внедрением компонентов EJB и ре-
сурсов в приложениях, развертываемых и выполняющихся внутри сервера EE.
А что если доступ к компонентам EJB и другим управляемым ресурсам потре-
буется получить из приложения SE, выполняющегося за пределами сервера EE?
Именно для разрешения подобных проблем существует контейнер клиентских
приложений (Application-Client Container, ACC) .

ACC – скрытое сокровище в мире EE. Это мини-контейнер Java EE, который
можно запустить из командной строки. Его можно рассматривать, как улучшенную
виртуальную машину Java (JVM) с некоторыми встроенными механизмами Java
EE. Внутри ACC можно запускать любые клиентские приложения Java SE, такие
как приложения на основе Swing, как если бы это была обычная виртуальная маши-
на JVM. Достоинство контейнера клиентских приложений в том, что он распознает
и обрабатывает большинство аннотаций Java EE, таких как @EJB . Кроме всего про-
чего ACC способен находить и внедрять компоненты EJB, находящиеся на удален-
ных серверах, взаимодействовать с удаленными компонентами EJB посредством
RMI, поддерживает аутентификацию, может выполнять авторизацию, публикацию
и подписку на ресурсы JMS, и так далее. Но в полном своем блеске ACC предстает,
когда возникает необходимость использовать компоненты EJB в приложениях SE
или внедрить ресурсы в POJO во время модульного тестирования.

Внутри ACC можно запустить любой Java-класс, обладающий методом main .
Как правило, вам нужно упаковать свое приложение в файл JAR и определить
MainClass в META-INF/MANIFEST . Дополнительно файл JAR может содержать
дескриптор развертывания ( META-INF/applicationclient.xml ) и файл jndi.
properties , определяющий параметры подключения с удаленным контейнером
EJB. В качестве небольшого примера: если бы в EE-приложении ActionBazaar
имелась удаленная EJB-служба для создания ставок, SE-приложение могло бы
легко внедрить ее в статическое свойство, как показано ниже:

@EJB
private static BidService remoteBidService;

public class BidServiceClient {
  public static void main(String[] args) {
    System.out.println(“result = “ + remoteBidService.addBid(bid));
}

Процедура запуска приложения SE в контейнере ACC зависит от конкретных
особенностей сервера EE. Давайте посмотрим, как сделать это в GlassFish. Допус-
тим, что приложение SE упаковано в JAR-файл с именем bidservice-client.
jar . Запустить его в контейнере ACC под управлением сервера приложений Sun
Microsystems GlassFish можно следующим образом:
appclient -client bidservice-client.jar
Подробности, касающиеся использования ACC, ищите в документации к свое-
му серверу EE.


5.2.12. Встраиваемые контейнеры

Спецификация Java EE определяет стандартную среду выполнения корпоратив-
ных приложений внутри сервера EE, но не все приложения создаются для работы
в этой среде. Тем не менее, в большинстве приложений будут востребованы такие
типичные услуги, как DI и транзакции, которые предоставляют серверы EE. В та-
ких ситуациях с успехом можно использовать встраиваемые конт ейнеры. Встраи-
ваемый контейнер – это контейнер EJB, размещаемый в памяти, внутри которого можно
выполнять приложения SE (или модульные тесты) под управлением собственной вирту-
альной машины JVM. В результате приложение SE получает в свое распоряжение
большую часть возможностей, предоставляемых компонентами EJB.


*. Создание встроенного контейнера

Класс javax.ejb.embeddable.EJBContainer – это абстрактный класс, кото-
рый может быть реализован сервером EE, хотя это и не является обязательным
требованием. Создание экземпляра возлагается на статический метод:

EJBContainer ec = EJBContainer.createEJBContainer();

Приложение SE может затем использовать объект EJBContainer для взаимо-
действий с контейнером EJB, например, оно может выполнять поиск и получать
экземпляры компонентов EJB.

Методы класса EJBContainer:

[ close() ]  Завершает работу встроенного контейнера EJB.

[ createEJBContainer() ]  Создает экземпляр EJBContainer с параметрами по
умолчанию.

[ createEJBContainer(Map<?,?>) ]  Создает экземпляр EJBContainer, определяя 
значения некоторых параметров.

[ getContext() ]  Возвращает javax.naming.Context.


*. Регистрация компонентов EJB

При создании контейнера вызовом метода createEJBContainer() автомати-
чески будет выполнен поиск компонентов EJB в пути поиска классов приложения
(classpath). Если не требуется сканировать все каталоги в пути поиска классов, или
по каким-то причинам необходимо загрузить только определенные компоненты
EJB, используйте метод createEJBContainer(java.util.Map<?,?>) и включите
в ассоциативный массив имена загружаемых модулей. Например, при следующих
параметрах будут загружены только компоненты EJB в файлах bidservice.jar и
accountservice.jar ; компоненты в других модулях будут игнорироваться.

Properties props = new Properties();
props.setProperty(EJBContainer.MODULES,
    new String[]{“bidservice”,”accountsevice”});
EJBContainer ec = EJBContainer.createEJBContainer(props);

При обнаружении компонента EJB встроенный контейнер зарегистрирует его в
JNDI, определив для него переносимое глобальное имя JNDI, как это делает пол-
ноценный сервер EE. Например, допустим, что в пути поиска классов присутству-
ет bidservice.jar , имеющий интерфейс @Local com.bazaar.BidServiceLocal
и его реализацию @Stateless com.bazaar.BidServiceEjb . Встроенный контей-
нер зарегистрирует его под именами:

java:global/bidservice/BidServiceEjb
java:global/bidservice/BidServiceEjb!com.bazaar.BidServiceLocal

Встраиваемые контейнеры поддерживают компоненты EJB с интерфейсами
@Local или без интерфейсов, а компоненты @Remote – нет.


*. Поиск компонентов EJB

Поиск компонентов EJB в JNDI выполняется точно так же, как и внутри
полно ценных контейнеров. Поиск классов, не управляемых встроенным кон-
тейнером, осуществляется с помощью объекта Context , возвращаемого методом
EJBContainer.getContext() . Например, получить компонент BidServiceLocal
можно так:

Context ctx = ec.getContext();
BidServiceLocal bsl = ctx.lookup(“java:global/bidservice/BidServiceEjb”);

И, конечно же, внедрение компонентов EJB, управляемых внедренным контей-
нером, можно выполнять с помощью аннотаций @EJB и @Resource .

.* Завершение

По окончании использования встроенного контейнера, вызывайте ec.close() ,
чтобы завершить его работу и освободить ресурсы. Завершение работы контей-
нера не означает, что следует завершить и само приложение SE – завершить ра-
боту встроенного контейнера может потребоваться по самым разным причинам.
Закрыв контейнер, приложение может запустить новый, если это потребуется.
Встроенный контейнер может быть так же дополнен поддержкой интерфейса
AutoCloseable . Благодаря чему его можно использовать в инструкции try-with-
resource и быть уверенными, что контейнер завершится автоматически. Ниже
показано, как можно использовать инструкцию try-with-resource :

try (EJBContainer ec = EJBContainer.createEJBContainer())
{
    // сделать нечто со встроенным котейнером
} catch (Throwable t) {
    t.printStackTrace();
} 


5.2.13. Эффективный поиск и внедрение компонентов EJB

Аннотация @EJB – самый простой, быстрый и безопасный способ связать ваше
приложение с экземплярами компонентов. В большинстве случаев контейнер EJB
может сам определить, какой компонент требуется создать и внедрить, по его клас-
су или интерфейсу. Но когда имеется несколько компонентов, реализующих один
и тот же интерфейс, и программа ссылается на компоненты по этому интерфейсу,
без поиска не обойтись. Механизм внедрения CDI имеет более удобное решение,
которое мы рассмотрим далее.


5.2.14. Механизмы внедрения EJB и CDI

Аннотация @EJB является самым простым, удобным и достаточно мощным инс-
трументом сервера EE для внедрения компонентов EJB в управляемые ресурсы.
Аннотация @EJB стала большим шагом в направлении упрощения разработки кор-
поративных приложений и ввела поддержку DI в контейнер EJB. Но аннотация
@EJB может внедрять только компоненты EJB и только в управляемые ресурсы,
такие как другие компоненты EJB, JSF-компоненты и сервлеты. Механизм CDI,
напротив, обладает намного более широкими возможностями и его аннотация
@Inject способна внедрять практически все что угодно и куда угодно, в том числе
и компоненты EJB. Но, если аннотация @Inject так хороша и способна внедрять
компоненты EJB, зачем тогда вообще использовать аннотацию @EJB ?


В простых случаях аннотации @EJB и @Inject можно считать взаимозаменяе-
мыми. Допустим, что у нас имеется компонент SimpleBidService , являющийся
простейшим сеансовым компонентом EJB без сохранения состояния из приложе-
ния ActionBazaar:

@Stateless
public class SimpleBidService {
  ...
}

В данном случае аннотации @EJB и @Inject будут действовать совершенно оди-
наково и с одинаковыми результатами:

@Inject
SimpleBidService bidService;

@EJB
SimpleBidService bidService;



Но с усложнением примера, в механизме CDI начинают проявляться дополни-
тельные проблемы. Например, допустим, что BidService – это интерфейс, имею-
щий множество реализаций:

public interface BidService { ... }

@Stateless(name=”defaultBids”)
public class DefaultBidService implements BidService { ... }

@Stateless(name=”clearanceBids”)
public class ClearanceBidService implements BidService { ... }



Аннотация @EJB позволяет легко справиться с этой проблемой несколькими
способами, основным из которых является использование параметра beanName :

@EJB(beanName=”clearanceBids”)
BidService clearanceBidService;

Аннотация @Inject действует немного иначе и требует дополнительных уси-
лий, чтобы сузить выбор внедряемой реализации BidService . Она требует созда-
ния класса-производителя в соответствии с шаблоном фабрики:

public class BidServiceProducer {
  @Produces
  @EJB(beanName=”defaultBids”)
  @DefaultBids
  BidService defaultBids;

  @Produces
  @EJB(beanName=”clearanceBids”)
  @ClearanceBids
  BidService clearanceBids;
}

Теперь аннотацию @Inject можно объединить с квалификаторами, используе-
мыми в BidServiceProducer , для внедрения нужного экземпляра компонента
BidService :

@Inject @ClearanceBids
BidService clearanceBidService;



В конечном счете, чтобы внедрить компонент EJB, кроме самых простых случа-
ев, даже при использовании механизма CDI, приходится опираться на аннотацию
@EJB в классах-производителях (producer classes), чтобы гарантировать создание
правильного экземпляра компонента EJB.


--//--

5.3. AOP в мире EJB: интерцепторы

В этом разделе мы расскажем, как создать простой интерцептор, осущест-
вляющий журналирование. Мы также покажем, как этот интерцептор можно сде-
лать интерцептором по умолчанию, выполняемым всякий раз, когда вызывается
метод компонента. В этом разделе вы узнаете как действуют интерцепторы.

5.3.1. Что такое AOP?

Вполне возможно, что вы уже сталкивались с термином аспектно-ориентирован-
ное программирование (Aspect-Oriented Programming, AOP) . Основная идея AOP
состоит в том, что типовой код, не связанный с решением прикладных задач и пов-
торяющийся от компонента к компоненту, должен рассматриваться как часть под-
держивающей инфраструктуры и не должен смешиваться с прикладной логикой.
Часто для обозначения такой функциональности используют термин сквозная
функциональность (crosscutting concerns) – функциональность, которая насквозь
пронизывает прикладную логику.

*. Сквозная функциональность

Поддержка аспектно-ориентированного программирования позволяет выде-
лять сквозную функциональность в отдельные модули. Журналирование, учет,
профилирование и сбор статистической информации – все эти задачи можно
было бы реализовать в виде отдельных модулей. Затем эти модули можно было
бы применять к соответствующим «сквозным» фрагментам прикладного кода, та-
ким как начало или конец каждого метода. В EJB 3 поддержка сквозной функцио-
нальности реализована как возможность перехвата вызовов прикладных методов
и методов обработки событий жизненного цикла.

5.3.2. Основы интерцепторов

Чтобы лучше понять суть интерцепторов EJB, давайте сначала коротко пройдемся
по основным понятиям аспектно-ориентированного программирования (AOP).

Первый: задача, функциональность (crosscutting concern – сквозная функцио-
нальность). Этот термин обозначает задачу, которую требуется решить, или функ-
циональность, которую нужно реализовать. Например: «Мне нужно добавить
журналирование во все прикладные методы», – или: «Мне требуется обеспечить
округление всех чисел до определенного числа знаков после запятой».

Второй: совет (advice) . Совет – это фактический код, решающий поставленную
задачу или реализующий требуемую функциональность. Например, если задача
состоит в том, чтобы обеспечить регистрацию в базе данных вызовов любых ме-
тодов, советом будет код, устанавливающий соединение с базой и выполняющий
запрос для вставки данных.

Третий: точка сопряжения (pointcut). Точка сопряжения описывает точку в при-
ложении, по достижении которой следует выполнить указанный совет. Типичны-
ми примерами точек сопряжения являются точки непосредственно перед вызовом
методов и сразу после вызова.

Четвертый: аспект (aspect) . Аспект – это комбинация точки сопряжения и со-
вета. Поддержка аспектно-ориентированного программирования вплетает советы
в соответствующие точки сопряжения, используя аспекты.

Хотя интерцепторы EJB 3 обеспечивают достаточный объем возможностей для
решения наиболее общих сквозных задач, они все же далеки по своим возможнос-
тям от полномасштабных пакетов поддержки AOP, таких как AspectJ. С другой
стороны, интерцепторы EJB 3 проще в использовании.

5.3.3. Когда следует использовать интерцепторы

Интерцепторы EJB 3 предназначены для использования с сеансовыми компо-
нентами и компонентами MDB. Они представляют аспекты, окружающие вызо-
вы методов, то есть с их помощью можно выполнить некоторые операции перед
вызовом метода, исследовать возвращаемое значение метода и обработать любые
исключения, генерируемые методом.

Перед вызовом метода обычно выполняется
сквозная логика, осуществляющая учет (журналирование, сбор статистической
информации и так далее) или проверяющая и при необходимости изменяющая
параметры, прежде чем они попадут в метод.

После вызова метода, опять же обыч-
но, выполняется сквозная логика, осуществляющая учет, а также проверяющая
возвращаемое значение и изменяющая его перед передачей вызывающему коду,
если это потребуется. Когда интерцептор перехватывает и обрабатывает исклю-
чения, генерируемые методами, снова может быть выполнена логика, осущест-
вляющая учет, но интерцептор может также попытаться повторно вызвать метод
или направить выполнение программы по другому пути.

5.3.4. Порядок реализации интерцепторов

Для реализации интерцептора EJB 3 требуется всего две аннотации. Первая:
@AroundInvoke . Эта аннотация применяется к методу класса, который будет иг-
рать роль совета интерцептора. Не забывайте, что совет – это фактический код,
который будет вплетаться в вызовы прикладных методов сеансовых компонентов
или компонентов MDB.

Вторая аннотация: @Interceptors . Эта аннотация применяется к классам ком-
понентов EJB и MDB, и определяет порядок применения интерцепторов к мето-
дам классов.

@Stateless
@Interceptors(SayHelloInterceptor.class)  // тут через запятую порядок советов
public class OrderBean { }

Комбинация аннотаций @AroundInvoke и @Interceptors представляет собой
мощный инструмент, упрощающий реализацию сквозной функциональности на
основе интерцепторов EJB 3.

@Interceptors
public class SayHelloInterceptor {
  @AroundInvoke
  public Object sayHello(InvocationContext ctx) throws Exception {
    System.out.println(“Hello Interceptor!”);
    return ctx.proceed();
  }
}

5.3.5. Определение интерцепторов

*. Интерцепторы уровня методов и классов

Аннотация @Interceptors дает возможность указать один или более клас-
сов-интерцепторов для метода или класса. В листинге 5.5 единственный интер-
цептор подключается к методу findOrderById() . В этом примере перед каждым
вызовом метода findOrderById() компонента OrderBean будет вызываться метод
sayHello() класса SayHelloInterceptor :

@Interceptors(SayHelloInterceptor.class)
public Order findOrderById(String id) { ... }

В листинге 5.6 единственный интерцептор подключается к классу OrderBean .
Когда интерцептор подключается к классу, он вызывается при вызове лю-
бого метода целевого класса. В данном примере метод sayHello() класса
SayHelloInterceptor будет вызываться перед вызовом любого метода класса
OrderBean :

@Stateless
@Interceptors(SayHelloInterceptor.class)
public class OrderBean { ... }

С помощью аннотации @Interceptors можно подключить сразу несколько
интерцепторов к классу или к методу. Для этого достаточно передать аннотации
список классов-интерцепторов, перечисленных через запятую. Например, следую-
щий фрагмент подключает к классу OrderBean два интерцептора:

@Stateless
@Interceptors({SayHelloInterceptor.class, SayGoodByeInterceptor.class})
public class OrderBean { ... }

С помощью аннотации @Interceptors можно подключить сразу несколько
интерцепторов к классу или к методу. Для этого достаточно передать аннотации
список классов-интерцепторов, перечисленных через запятую. Например, следую-
щий фрагмент подключает к классу OrderBean два интерцептора:

@Stateless
@Interceptors({SayHelloInterceptor.class, SayGoodByeInterceptor.class})
public class OrderBean { ... }


*. Интерцептор по умолчанию

Помимо интерцепторов уровня класса или метода можно также определять, так
называемые, интерцепторы по умолчанию (default interceptor). Интерцептор по
умолчанию – это глобальный механизм, который подключается ко всем методам
всех компонентов в модуле.

Важно понимать, что область видимости интерцепторов по умолчанию огра-
ничена модулями, в которых они определены. Если интерцептор определяется в
файле EJB-JAR, он будет применяться только к компонентам в этом файле. Если
интерцептор определен в файле JAR, входящем в состав библиотеки или файла
WAR, он будет применяться только к компонентам в этом файле JAR, а не ко всему
файлу WAR.

Определить интерцептор по умолчанию для модуля можно только в файле
ejb-jar.xml . Никаких специальных аннотаций для таких интерцепторов не су-
ществует. Рассмотрим пример определения интерцептора по умолчанию для мо-
дуля EJB-JAR. В листинге 5.7 приводится фрагмент файла конфигурации с опре-
делениями двух интерцепторов для модуля ActionBazaar.


*. Порядок выполнения интерцепторов

У вас наверняка созрел интересный вопрос: «Если одновременно применить
интерцепторы по умолчанию, уровня класса и уровня метода (что вполне допус-
тимо), в каком порядке они будут вызываться?».

Интерцепторы вызываются в порядке сужения области их действия. То есть,
первыми будут вызваны интерцепторы по умолчанию, затем интерцепторы
уровня класса (в порядке их следования в аннотации @Interceptors ) и, нако-
нец, интерцепторы уровня метода (так же в порядке их следования в аннотации
@Interceptors ). Таков порядок вызова интерцепторов, принятый по умолча-
нию.
Изменить этот порядок можно в файле ejb-jar.xml .


*. Отключение интерцепторов

уществует две до-
полнительные аннотации, с помощью которых можно отключать интерцепторы
по умолчанию или уровня класса. Применение аннотации @javax.interceptor.
ExcludeDefaultInterceptors к классу или к методу отключает действие ин-
терцептора по умолчанию для класса или метода, соответственно.

В следующем примере
демонстрируется возможность отключения действия интерцепторов по умолча-
нию и уровня класса для метода findOrderById() , но имейте в виду, что интер-
цептор SayHelloInterceptor продолжит действовать, так как он применяется на
уровне данного метода:

@Interceptors(SayHelloInterceptor.class)
@ExcludeDefaultInterceptors
@ExcludeClassInterceptors
public Order findOrderById(String id) { ... }


5.3.6. Интерцепторы в действии

Давайте реализуем простой интерцептор журналирования для компонента
BidServiceBean из главы 2. В листинге 5.10 представлен программный код ин-
терцептора. Интерцептор подключается к методу addBid() и выводит сообщение в
консоль при каждом вызове метода. В действующих приложениях подобный ин-
терцептор можно использовать для вывода отладочной информации


@Stateless
public class BidServiceBean implements BidService {
  // Подключение интерцептора
  @Interceptors(ActionBazaarLogger.class)
  public void addBid(Bid bid) {
  }
}

public class ActionBazaarLogger {
  // Определение типа интерцептора
  @AroundInvoke
  public Object logMethodEntry(InvocationContext invocationContext)
    throws Exception {
      System.out.println(“Entering method: “
           + invocationContext.getMethod().getName());
      return invocationContext.proceed();
  }
}


Интерцеп-
тор ActionBazaarLogger подключается к методу addBid() сеансового компонен-
та без сохранения состояния PlaceBidBean с помощью аннотации @Interceptors. 

Метод logMethodEntry() объекта ActionBazaarLogger отмечен аннотацией
@AroundInvoke. Все обращения к методу addBid() будут перехватываться объ-
ектом ActionBazaarLogger и перед методом addBid() будет вызываться метод
logMethodEntry() , который выводит сообщение в системную консоль, используя
InvocationContext для включения имени целевого метода в сообщение. 

В заключение вызывается метод InvocationContext.proceed() , сообщающий 
контейнеру, что вызов addBid() был выполнен без ошибок.


*. Аспекты, окружающие вызовы

Важно отметить, что интерцептор всегда должен иметь единственный метод,
действующий как окружающий ( @AroundInvoke ) вызов целевого метода. Такие
окружающие методы не должны содержать прикладную логику, то есть, они не
должны быть общедоступными методами в прикладных интерфейсах компонен-
тов.
Окружающий метод автоматически вызывается контейнером, когда клиент об-
ращается к целевому методу.

Как можно заметить в коде
примера, любой метод, отмеченный аннотацией @AroundInvoke , должен следо-
вать следующему шаблону:

Object <METHOD>(InvocationContext) throws Exception

В качестве единственного параметра методу передается интерфейс
InvocationContext , обладающий множеством возможностей, делающих меха-
низм AOP необычайно гибким.

Вызов getMethod().getName() возвра-
щает имя метода, обращение к которому было перехвачено, – в данном случае
“addBid” .


Вызов метода proceed() чрезвычайно важен для работы интерцептора. Он со-
общает контейнеру, что тот должен передать управление следующему интерцеп-
тору в цепочке или прикладному методу. Отказ от вызова метода proceed() при-
ведет к тому, что ни прикладной метод, ни другие методы в последовательности
интерцепторов (если таковые имеются) не будут вызваны


*. Интерфейс InvocationContext

приводится определение интерфейса javax.
interceptor.InvocationContext , где можно видеть еще несколько полезных ме-
тодов.

public interface InvocationContext {
  public Object getTarget();
  public Method getMethod();
  public Object[] getParameters();
  public void setParameters(Object[]);
  public java.util.Map<String,Object> getContextData();
  public Object proceed() throws Exception;
}

Метод getTarget() возвращает экземпляр компонента, которому принадле-
жит перехваченный метод. Этот метод особенно удобно использовать для провер-
ки текущего состояния компонента по его переменным экземпляра или методам
доступа.

Метод getMethod() возвращает метод компонента, вызов которого был пере-
хвачен интерцептором. Для методов, отмеченных аннотацией @AroundInvoke , это
будет прикладной метод компонента; для методов, перехватывающих события
жизненного цикла, getMethod() вернет null .

Метод getParameters () возвращает параметры, переданные перехваченному
методу, в виде массива объектов. Метод setParameters () , напротив, позволяет
изменять значения параметров во время выполнения перед передачей их приклад-
ному методу. Эти два метода могут пригодиться для реализации интерцепторов,
манипулирующих параметрами с целью изменить поведение компонента. Интер-
цептор в приложении ActionBazaar, прозрачно округляющий все денежные суммы
до двух знаков после запятой во всех методах в приложении, как раз мог бы ис-
пользовать с этой целью методы getParameters() и setParameters().

В основе метода InvocationContext.getContextData () лежит тот факт, что
все интерцепторы в цепочке для данного прикладного метода используют один и
тот же объект контекста вызова. Как результат, прием добавления данных в объ-
ект InvocationContext можно использовать для организации взаимодействий
интерцепторов. Например, допустим, что интерцептор поддержки безопасности
сохраняет в контексте вызова результат проверки привилегий пользователя:

invocationContext.getContextData().put(“MemberStatus”, “Gold”);

Как видите, данные в контексте вызова – это обычный ассоциативный массив,
хранящий пары имя/значение. Другой интерцептор в цепочке может теперь из-
влечь эти данные и выполнить какие-то дополнительные операции, исходя из
привилегий пользователя.

Код, извлекающий уровень привилегий, мог бы выглядеть при-
мерно так:

String memberStatus =
(String) invocationContext.getContextData().get(“MemberStatus”);

В интерцепторах прикладных методов можно возбуждать или обрабатывать ис-
ключения времени выполнения (runtime exceptions) или контролируемые исклю-
чения (checked exceptions). Если интерцептор возбуждает исключение до вызова
метода proceed , остальные методы в цепочке интерцепторов, а так же прикладной
метод вызываться не будут.


*. Методы-обработчики событий жизненного цикла
в классах-интерцепторах

Как известно, аннотации @PostConstruct , @PrePassivate , @PostActivate и
@PreDestroy применяются к методам, обрабатывающим события жизненно-
го цикла. При применении этих аннотаций к методам класса-интерцептора, они
действуют точно так же. Обработчики событий в классе-интерцепторе называют
интерцепторами событий жизненного цикла. Когда целевой компонент переходит
от одного этапа к другому, вызываются аннотированные методы в классе-интер-
цепторе.

Следующий класс-интерцептор выводит сообщение, когда какой-нибудь ком-
понент в приложении ActionBazaar выделяет или освобождает ресурсы после его
создания или перед уничтожением:

public class ActionBazaarResourceLogger {

  @PostConstruct
  public void initialize(InvocationContext context) {
    System.out.println(“Allocating resources for bean: “
      + context.getTarget());
    context.proceed();
  }

  @PreDestroy
  public void cleanup(InvocationContext context) {
    System.out.println(“Releasing resources for bean: “
      + context.getTarget());
    context.proceed();
   }
}

Нет никакой
разницы между применением класса-интерцептора имеющего методы-обработчи-
ки событий и не имеющего их. Класс ActionBazaarResourceLogger , например,
применяется к компонентам так:

@Interceptors({ActionBazaarResourceLogger.class})
public class PlaceBidBean { ... }


5.3.7. Эффективное использование интерцепторов

Для большей
эффективности старайтесь не выходить за рамки решения сквозных задач, таких
как аудит, сбор статистической информации, журналирование, обработка ошибок
и так далее. Хотя интерцепторы дают возможность исследовать и изменять воз-
вращаемое значение перехваченного метода, старайтесь избегать этого.

Все, о чем рассказывалось до сих пор, касалось интерцепторов EJB.
Далее мы сравним
интерцепторы EJB с их более мощными собратьями – интерцепторами CDI.


5.3.8. Интерцепторы CDI и EJB

Интерцепторы EJB удобны, но поддерживают лишь самые основные возможнос-
ти. Механизм CDI продвинулся в этом отношении намного дальше и реализует
поддержку привязок интерцепторов, которые могут комбинироваться множест-
вом разных способов, обеспечивая тем самым более широкие возможности их ре-
ализации.

*. Подключение интерцепторов

Допустим, что в приложении ActionBazaar реализована некоторая сквозная за-
дача аудита и вам требуется включить ее в работу с использованием интерцептора
CDI. Сначала необходимо создать привязку интерцептора. Привязка – это связь
между интерцептором и компонентом EJB. Имя привязки должно отражать ее на-
значение. В данном примере мы рассматриваем задачу аудита, поэтому создадим
привязку с именем @Audited :

@InterceptorBinding
@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface Audited {}

Как видите, привязка интерцептора – это аннотация, объявленная с помо-
щью аннотации @javax.interceptor.InterceptorBinding . Теперь привязку
@Audited можно использовать в прикладном коде для подключения интерцептора
к компонентам. Для этого привязку требуется применить и к интерцептору, и к
компоненту.

*. Объявление привязок для интерцепторов

При создании класса-интерцептора CDI (совета, в мире AOP) необходимо объ-
явить, что этот класс является интерцептором, а также определить, какие привяз-
ки интерцепторов будут связаны с этим классом.

@Audited @Interceptor
public class AuditInterceptor {
  @AroundInvoke
  public Object audit(InvocationContext context) throws Exception {
    System.out.print(“Invoking: “
      + context.getMethod().getName());
    System.out.println(“ with arguments: “
      + context.getParameters());
    return context.proceed();
  }
}

Аннотация @Interceptor объявляет этот класс интерцептором. Аннотация
@Audited связывает этот интерцептор с привязкой. Все интерцепторы CDI долж-
ны быть связаны с какими-либо привязками.

*. Связывание интерцепторов с компонентами

Чтобы связать интерцептор с компонентом EJB, следует применить привяз-
ку интерцептора к классу компонента или к его методам. Другими словами,
в нашем примере, поставить аннотацию @Audited на класс или метод.

Это был простой пример, демонстрирующий использование интерцепторов
CDI. Однако возможности интерцепторов CDI могут быть намного шире, благо-
даря включению в привязки других привязок интерцепторов и объявлению не-
скольких привязок для интерцепторов.

*. Beans.xml

Напомним, что при использовании CDI, файл JAR-архива с реализацией ком-
понента должен содержаться в файле META-INF/beans.xml , чтобы механизм CDI
смог найти JAR-файлы с компонентами. Кроме того, чтобы получить возможность
использовать интерцепторы CDI, в файле beans.xml должны быть перечислены
все активируемые интерцепторы. То есть, на заключительном шаге следует доба-
вить AuditInterceptor в bean.xml :

<beans
  xmlns=”http://java.sun.com/xml/ns/javaee”
  xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”
  xsi:schemaLocation=”
    http://java.sun.com/xml/ns/javaee
    http://java.sun.com/xml/ns/javaee/beans_1_0.xsd”>
  <interceptors>
    <class>com.bazaar.AuditInterceptor</class>
  </interceptors>
</beans>


*. Множественные привязки

Представьте, что в при-
ложении ActionBazaar имеется некоторый прикладной компонент EJB, требую-
щий поддержки безопасности. Он должен быть доступен, только при соблюдении
определенных условий. Чтобы реализовать эту задачу, было решено определить
привязку интерцептора @Secured . Но, при обсуждении этой новой привязки кто-
то заметил, что в довесок к поддержке безопасности обязательно следует также
подключить логику, реализующую аудит. То есть, аудит может проводиться или не
проводиться для прикладной логики, не имеющей требований к безопасности, но
он всегда должен проводиться для прикладной логики, где безопасность являет-
ся необходимым условием. Это прекрасный случай для использования привязки
интерцептора.


@InterceptorBinding   // Привязка интерцептора
@Target({TYPE, METHOD})
@Retention(RUNTIME)
@Audited              // С дополнительной привязкой
public @interface Secured {}


*) суть в том что еще привезали интерсептор по метке [ @Audited ]
   описанный ранее
Создание привязки интерцептора @Secured осуществляется с помощью
@InterceptorBinding. Затем, включением аннотации @Audited в опреде-
ление @Secured добавляется еще одна привязка интерцептора. Это означает, что
все интерцепторы, связанные с привязками @Secured и @Audited будут автома-
тически применяться к классам или методам, отмеченным привязкой @Secured .
Например, взгляните на следующее определение SecurityCheckInterceptor :


@Secured @Interceptor
public class SecurityCheckInterceptor {
  @AroundInvoke
  public Object checkSecurity(InvocationContext context)
          throws Exception {
      // Здесь проверяется соответствие условиям безопасности
      // и если все в порядке, вызывается метод proceed
      return context.proceed();
  }
}


Теперь применим эту привязку интерцептора к методу removeBid() компонен-
та BidService – к методу, который никогда не должен вызываться без соблюдения
мер безопасности, а его вызовы обязательно должны регистрироваться на случай
проверки в будущем:


@Stateless
public class BidService {
  ...
  @Secured
  public void removeBid(Bid bid) {
    bidDao.removeBid(bid);
  }
}


При обращении к методу removeBid() привязка интерцептора @Secured пере-
хватит его. Привязка @Secured связана с SecurityCheckInterceptor , а привязка
@Audited связана с AuditInterceptor . Так как в определении @Secured использова-
лась привязка @Audited , перед вызовом removeBid() будут вызваны оба интерцеп-
тора, SecurityCheckInterceptor и AuditInterceptor .

какой из интерцепторов будет вызван первым?
Ответ на этот вопрос кроется в файле beans.xml . Перечисляя интерцепто-
ры, мы не только сообщаем механизму CDI, какие интерцепторы должны быть
активизированы, но и определяем порядок, в каком они должны вызываться.


Если интерцепторы CDI смешиваются с интерцепторами EJB, сначала будут
вызваны интерцепторы EJB, а затем интерцепторы CDI. То есть, порядок выпол-
нения интерцепторов будет следующим:
  1. Интерцепторы, перечисленные в аннотации @Interceptors .
  2. Интерцепторы, перечисленные в ejb-jar.xml .
  3. Интерцепторы CDI, перечисленные в beans.xml .
Вдобавок к возможности создания новых привязок интерцепторов с вложен-
ными привязками, сами компоненты могут включать несколько привязок интер-
цепторов.

--//--

5.4. В заключение

  --- 

--//-------------------------------------------------------------------------

# ГЛАВА 6.
# Транзакции и безопасность


Транзакции и безопасность – краеугольные камни, на которых строятся корпо-
ративные приложения. С точки зрения разработки, механизмы поддержки транз-
акций и безопасности являются, пожалуй, наиболее сложными в реализации и
практически не поддаются модификации после встраивания их в приложение.
Оба механизма считаются системной сквозной функциональностью, пронизы-
вающей прикладную логику и используемой ею. Спецификация EJB определяет
особенности обоих механизмов и тем самым создает основу для создания надеж-
ных приложений, позволяя при этом программистам сосредоточиться на приклад-
ных аспектах.

6.1. Знакомство с транзакциями

Транзакция – это группа заданий, которые должны быть выполнены атомарно.
Если какое-либо из заданий в группе не удалось выполнить, все изменения, произ-
веденные при выполнении любых других заданий, автоматически отменяются.

Поддержка транзакция является составной частью архитектуры EJB. Как будет
показано далее, при работе с компонентами EJB на выбор предоставляется две мо-
дели транзакций: программная и декларативная.

Под программными понимают-
ся транзакции, управляемые на уровне компонентов (Bean-Managed Transactions,
BMT). Используя эту модель, разработчик должен явно запускать, подтверждать
и откатывать транзакции. Декларативные транзакции – это транзакции, управляе-
мые на уровне контейнера (Container-Managed Transactions, CMT). Управление
подтверждением и откатом таких транзакций осуществляется через настройки,
указанные разработчиком.

Обратите внимание, что поддержка модели BMT распространяется также на со-
общения JMS. Это стало возможным, благодаря реализации коннекторов Java
Connector Architecture (JCA) , позволяющей взаимодействовать с корпоративны-
ми информационными системами, унаследованными системами, и поддерживаю-
щей транзакции. Системы, такие как базы данных, очереди сообщений JMS и
внешние системы, доступные через JCA, все они интерпретируются как ресурсы,
доступ к которым регулируется диспетчером ресурсов.


6.1.1. Основы транзакций

Много-много лет тому назад Джим Грей (Jim Gray) приду-
мал аббревиатуру ACID: 
Atomicity (атомарность), 
Consistency (согласованность),
Isolation (изолированность) и 
Durability (надежность).

*. Атомарность
С точки зрения программирования – если за-
ключить некоторый фрагмент кода в рамки транзакции, неожиданная ошибка в
этом фрагменте приведет к отмене всех изменений, выполненных этим фрагмен-
том.

*. Согласованность
Под согласованностью понимается допустимость состояния систе-
мы – и до, и после выполнения транзакции система должна находиться в согласо-
ванном состоянии, в соответствии с бизнес-правилами приложения.

*. Изоляция
Во вселенной Java существует четыре уровня изолированности, перечисленные
ниже.

1) Read uncommitted (чтение неподтвержденных данных ) – транзакция может
читать неподтвержденные изменения, произведенные в других транзак-
циях. 

2) Read committed (чтение подтвержденных данных ) – транзакция может чи-
тать только подтвержденные изменения, любые другие изменения, кото-
рые пока не завершены, будут недоступны. Здесь важно отметить, что если
в рамках транзакции попытаться повторно прочитать одни и те же данные,
нет никакой гарантии, что данные не изменятся.

3) Repeatable read (повторяемость чтения ) – в ходе транзакции чтение мо-
жет выполняться многократно и каждый раз будет возвращаться один и
тот же результат. Транзакция не увидит изменений, выполненных другими
транзакциями, даже если они будут подтверждены до окончания данной
транзакции. Фактически, транзакция с этим уровнем изоляции работает с
собственной копией данных.

4) Serializable (последовательный доступ ) – только одна транзакция может
работать с данными в каждый конкретный момент времени. Этот уровень
изоляции особенно ухудшает производительность, потому что исключает
возможность параллельного доступа к данным.

С увеличением степени изоляции производительность падает. Это означает,
что самая худшая производительность наблюдается при использовании уровня
Serializable – в каждый конкретный момент времени может выполняться только
одна транзакция.

*. Надежность
Под надежностью понимается сохранность изменений произведенных в рамках
транзакции. Как только владелец транзакции получит подтверждение, что она ус-
пешно завершена, он может быть уверен, что любые изменения сохранятся даже
в случае сбоя системы.


6.1.2. Транзакции в Java

Выполнение инструкций SQL и вызов хранимых процедур в базе данных про-
изводится с помощью JDBC. JDBC – это уровень абстракции доступа к базам дан-
ных, избавляющий от необходимости использовать разнородные API для разных
баз данных.

Чтобы обеспечить вы-
полнение всех этих инструкций в рамках одной транзакции, необходимо отклю-
чить автоматическое подтверждение и явно подтверждать изменения или выпол-
нять откат в случае ошибки.


Class.forName(“org.postgresql.Driver”);
Connection con =
    DriverManager.getConnection(“jdbc:postgresql:actionbazaar”,”user”,”pw”);
con.setAutoCommit(false);
try {
  Statement st = con.createStatement();
  st.executeUpdate(“insert into item ( item_id, bidstartdate, createddate ,
      initialprice , itemname ) values ( 0 , current_date, current_date,
      100.50 , ‘Apple IIGS’)”);
  st.executeUpdate(“insert into item ( item_id, bidstartdate, createddate ,
      initialprice , itemname ) values ( 1 , current_date, current_date,
      100.50 , ‘Apple IIE’)”);
  st.executeUpdate(“insert into item ( item_id, bidstartdate, createddate ,
      initialprice , itemname ) values ( 1 , current_date, current_date,
      100.50 , ‘Apple IIC’)”);
  con.commit();
} catch (Throwable t) {
  con.rollback();
  t.printStackTrace();
}


6.1.3. Транзакции в EJB

Технология Java EE, компонентом которой является EJB, создавалась с целью уп-
ростить нам жизнь. Фрагменты кода в предыдущем разделе выглядят простыми,
но эта простота обманчива.

Давайте для начала познакомимся с определениями некоторых распространен-
ных аббревиатур, которые будут встречаться вам далее, и узнаем, как они связаны
с хранением данных и транзакциями.

1) JPA (Java Persistence API) – это прикладной программный интерфейс, оп-
ределяющий порядок отображения объектов Java в реляционные струк-
туры, а также средства извлечения, сохранения и удаления этих объектов.

2) JDBC (Java Database Connectivity) – это прикладной программный интер-
фейс, определяющий порядок доступа к базе данных. Он помогает писать
универсальный программный код на Java, не зависящий от характерных
особенностей баз данных. Это относительно низкоуровневый интерфейс –
вы вынуждены будете использовать язык SQL, синтаксис которого для раз-
ных баз данных может отличаться. 

3) JTA (Java Transaction API) – это прикладной программный интерфейс уп-
равления транзакциями. Он опирается на модель распределенной обработ-
ки транзакций (Distributed Transaction Processing, DTP), созданной в Open
Group. Если вам потребуется организовать программное управление тран-
закциями или реализовать сохранение данных на уровне компонентов, вам
придется использовать интерфейсы JTA.

4) JTS (Java Transaction Service) – это спецификация, определяющая особен-
ности создания служб управления транзакциями. На основе JTS может
быть реализован механизм JTA. Как разработчику EJB, вам практически не
придется касаться JTS. JTS определена в CORBA и является частью Object
Services.

5) DataSource – интерфейс, выступающий в качестве замены для java.sql.
DriverManager (см. примеры кода в предыдущем разделе). Используется
для получения соединений с базами данных и может быть зарегистрирован
в JNDI.

6) XA – адаптация спецификации Open Group DTP для Java. В своей прак-
тике вы будете встречаться с такими классами, как javax.transaction.
xa.XAResource , javax.transaction.xa.XAConnection и другими. Пом-
ните, что спецификация DTP определяется в рамках JTA. Ресурсы и соеди-
нения механизма XA используются для поддержки транзакций, действие
которых распространяется на несколько баз данных или ресурсов, таких
как ресурсы JMS.


В EJB управление транзакциями осуществляется или программно, или с по-
мощью аннотаций.

Соединение с ресурсами, такими как базы данных, внутри контейнера
EJB осуществляется посредством объектов DataSource , и очень часто эти объек-
ты поддерживают протокол XA. Протокол XA позволяет распространять действие
транзакций сразу на несколько ресурсов, таких как базы данных и контейнеры.
Объекты DataSource можно извлекать из JNDI программно или с помощью ан-
нотации @Inject.

астройка уровней изоляции не определяется стандартом Java EE и поэтому в
каждом контейнере она может быть реализована по-разному. Чаще всего уровни
изоляции определяются при настройке DataSource.


6.1.4. Когда следует использовать транзакции

Транзакции – составная часть EJB. По умолчанию компоненты EJB используют
транзакции, управляемые на уровне контейнера, при этом для компонентов мо-
гут использоваться уже действующие транзакции или запускаться новые.

«Когда не следует использовать тран-
закции?». Транзакции бессмысленно использовать при обращении к диспетчеру
ресурсов, не поддерживающему транзакции.


6.1.5. Как реализованы транзакции EJB

Вашей первичной задачей при разработке корпоративных приложений является
правильное использование транзакций. Основу поддержки транзакций состав-
ляет механизм взаимодействий контейнера с диспетчерами ресурсов. В конеч-
ном счете все, что вы делаете в коде, транслируется в низкоуровневые операции
с базой данных, такие как блокировка и разблокировка строк или таблиц в базе
данных, ведение журнала транзакций, подтверждение транзакций применением
записей в журнале или их откат путем отмены этих записей. Компонент, реали-
зующий функции управления транзакциями при работе с определенным ресур-
сом, называется диспетчером ресурсов. Не забывайте, что ресурсом может быть
не только система управления базами данных, такая как Oracle или PostgreSQL.
Ресурсом может быть также сервер сообщений, такой как IBM MQSeries или кор-
поративная информационная система (Enterprise Information System, EIS), такая
как PeopleSoft CRM.


Точно названный диспетчер транзакций осуществляет управление
транзакциями. Он взаимодействует с одним или более диспетчерами ресурсов,
которые выполняют операции с базами данных. В случае с базой данных Oracle,
роль диспетчера ресурса играет драйвер JDBC, обеспечивающий связь с Oracle.
Диспетчер транзакций может быть частью контейнера или отдельным процессом.

Компоненты EJB взаимодействуют с диспетчером транзакций посредством
JTA. Прикладной интерфейс JTA основан на модели распределенной обработки
транзакций (DTP ), созданной в Open Group.

Модель DTP подразделяет свой интерфейс на две части: TX, диспетчер
транзакций, и XA, интерфейс между диспетчером транзакций и диспетчером ре-
сурсов.

Диспетчер транзакций координирует эти запросы между двумя дис-
петчерами ресурсов. Если попытка внести изменения в базу данных платежей по-
терпит неудачу, диспетчер транзакций обеспечит откат изменений в базе данных
товаров. Координация операций с двумя или более ресурсами достигается за счет
использования двухфазного подтверждения.


6.1.6. Двухфазное подтверждение

Протокол двухфазного подтверждения применяется в ситуациях, когда действие
транзакции распространяется на несколько ресурсов. Как следует из названия,
двухфазное подтверждение выполняется в два этапа. На первом этапе диспет-
чер транзакций опрашивает диспетчеров ресурсов на предмет готовности к под-
тверждению транзакции. Если все диспетчеры ресурсов отвечают утвердительно,
диспетчер транзакций отправляет каждому из них сообщение с подтверждением
транзакции. Если какой-то из диспетчеров ресурсов отве-
тит отрицательно, транзакция откатывается. Каждый диспетчер ресурсов отвеча-
ет за ведение собственного журнала транзакций, чтобы в случае чего транзакция
могла быть восстановлена.


6.1.7. Производительность JTA

  --- 

--//--

6.2. Транзакции, управляемые контейнером

В модели CMT запуск, подтверждение и откат транзакций осуществляется контей-
нером. Границы декларативных транзакций всегда совпадают с началом и концом
прикладных методов компонентов EJB. Точнее говоря, контейнер сначала запус-
кает транзакцию JTA, затем вызывает метод и, в зависимости от результатов вы-
полнения метода, подтверждает или откатывает транзакцию. Вам остается только
с помощью аннотаций или дескриптора развертывания сообщить контейнеру, как
он должен управлять транзакциями, и информировать диспетчера транзакций о
ситуациях, когда требуется откатить транзакцию. Как упоминалось выше, кон-
тейнер предполагает, что модель CMT должна применяться ко всем прикладным
методам компонентов.


6.2.1. Досрочное оформление заказов
с применением модели CMT

Для реализации досрочной покупки добавим метод placeSnagItOrder в сеан-
совый компонент OrderManagerBean . Код этого метода приводится в листинге 6.1.
Метод сначала проверяет, имеются ли другие ставки для этого лота, и в случае
их отсутствия проверяет кредитную карту клиента, осуществляет перевод денег и
снимает лот с торгов. Чтобы максимально упростить код, мы опустили значитель-
ную часть реализации компонента.


@Stateless(name = “BidManager”)
// использовать модель CMT
@TransactionManagement(TransactionManagementType.CONTAINER)
public class BidManagerBean implements BidManager {

  @Inject
  private CreditCardManager creditCardManager;
  @Inject                         // Внедрить
  private SessionContext context; // контекст EJB
  @Inject
  private CreditCardManager creditCardManager;

  // Определяет атрибут транзакции для метода
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  @Override
  public void placeSnagItOrder(Item item, Bidder bidder, CreditCard card) {
    try {
      if(!hasBids(item)) {
        creditCardManager.validateCard(card);
        creditCardManager.chargeCreditCard(card,item.getInitialPrice());
        closeBid(item,bidder,item.getInitialPrice());
      }  
    } catch (CreditProcessingException ce) {
      logger.log(Level.SEVERE,”An error ocurred processing the order.”,ce);
      context.setRollbackOnly();       // Выполнить откат в случае исключения
    } catch (CreditCardSystemException ccse) {
      logger.log(Level.SEVERE,”Unable to validate credit card.”,ccse);
      context.setRollbackOnly();       // Выполнить откат в случае исключения
    }
  }
}


6.2.2. Аннотация @TransactionManagement

Аннотация @TransactionManagement определяет, какая модель – CMT или
BMT – должна использоваться для этого конкретного компонента. В данном слу-
чае аннотации передается значение TransactionManagementType.CONTAINER ,
которое означает, что управление транзакциями для компонента осуществляется
контейнером. Если бы мы решили управлять транзакциями программно, мы ука-
зали бы значение TransactionManagementType.BEAN . Обратите внимание: хотя
мы и включили данную аннотацию в пример, делать это было совсем необязатель-
но, так как модель CMT используется по умолчанию.

6.2.3. Аннотация @TransactionAttribute

Хотя при использовании модели CMT большую часть хлопот берет на себя кон-
тейнер, вам все еще необходимо явно сообщить ему как он должен управлять
транзакциями. Чтобы понять, что под этим имеется в виду, представьте, что метод
placeSnagItOrder мог бы вызываться из другого компонента, для которого уже
была запущена транзакция. Какой сценарий действий предпочли бы вы: приоста-
новить внешнюю транзакцию, присоединиться к ней или отменить? В нашем слу-
чае метод placeSnagItOrder вызывается из веб-слоя приложения, где транзакции
не используются, поэтому очевидно, что должна быть запущена новая транзакция.
Аннотация @TransactionAttribute дает возможность указать контейнеру, как он
должен действовать в отношении транзакций.

атрибут MANDATORY транзакции. Это означает, что вызов метода должен осу-
ществляться только в рамках уже действующей транзакции – для него не может
запускаться новая транзакция. Это вполне логично: разве можно снять деньги со
счета в отрыве от другой операции, такой как обработка заказа? При вызове этого
метода, он присоединится к транзакции, запущенной методом placeSnagItOrder .
Если в CreditCardManagerBean возникнет ошибка, все изменения, произведен-
ные в методе placeSnagItOrder , также будут отменены.

Влияние атрибутов транзакций на методы компонентов EJB

*) везде вопрос: [ Транзакция запущена вызывающим кодом? ]


[ REQUIRED ]
[ Нет ] - Контейнер запустит новую транзакцию.
[ Да ]  - Метод присоединится к запущенной транзакции.


[ REQUIRES_NEW ]
[ Нет ] - Контейнер запустит новую транзакцию.
[ Да ]  - Контейнер запустит новую транзакцию, а сущест-
          вующая транзакция будет приостановлена.


[ SUPPORTS ]
[ Нет ] - Транзакции не используются.
[ Да ]  - Метод присоединится к запущенной транзакции.


[ MANDATORY ]
[ Нет ] - Вызовет исключение
          javax.ejb.EJBTransactionRequiredException.
[ Да ]  - Метод присоединится к запущенной транзакции.


[ NOT_SUPPORTED ]
[ Нет ] - Транзакции не используются.
[ Да ]  - Существующая транзакция будет приостановле-
          на, а метод продолжит работу вне транзакции.


[ NEVER ]
[ Нет ] - Транзакции не используются.
[ Да ]  - Вызовет исключение javax.ejb.EJBException.


*. REQUIRED
Значение REQUIRED используется по умолчанию и имеет наиболее широкую
область применения. Он указывает, что метод компонента EJB всегда должен
вызываться в контексте транзакции. Если клиент, вызывающий метод, не запус-
тит транзакцию, контейнер запустит ее автоматически перед вызовом метода
и подтвердит по завершении метода. С другой стороны, если вызывающий код
уже выполняется в контексте транзакции, метод будет выполнен в рамках этой
транзакции.

*. REQUIRES_NEW
Значение REQUIRES_NEW указывает, что контейнер всегда должен запускать но-
вую транзакцию перед вызовом метода. Если вызывающий код уже запустил тран-
закцию, она будет приостановлена, пока метод не вернет управление. Это означа-
ет, что успех или неудача при выполнении новой транзакции никак не отразится
на существующей.

Значение REQUIRES_NEW имеет ограниченное применение. Его следует исполь-
зовать, когда операции должны выполняться в контексте транзакции, но при этом
откат этой транзакции не должен повлиять на клиента, и наоборот.

*. SUPPORTS
Значение SUPPORTS указывает, что метод имеет двойственное отношение к
транзакциям. Если вызывающий код запустил транзакцию, метод присоединит-
ся к ней. Если же транзакция не была запущена, метод не будет запускать новую
транзакцию.

*. MANDATORY
Значение MANDATORY указывает, что метод должен вызываться в контексте уже
действующей транзакции.
Перед вызовом такого метода контейнер прове-
рит наличие действующей транзакции и при ее отсутствии возбудит исключение
EJBTransactionRequiredException .

*. NOT_SUPPORTED
Когда метод отмечен атрибутом NOT_SUPPORTED , он не может вызываться в
контексте транзакции. Если перед вызовом метода вызывающий код запустит
транзакцию, контейнер приостановит ее, вызовет метод и после завершения ме-
тода возобновит транзакцию. Этот атрибут обычно используется для поддержки
провайдера JMS в режиме с автоматическим подтверждением транзакций. В этом
случае получение сообщения подтверждается сразу же после успешной доставки,
и у компонента MDB нет никакой возможности или явной необходимости выпол-
нить откат факта доставки сообщения.

*. NEVER
В модели CMT значение NEVER означает, что метод никогда не должен вызы-
ваться в контексте транзакции. Если такая попытка будет произведена, контейнер
возбудит исключение javax.ejb.EJBException .


*. Атрибуты транзакций и компоненты MDB
Как говорилось в главе 4, компоненты MDB поддерживают только часть из этих
шести атрибутов – REQUIRED и NOT_SUPPORTED . Напомним, что клиенты никогда
не вызывают компоненты MDB непосредственно – они вызываются в момент до-
ставки сообщения компоненту из очереди. В этот момент не существует никаких
транзакций, которые можно было бы приостановить или к которым можно было
присоединиться.

Таким образом, двух атрибутов
оказывается вполне достаточно: атрибут REQUIRED используется, когда необходи-
мо обеспечить выполнение операций в контексте транзакций, и SUPPORTS – когда
в этом нет необходимости.


6.2.4. Откат транзакций в модели CMT

Модель CMT
дает компонентам возможность сообщить контейнеру о необходимости откатить
транзакцию. Откат не выполняется немедленно – сначала устанавливается флаг,
а в конце действия транзакции контейнер выполняет откат, руководствуясь этим
флагом.

@Resource
private SessionContext context;
public void placeSnagItOrder(Item item, Bidder bidder, CreditCard card) {
  try {
  ...
  } catch (CreditProcessingException ce) {
    logger.log(Level.SEVERE,”An error ocurred processing the order.”,ce);
    context.setRollbackOnly();
  }
  ...
}

Как видно в этом фрагменте, при обработке ошибки, связанной с номером кре-
дитной карты, вызов метода setRollbackOnly объекта javax.ejb.EJBContext
отмечает транзакцию для отката. Если не сделать этого, тогда все изменения в
данных будут подтверждены. Важно помнить, что вся ответственность за вызов
этого метода в случае исключений целиком возлагается на вас.

Метод setRollbackOnly объекта EJBContext может вызываться, только из ме-
тодов, отмеченных атрибутом транзакции REQUIRED , REQUIRED_NEW или MANDATORY .
Если транзакция не была запущена, как в случае с атрибутами SUPPORTED и NEVER ,
контейнер возбудит исключение java.lang.IllegalStateException .

Как отмечалось выше, когда транзакция отмечается как подлежащая отмене, она
не завершается немедленно. То есть метод не завершается сразу же после вызова
setRollbackOnly – он продолжает выполнение, как если бы ничего не произош-
ло. Объект EJBContext предоставляет метод, с помощью которого можно узнать,
не отмечена ли транзакция для отмены: getRollbackOnly() .


public void placeSnagItOrder(Item item, Bidder bidder, CreditCard card) {
  try {
    if(!hasBids(item)) {
      creditCardManager.chargeCreditCard(card,item.getInitialPrice());
      if(!context.getRollbackOnly()) {
        closeBid(item,bidder,item.getInitialPrice());
      }
  }

Если обработка исключений, заключающаяся только в вызове setRollbackOnly ,
кажется утомительной, механической работой, вам приятно будет узнать, что в
EJB 3 имеется более простое решение, основанное на аннотациях, о чем рассказы-
вается далее.


6.2.5. Транзакции и обработка исключений

Чтобы избежать
необходимости снова и снова писать один и тот же шаблонный код, в EJB 3 была
возможность управлять результатом транзакции в случае исключений с помощью
аннотации @javax.ejb.ApplicationException.

приводится измененная версия метода
placeSnagItOrder , отмеченного аннотацией @ApplicationException , осущест-
вляющей откат транзакции в случае исключения.

// Объявление возбуждаемых исключений в инструкции
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public void placeSnagItOrder(Item item, Bidder bidder, CreditCard card) 
  throws CreditProcessingException, CreditCardSystemException {
  // Исключения могут возбуждаться в следующих вызовах методов
  if(!hasBids(item)) {
    creditCardManager.validateCard(card);
    creditCardManager.chargeCreditCard(card,item.getInitialPrice());
    closeBid(item, bidder, item.getInitialPrice());
  }
}
...
// Определение ApplicationException
@ApplicationException(rollback=true)
public class CreditProcessingException extends Exception {
...
// Отмечает RuntimeException как ApplicationException
@ApplicationException(rollback=true)
public class CreditCardSystemException extends RuntimeException {


Но самое важное, на что следует обратить внимание, – это
две аннотации @ApplicationException перед классами исключений. Аннотация
@ApplicationException идентифицирует контролируемые (checked) и некон-
тролируемые (unchecked) исключения Java как прикладные исключения.

(*) Прикладное исключение – это исключение, которое, как ожидается, бу-
дет обработано клиентом, использующим компонент EJB. В случае возбуждения такие
исключения передаются непосредственно в вызывающий код. По умолчанию все конт-
ролируемые исключения, кроме java.rmi.RemoteException , считаются прикладными
исключениями. Все исключения, наследующие класс java.rmi.RemoteException или
java.lang.RuntimeException (неконтролируемые) считаются системными исключе-
ниями. В EJB не предполагается, что клиент будет обрабатывать системные исключе-
ния. Поэтому такие исключения не передаются клиенту, а заворачиваются в javax.ejb.
EJBException.

аннотация @ApplicationException изменяет поведение исключения
CreditCardSystemException, которое в ином случае было бы завернуто в
EJBException , потому что интерпретируется как системное исключение. Приме-
нение аннотации @ApplicationException вынуждает интерпретировать это ис-
ключение как прикладное.

Возможно вы обратили внимание на атрибут rollback аннотации
@ApplicationException . По умолчанию прикладные исключения не вызывают
автоматический откат транзакций в модели CMT, потому что этот атрибут полу-
чает значение false , если явно не указано иное. Присвоив ему значение true , мы
сообщаем контейнеру, что он должен откатить транзакцию, прежде чем передать
исключение клиенту.


6.2.6. Синхронизация с сеансом

Интерфейс синхронизации с сеансом позволяет сеансовым компонентам с сохране-
нием состояния получать извещения о прохождении различных границ этапов тран-
закции. Данный интерфейс определен как javax.ejb.SessionSynchronization .
Чтобы воспользоваться им, компонент должен реализовать методы интерфейса.
Этот интерфейс определяет три метода:
 - void afterBegin () – вызывается сразу после запуска новой транзакции
   контейнером, но перед вызовом прикладного метода;
 - void beforeCompletion () – вызывается перед тем, как прикладной метод
   вернет управление, но до того, как контейнер завершит транзакцию;
 - void afterCompletion (boolean committed) – вызывается сразу после
   завершения транзакции; флаг boolean committed позволяет определить,
   была ли подтверждена транзакция или произошел откат.


6.2.7. Эффективное использование модели CMT

Модель CMT намного проще в использовании, в сравнении с моделью BMT. В от-
сутствие аннотаций и специфичных настроек в дескрипторе развертывания, ком-
поненты автоматически будут использовать модель CMT и отмечаться атрибутом
транзакций REQUIRED .

Чтобы упростить сопровождение кода, желательно определить логические гра-
ницы транзакции и создать отдельный метод, осуществляющий операции в кон-
тексте этой транзакции. Этот метод должен решать две основные задачи: пере-
хватывать прикладные исключения и устанавливать флаг, управляющий откатом
транзакции. Обработка прикладных исключений должна быть сосредоточена в
одном месте, а на «размазываться» по множеству компонентов, участвующих в
транзакции.

перед выполнением продолжительных операций обязательно вызывайте метод
getRollbackOnly() , чтобы убедиться в их целесообразности. Бессмысленно тра-
тить время на длительные вычисления, если результаты в конечном итоге будут
просто отброшены.

Правильная обработка прикладных исключений также имеет большое зна-
чение, потому что для таких исключений контейнер не выполняет откат тран-
закции автоматически. Если код может возбуждать прикладные исключения,
требующие отмены транзакции, обязательно предусматривайте их обработ-
ку. По возможности старайтесь отмечать прикладные исключения аннотацией
@ApplicationException . Это уменьшит риск появления ошибок, когда по забыв-
чивости пропущен вызов метода setRollbackOnly() .

--//--

6.3. Транзакции, управляемые компонентами

Сила модели CMT является и ее слабостью. При использовании этой модели гра-
ницы транзакций принудительно устанавливаются в соответствии с границами
прикладных методов, и вы не можете решать, когда запускать транзакции, когда
подтверждать их или откатывать. Модель BMT, напротив, позволяет управлять
всем этим программно, используя семантику, напоминающую модель транзакций
JDBC.


6.3.1. Досрочное оформление заказов с применением модели BMT

@Stateless(name = “BidManager”)            // использовать модель BMT
@TransactionManagement(TransactionManagementType.BEAN)
public class BidManagerBean implements BidManager {

  @Resource                                // Внедрить
  private UserTransaction userTransaction; // UserTransaction

  public void placeSnagItOrder(Item item, Bidder bidder, CreditCard card) {
    try {
      userTransaction.begin();             // Запустить транзакцию
      if(!hasBids(item)) {
        creditCardManager.validateCard(card);
        creditCardManager.chargeCreditCard(card,item.getInitialPrice());
        closeBid(item,bidder,item.getInitialPrice());
      }
      userTransaction.commit();            // Подтвердить транзакцию
    } catch (CreditProcessingException ce) {
      logger.log(Level.SEVERE,"An error ocurred processing the order.",ce);  
      context.setRollbackOnly();           //  В случае исключения откатить транзакцию
    } catch (CreditCardSystemException ccse) {
      logger.log(Level.SEVERE,“Unable to validate credit card.”,ccse);
      context.setRollbackOnly();
    } catch (Exception e) {
      logger.log(Level.SEVERE,“An error ocurred processing the order.”,e);
    }
  }

}


Обратите внимание на аннотацию @TransactionManagement , которой на этот
раз вместо значения TransactionManageMentType.CONTAINER передано значение
TransactionManagementType.BEAN , указывающее, что используется модель BMT

внедряется объект UserTransaction , реали зующий интерфейс JTA посредством 
которого явно осуществляется запуск , подтверждение и откат транзакции.


6.3.2. Получение экземпляра UserTransaction

Интерфейс UserTransaction включает в себя основные функциональные воз-
можности, предоставляемые диспетчером транзакций Java EE. Механизм JTA
содержит ряд других интерфейсов, используемых в разных ситуациях, но мы
не будем охватывать их здесь, потому что в подавляющем большинстве случаев
вам достаточно будет интерфейса UserTransaction . Как можно догадаться, ин-
терфейс UserTransaction является слишком запутанным, чтобы создавать не-
посредственно, поэтому его проще получить с помощью контейнера.

*. Поиск в JNDI

Сервер приложений связывает UserTransaction с именем JNDI java:comp/
UserTransaction . Поиск объекта в реестре JNDI можно выполнить вручную, как
показано ниже:


Context context = new InitialContext();
UserTransaction userTransaction = (UserTransaction)context.lookup(“java:comp/
  UserTransaction”);
userTransaction.begin();
  // Выполнить операции в контексте транзакции.
userTransaction.commit();


*. EJBContext

Получить ссылку на UserTransaction можно также вызовом метода
getUserTransaction объекта EJBContext . Этот прием может пригодить-
ся при наличии ссылки на SessionContext или MessageDrivenContext для
каких-то других целей, когда внедрение отдельного экземпляра интерфей-
са для доступа к транзакциям нежелательно.


@Resource
private SessionContext context;
...
UserTransaction userTransaction = context.getUserTransaction();
userTransaction.begin();
// Выполнить операции в контексте транзакции.
userTransaction.commit();


6.3.3. Использование интерфейса UserTransaction


Вы уже видели наиболее часто используемые методы интерфейса
UserTransaction : begin , commit и rollback . Однако этот интерфейс имеет еще
ряд полезных методов, с которыми стоит познакомиться поближе. Взгляните, как
выглядит полное определение интерфейса:


public interface UserTransaction {
  public void begin() throws NotSupportedException, SystemException;
  public void commit() throws RollbackException,
    HeuristicMixedException,HeuristicRollbackException, SecurityException,
    IllegalStateException, SystemException;
  public void rollback() throws IllegalStateException,
    SecurityException,SystemException;
  public void setRollbackOnly() throws IllegalStateException,
    SystemException;
  public int getStatus() throws SystemException;
  public void setTransactionTimeout(int seconds) throws SystemException;
}

Метод begin создает новую, низкоуровневую транзакцию и связывает ее с
текущим потоком выполнения. Возможно вам будет интересно узнать, что про-
изойдет, если вызвать метод begin дважды, прежде обратиться к методу rollback
или commit . Может показаться, что таким способом можно запустить вложенную
транзакцию. Однако это не так. В действительности второй вызов метода begin
возбудит исключение NotSupportedException , потому что Java EE не поддержи-
вает вложенные транзакции.

Методы commit и rollback , в свою очередь, удаляют
транзакцию, связанную с текущим потоком выполнения вызовом метода begin .
При этом метод commit посылает диспетчеру транзакций сигнал «успеха», а метод
rollback отменяет текущую транзакцию.

Метод getStatus является более надежной версией метода getRollbackOnly из
мира CMT. Вместо логического значения он возвращает целочисленный код, по-
зволяющий более точно определить состояние текущей транзакции. Возможные
состояния определяются интерфейсом javax.transaction.Status

(*) Возможные значения интерфейса javax.transaction.
Status interface, определяющие коды состояния, возвращаемые методом
UserTransaction.getStatus

//--------------------------\\
[STATUS_ACTIVE]          Транзакция находится в активном состоянии.
[STATUS_MARKED_ROLLBACK] Транзакция находится в активном состоянии.

[STATUS_ACTIVE]    Транзакция находится в активном состоянии.
[STATUS_ACTIVE]    Транзакция отмечена, как предназначенная для отката, воз-
                   можно вызовом метода setRollbackOnly.
[STATUS_PREPARED]  Транзакция находится в состоянии готовности, когда все ре-
                   сурсы готовы к подтверждению.
[STATUS_COMMITTED] Транзакция была подтверждена.               

[STATUS_COMMITTED] Транзакция была подтверждена.  
[STATUS_ROLLBACK]  Транзакция была отменена.
[STATUS_UNKNOWN]   Состояние транзакции неизвестно. 

[STATUS_NO_TRANSACTION] Транзакция была подтверждена.  
[STATUS_PREPARING]      Транзакция готовится к подтверждению и ожидает ответа от
                        подчиненных ресурсов. (См. раздел 6.1.6. «Двухфазное под-
                        тверждение».)
[STATUS_COMMITTING]     Транзакция находится в процессе подтверждения. 
[STATUS_ROLLING_BACK]   Транзакция находится в процессе отмены. 
//--------------------------\\


6.3.4. Эффективное использование модели BMT

Компоненты EJB по умолчанию используют модель CMT управления транзакци-
ями. Вообще не следует злоупотреблять применением модели BMT из-за увели-
чения объема кода, который придется писать, и более высокой сложности.

--//--

6.4. Безопасность EJB

Безопасность обеспечива-
ется двумя основными способами: предоставление доступа пользователям только
к тем данным и операциям, на которые они имеют права, и предотвращение обхода
защитных механизмов хакерами.

Подходы к поддержке безопасности в EJB в чем-то напоминают транзакции: вы
можете управлять доступом декларативно или программно. Однако вам не при-
дется выбирать между этими двумя моделями: вы можете свободно использовать
декларативную модель в одних компонентах и программную в других.

6.4.1. Аутентификация и авторизация

Поддержка безопасности приложения заключается в двух основных функциях:
аутентификации и авторизации. Аутентификация должна выполняться перед
авто ризацией

Аутентификация – это процедура проверки идентичности пользователя. Пу-
тем аутентификации пользователь доказывает свою подлинность.

Авторизация – это процедура определения прав пользователя на доступ к ре-
сурсам и операциям. Авторизации предшествует аутентификация – только после
аутентификации пользователя можно установить круг его прав.

6.4.2. Пользователи, группы и роли

Пользователи , группы и роли – это три, тесно связанных между собой понятия,
образующие основу поддержки безопасности в EJB. Мы уже упоминали поня-
тие «пользователь», поэтому начнем с групп.

Группы – это способ
логического разделения пользователей, помогающий приложению идентифици-
ровать, кто к каким функциям должен иметь доступ – например, к функциям ад-
министрирования, поддержке клиентов и так далее.

Роль – это абстракция группы
в контейнере приложения. Обычно в приложении определяется система соот-
ветствий между группами и ролями. То есть, эта абс-
тракция позволяет отделить группы от фактических названий групп, используе-
мых в производстве. Приложение может иметь группу Administrator, тогда как в
каталоге LDAP компании аналогом ей является роль Department Head (началь-
ник отдела, начальник службы).

6.4.3. Как реализована поддержка безопасности в EJB

Поддержка безопасности в Java EE в значительной степени основана на служ-
бе Java Authentication and Authorization Service (JAAS) . Служба JAAS отделяет
систему аутентификации от приложения Java EE посредством четко определен-
ного, подключаемого API. Приложение Java EE взаимодействует только с JAAS
API – оно не несет ответственности за такие низкоуровневые тонкости, связанные
с аутентификацией пользователя, как шифрование паролей или взаимодейст вие
с внешней службой аутентификации, такой как Microsoft Active Directory или
LDAP. Все это берет на себя модуль, созданный разработчиками контейнера, и
доступный вам для настройки. В дополнение к аутентификации контейнер реа-
лизует еще и авторизацию в слое прикладной логики и в веб-слое EJB, так же с
использованием JAAS.

JAAS API спроектирован так, что позволяет выполнять оба шага – аутентифи-
кацию и авторизацию – из любого слоя Java EE, включая веб-слой и слой ком-
понентов EJB.

После
аутентификации соответствующий контекст становится доступен всем уровням
приложения, что избавляет от необходимости повторно выполнять аутентифика-
цию. Контекст аутентификации доступен в виде объекта Principal

пользователь входит в приложение через веб-слой.
Веб-слой получает от пользователя информацию об аутентификации и проверяет
ее с помощью JAAS. В случае успеха создается действительный объект Principal .
В этот момент объекту Principal присваивается одна или более ролей. После это-
го, при обращении к каждому ресурсу в веб-слое или в слое компонентов EJB, сер-
вер приложений будет проверять право на доступ к ресурсу.

*. Аутентификация и авторизация в веб-слое

Поддержка безопасности в веб-слое настраивается с помощью элементов
login-config и security-constraint в файле web.xml.

<login-config>
  <!-- Устанавливается метод аутентификации FORM -->
  <auth-method>FORM</auth-method>

  <!-- Имя области действия аутентификации -->
  <realm-name>ActionBazaarRealm</realm-name>

  <form-login-config>
    <!-- Форма, используемая для аутентификации -->
    <form-login-page>/login.faces</form-login-page>
    <!-- Страница с сообщением об ошибке, на случай неудачи аутентификации -->
    <form-error-page>/login_error.faces</form-error-page>
  </form-login-config>
</login-config>


<security-constraint>
  <web-resource-collection>
    <web-resource-name>
      Action Bazaar Administrative Component
    </web-resource-name>
    <!-- Шаблон URL блокируемых страниц -->
    <url-pattern>/admin/*</url-pattern>
  </web-resource-collection>
  <auth-constraint>
    <!-- Роль, дающая право доступа к коллекции ресурсов -->
    <role-name>CSR</role-name>
  </auth-constraint>
</security-constraint>


Эти настройки определяют, как веб-контейнер должен получать и проверять
информацию об аутентификации. В данном случае ввод информации осуществля-
ется с помощью нестандартной формы, поэтому в качестве метода аутентификации
указан метод FORM.

приводится разметка формы аутентификации. Когда форма бу-
дет передана браузером на сервер, контейнер извлечет параметры запроса с име-
нем пользователя и паролем, и выполнит аутентификацию.

<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”
  “http://www.w3.org/TR/html4/loose.dtd”>
<HTML xmlns:f=http://java.sun.com/jsf/core
  xmlns:h=”http://java.sun.com/jsf/html”>
  
    <h:head>
      <title>ActionBazaar Admin Login</title>
    </h:head>
  
  <h:body>
    <!-- Определить действие для формы -->
    <form action=”j_security_check” method=”POST”>
      <h:panelGrid columns=”2”>
        <f:facet name=”header”>
          Authentication
        </f:facet>
        <h:outputText value=”Username”/>
        <!-- Поле ввода имени пользователя -->
        <input type=”text” name=”j_username” size=”25”/>
        <h:outputText value=”Password”/>
        <!-- p Поле ввода пароля -->
        <input type=”password” size=”15” name=”j_password”/>
        <h:panelGroup>
          <input type=”submit” value=”Submit”/>
          <input type=”reset” value=”Reset”/>
        </h:panelGroup>
      </h:panelGrid>
    </form>
  </h:body>
</HTML>

Контейнер должен содержать реализацию действия j_security_check для
обработки формы


6.4.4. Декларативное управление безопасностью в EJB

Декларативное управление безопасностью чем-то напоминает модель CMT уп-
равления транзакциями. Вы сообщаете контейнеру о своих желаниях посредством
аннотаций или файлов с настройками, а контейнер заботится об их воплощении.

Контейнер просматривает результаты преобразо-
вания ролей, используемых сервером, в группы приложения и затем сопоставляет
их со списком допустимых ролей, чтобы определить возможность обращения к
конкретному методу или компоненту. Если обращение невозможно, возбуждается
исключение.

Защита функции удаления ставок с использованием декларативного
управления безопасностью


// Объявление ролей для компонента
@DeclareRoles({“BIDDER”, “CSR”, “ADMIN”})
@Stateless(name = “BidManager”)
public class BidManagerBean implements BidManager {

  // Список ролей, разрешающих доступ к методу
  @RolesAllowed({“CSR”,”ADMIN”})
  public void cancelBid(Bid bid) {
    ...
  }

  // Разрешает доступ для всех системных ролей
  @PermitAll
  public List<Bid> getBids(Item item) {
    return item.getBids();
  }

}

*. Аннотация @DeclareRoles
Аннотация @DeclareRoles перечисляет роли, используемые для проверки прав
доступа к компоненту EJB. Она может применяться только к классу целиком.
В отсутствие этой аннотации, контейнер найдет все аннотации @RolesAllowed
и сам сконструирует список ролей для класса.

*. Аннотация @RolesAllowed
является решающей при декларативном управле-
нии безопасностью. Она может применяться либо к прикладным методам компо-
нента EJB, либо ко всему классу. При применении ко всему классу, она сообщает
контейнеру список ролей, которым позволено обращаться к любым методам компо-
нента. Если эта аннотация применяется к методу, она определяет правила доступа
к этому конкретному методу.

*. Аннотации @PermitAll и @DenyAll
Аннотации @PermitAll и @DenyAll говорят сами за себя – они открывают или
закрывают доступ сразу всем.

*. @RunAs
Аннотация @RunAs напоминает утилиту sudo в Unix, которая позволяет выпол-
нить команду от имени другого пользователя. Часто этим другим пользователем
оказывается администратор. Данная аннотация дает возможность выполнять опе-
рации с разными наборами привилегий, которые могут быть более или менее ог-
раниченными.

С помощью аннотации @RunAs можно временно присвоить пользователю с
ролью CSR привилегии роли ADMIN , чтобы вызываемый компонент EJB считал, что
к нему обращается администратор

@RunAs(“ADMIN”)
@RolesAllowed({“CSR”})
public void cancelBid(Bid bid, Item item) {...}


6.4.5. Программное управление безопасностью в EJB

Декларативное управление безопасностью обладает широкими возможностями, но
иногда бывает необходимо организовать более избирательное управление. Напри-
мер, может потребоваться менять поведение метода в зависимости от роли поль-
зователя или даже имени пользователя. Кроме того, может оказаться желательно
проверить принадлежность пользователя сразу двум группам или убедиться, что
пользователь входит в одну группу и не входит в другую. Используя программное
управление безопасностью легко можно реализовать подобные сценарии.

Прежде
чем углубиться в изучение, хочу предупредить, что программная и декларативная
модели управления безопасностью не являются взаимоисключающими.

Защита функции удаления ставок с использованием программного
управления безопасностью

@Resource      // Внедрение контекста EJB
private SessionContext context;

public void cancelBid(Bid bid) {
  // Проверка авторизации
  if(!context.isCallerInRole(“CSR”) && !context.isCallerInRole(“ADMIN”))
  {
     // Возбудить исключение при нехватке прав
     throw new SecurityException(
       “You do not have permission to cancel an order.”);
     ...
   }
}

с помощью
метода isCallerInRole объекта EJBContext проверяется – обладает ли вызыва-
ющий код правами роли CSR. Если проверка не увенчалась успехом, возбуж-
дается исключение java.lang.SecurityException , извещающее пользователя о
недостаточности прав.

*. isCallerInRole и getCallerPrincipal

Программное управление безопасностью осуществляется достаточно просто.
Основные операции управления выполняются с помощью двух методов, доступ-
ных через интерфейс javax.ejb.EJBContext

public interface EJBContext {
  ...
  public java.securityPrincipal getCallerPrincipal();
  public boolean isCallerInRole(java.lang.String roleName);
  ...
}

Вы уже видели метод isCallerInRole в действии. Его имя говорит само за
себя. За кулисами объект контекста EJB извлекает объект Principal , связан-
ный с текущим потоком выполнения, и проверяет наличие роли с именем, сов-
падающим с указанным вами. Метод getCallerPrincipal дает прямой доступ
к объекту java.security.Principal , представляющему текущий контекст ау-
тентификации. Единственный метод в интерфейсе Principal , представляющий
интерес, – это метод getName , возвращающий имя пользователя, с привилегиями
которого выполняется код.


*. Использование интерцепторов в программном управлении безопасностью

public class SecurityInterceptor {
  @Resource
  private SessionContext sessionContext;
  
  // Пометить метод как интерцептор
  @AroundInvoke
  public Object checkUserRole(InvocationContext context) throws Exception {
    // Обращение к EJBContext из InvocationContext
    if(!sessionContext.isCallerInRole(“CSR”)) {
      throw new SecurityException(“No permission to cancel bid.”);
    }
    return context.proceed();
  }
}

@Stateless
public class BidManagerBean implements BidManager {
  // Назначается интерцептор для метода
  @Interceptors(SecurityInterceptor.class)
  public void cancelBid(Bid bid) {...}
}


Метод checkUserRole класса SecurityInterceptor отмечен как интерцептор
типа AroundInvoke , который вызывается при каждом обращении к перехватывае-
мому методу. В методе с помощью объекта Principal проверяется наличие
привилегий роли CSR. Если соответствие указанной роли не обнаруживается,
возбуждается исключение SecurityException .


6.4.6. Эффективное использование поддержки безопасности в EJB

Декларативная модель намного проще для анализа и
меньше подвержена ошибкам, чем модель программного управления. Применяя
декларативный подход можно аннотировать классы и при необходимости пере-
определять настройки безопасности для отдельных методов.

6.5. В заключение

  ---

--//-------------------------------------------------------------------------

# Глава 7.
# Планирование и таймеры

иногда бывает необхо-
димо, чтобы приложение само выполнило какие-то действия, через некоторый ин-
тервал или в определенный момент времени. Реализовать та-
кое поведение можно с помощью службы таймеров EJB Timer Service. Эта служба
поможет вам создавать приложения, планирующие свои операции.

7.1. Основы планирования

Метод вызывается точно так же, как если бы его
вызов был инициирован пользователем через веб-интерфейс. Контейнер автома-
тически выполнит внедрение всех необходимых зависимостей, без всякого вме-
шательства с вашей стороны. Если таймер окажется периодическим (например,
срабатывающим каждые 10 минут), автоматически будет создан новый таймер,
которые сработает через 10 минут.

7.1.1. Возможности Timer Service

службу Timer Service можно с успехом использовать для рас-
сылки электронной почты в полночь. Однако использовать ее для мониторинга
показаний трубок Пито на самолете и рассчитывать тягу двигателей – это плохая
идея. (могут быть сильные сдвиги по времени срабатывания)

*. Поддерживаемые типы компонентов

службу EJB Timer Service стало возможно использо-
вать с сеансовыми компонентами без сохранения состояния, компонентами-оди-
ночками и компонентами, управляемыми сообщениями . Сеансовые компоненты
с сохранением состояния не поддерживаются – возможно в будущем такая под-
держка появится, но на сегодняшний день она отсутствует.

*. Надежность

Таймеры службы EJB Timer Service спокойно
переживают перезапуск сервера без какого-либо вмешательства с вашей стороны.

*. Создание таймеров

Запланировать выполнение операций можно в конфигурационном файле, про-
граммно или с помощью аннотаций.
Программный способ обычно используется для создания таймеров по
требованию конечного пользователя, а также, когда таймеры являются неотъемле-
мой частью логики работы приложения.

7.1.2. Таймауты

Срабатывание таймера действует
как звонок, дающий команду на выполнение каких-то операций – вы настраива-
ете таймер и указываете ему, какое действие должно быть выполнено. Действием
может быть реализация метода ejbTimeout , определяемого интерфейсом javax.
ejb.TimedObject , или любой другой метод, отмеченный аннотацией @Scheduled .
Таймауты могут также настраиваться в конфигурационных файлах XML.

7.1.3. Cron

Под названием cron подразумевается планировщик заданий, имеющийся во мно-
гих Unix-системах. Он осуществляет прило-
жения или сценарии в указанные моменты времени для выполнения таких задач,
как ротация файлов журналов, перезапуск служб и так далее. Конфигурационный
файл планировщика, известный как crontab , определяет команды для запуска и
расписание.

Cron – имеет чрезвычайно гибкие возможности планирования. На-
пример, с помощью cron можно запланировать выполнение некоторого задания
в первую субботу каждого месяца.


* * * * * Команда
| | | | |  
| | | | ---- День недели (0-7)
| | | ------ Месяц (1-12)
| | -------- День Месяца(1-31)
| ---------- Час (0-23)
------------ Минута (0-59)


7.1.4. Интерфейс Timer

Как будет показано далее, существует три способа настройки таймеров: с по-
мощью аннотаций, программно и посредством конфигурационных файлов. Уп-
равлять отдельными таймерами можно с помощью интерфейса javax.ejb.Timer.
Этот интерфейс предоставляет единственную
операцию cancel и несколько методов для извлечения информации о таймере.
Для получения представления таймера, которое может быть сериализовано, ис-
пользуется метод getHandle() . Он возвращает javax.ejb.TimerHandle , с по-
мощью которого можно получить экземпляр таймера. Объект TimerHandle мо-
жет существовать только внутри контейнера – его нельзя передать удаленному
коду.

Информацию, указанную при создании таймера, можно извлечь вызовом
метода getInfo() . Это может быть любой сериализованный объект, но в атри-
буте info аннотации Schedule допускается передавать только строки. Метод
getNextTimeout() возвращает объект Date с временем срабатывания таймера.
Обратите внимание, что к моменту, когда вы будете выполнять проверку, таймер
может уже сработать. Для таймеров на основе cron метод getSchedule() воз-
вращает javax.ejb.ScheduleExpression с информацией о расписании. Метод
getTimeRemaining() возвращает число миллисекунд, оставшихся до срабатыва-
ния таймера. Метод isCalendarTimer() возвращает true , если таймер действует
на основе механизма cron. Наконец, последний метод интерфейса, isPersistent()
возвращает true , если таймер способен пережить перезапуск сервера.

public interface Timer {
  void cancel();
  TimerHandle getHandle();
  Serializable getInfo();
  Date getNextTimeout();
  ScheduleExpression getSchedule();
  long getTimeRemaining();
  boolean isCalendarTimer();
  boolean isPersistent();
}

Что касается поддержки безопасности: метод, вызываемый таймером, действу-
ет вне контекста безопасности. То есть, если вызвать метод getCallerPrincipal ,
он вернет представление неаутентифицированного пользователя. То есть, если в
методе, вызываемом таймером, попытаться обратиться к какому-нибудь защи-
щенному методу, эта попытка потерпит неудачу. Не забывайте, что таймеры могут
создаваться посредством конфигурационных файлов и потому не могут быть свя-
заны с каким-либо пользователем.


7.1.5. Типы таймеров

Существует два типа таймеров , которые поддерживают компоненты EJB: таймеры
задержки и календарные таймеры.

--//--

7.2. Декларативные таймеры

Декларативные таймеры можно создавать, помещая аннотации перед методами
компонентов или включая объявления в конфигурационный файл приложения.

7.2.1. Аннотация @Schedule

Добавление аннотации @Schedule перед методом приводит к созданию декларатив-
ного таймера. Аннотация может использоваться только в компонентах-одиночках,
сеансовых компонентах без сохранения состояния и компонентах, управляемых
сообщениями.


@Target(value=METHOD)
@Retention(value=RUNTIME)
public @interface Schedule {
  String dayOfMonth() default “*”;
  String dayOfWeek() default “*”;
  String hour() default “0”;
  String info() default “”;
  String minute() default “0”;
  String month() default “*”;
  boolean persistent() default true;
  String second() default “0”;
  String timezone() default “”;
  String year() default “*”;
}


Аннотация @Schedule предъявляет к целевому методу те же требования, что и
аннотация @Timeout . Этот метод не должен возвращать значение и может иметь
единственный аргумент – объект javax.ejb.Timer , обсуждавшийся выше. Ниже
приводятся допустимые прототипы целевых методов:

void <METHOD>()
void <METHOD>(Timer timer)

При декларативном подходе для одного метода может быть создано несколь-
ко таймеров. Сделать это можно с помощью аннотации @Schedules . Эта анно-
тация принимает массив аннотаций @Schedule .

7.2.2. Аннотация @Schedules

Аннотация @Schedules используется с целью создания сразу нескольких ка-
лендарных таймеров, для единственного метода и принимает массив аннотаций
@Schedule .

@Target({METHOD})
@Retention(RUNTIME)
public @interface Schedules {
  javax.ejb.Schedule[] value();
}

7.2.3. Параметры аннотации @Schedule

Следует отметить, что по умолчанию таймеры используют настройки часо-
вого пояса сервера. Чтобы задать другой часовой пояс, следует указать атрибут
timezone со значением из IANA Time Zone Database. Допустимые значения хра-
нятся в поле Zone Name. Строковое представление можно также получить с по-
мощью класса java.util.TimeZone .

7.2.4. Пример использования декларативных таймеров

Так как запросить спи-
сок пользователей можно, только обладая привилегиями администратора, что-
бы не возникали исключения, вызванные нарушением прав доступа, компонент
Newsletter будет вызываться с правами администратора. Помните, что методы,
вызываемые таймером, выполняются с привилегиями неаутентифицированно-
го пользователя.


@RunAs(“Admin”) // Метод будет вызываться с привилегиями роли Admin
@Stateless
public class NewsletterBean {

  @PersistenceContext
  private EntityManager em;

  // Рассылка бюллетеня будет выполняться в полночь
  // первого числа каждого месяца
  @Schedule(second=”0”, minute=”0”, hour=”0”, dayOfMonth=”1”, month=”*”, year=”*”)
  public void sendMonthlyNewsletter() {
    ...
  }

  // Аннотация @Schedules может создавать несколько таймеров
  @Schedules({
  // В полдень последнего четверга ноября
  @Schedule(second=”0”, minute=”0”, hour=”12”, dayOfMonth=”Last Thu”, month=”Nov”, year=”*”),
  // В полдень 18 декабря
  @Schedule(second=”0”, minute=”0”, hour=”12”, dayOfMonth=”18”, month=”Dec”, year=”*”)
  })
  // Метод отмечен, как требующий запуска новой транзакции
  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
  public void sendHolidayNewsletter() {
    ...
  }
  ...
}

В этом листинге класс NewsletterBean объявлен, как действующий с приви-
легиями администратора. Это позволяет компоненту извлекать список пользо-
вателей, доступ к которому ограничен по соображениям безопасности. Метод
sendMonthlyNewsletter отмечен аннотацией @Schedule , указывающей, что метод
должен вызываться первого числа каждого месяца. Метод sendHolidayNewsletter
отмечен аннотацией @Schedules , настраивающей его вызов в День благодарения
и на Рождество.


7.2.5. Синтаксис правил в стиле cron

Вы наверняка обратили внимание, что в атрибутах second , minute и hour
аннотации @Schedule передаются строковые, а не целочисленные значения. Это
обусловлено тем, что в атрибутах можно передавать более сложные значения. На-
пример, можно создать таймер, срабатывающий только с понедельника по пятни-
цу каждую вторую неделю.

Атрибуты поддерживают следующие синтаксические формы: единственное зна-
чение, групповой символ, список, диапазон и приращение.


*. Единичные значения
Для некоторых атрибутов существует два пред-
ставления – числовое и текстовое – как в случае с днями недели, где понедельник
может быть представлен как “Mon” или “0” .
атрибуты dayOfMonth и dayOfWeek объединяются по ИЛИ, тогда как
все остальные – по И.

@Schedule(second=”0”, minute=”1”, hour=”23”, dayOfMonth=”1”, month=”Apr”,
dayOfWeek=”Mon”, year=”2015”)


*. Групповой символ
рупповой символ * соответствует всем допустимым значениям для данно-
го атрибута. Групповой символ используется
в ситуациях, когда необходимо указать в атрибуте, что он совпадает со всеми воз-
можными значениями, но не хочется перечислять полный список этих значений.

@Schedule(second=”*”, minute=”*”, hour=”*”, dayOfMonth=”*”, month=”*”,
dayOfWeek=”*”, year=”*”)


*. Список
Список состоит из единичных значений, разделенных запятыми. Список может
содержать повторяющиеся значения – они просто игнорируются. Пробельные
символы между значениями и запятыми также игнорируются. Список не может
содержать групповой символ, вложенные списки или приращения. Но список мо-
жет содержать диапазоны. Например, можно указать диапазоны с понедельника
по вторник и с четверга по пятницу.

@Schedule(second=”0,29”, minute=”0,14,29,59”, hour=”0,5,11,17”,
dayOfMonth=”1,15-31”,year=”2011,2012,2013”)


*. Диапазон
Диапазоны уже демонстрировались в примере со списками. Они позволяют за-
дать множество значений, включая граничные. Диапазон определяется как пара
единичных значений, разделенных дефисом ( - ), где значение, предшествующее
дефису, является начальным значением диапазона, а значение, следующее за де-
фисом, – конечным. Диапазоны не могут содержать групповые символы, списки
или приращения.

@Schedule(hour=”0-11”,dayOfMonth=”15-31”,dayOfWeek=”Mon-Fri”,month=”11-12”,
year=”2010-2020”)

*. Приращения
Приращения позволяют создавать таймеры, срабатывающие в течение фикси-
рованных интервалов. Приращение определяется как пара единичных значений,
разделенных символом косой черты, где первое значение задает начало интервала,
а второе – протяженность интервала. Приращения могут указываться только в
атрибутах second , minute и hour . Они продолжают действовать до достижения
границы в единице измерения уровнем выше – если приращение указано в атри-
буте second , приращение завершится по достижении следующей минуты. То же
относится к минутам и часам. Групповые символы могут указываться перед косой
чертой, но не после нее.

@Schedule(second=”30/10”, minute=”*/20”, hour=”*/6”)

Это выражение определяет таймер, который будет срабатывать каждые 10 се-
кунд после задержки в 30 секунд, через каждые 20 минут, каждый шестой час.
То есть, если создать таймер в полночь, он сработает в 06:20:40, 6:40:30, 12:20:40,
12:40:30, и так далее.

--//--

7.3. Программные таймеры

Итак, специальные таймеры создаются программно. Функционально они очень
близки к декларативным таймерам. Единственное отличие лишь в том, что специ-
альные таймеры создаются программно, во время выполнения, и каждый компо-
нент может иметь не больше одного метода, вызываемого таймером, потому что
только один метод можно отметить аннотацией @Timeout . Как будет показано
далее, существует несколько методов на выбор, с помощью которых можно созда-
вать программные таймеры.

7.3.1. Знакомство с программными таймерами

Специальные таймеры создаются посредством интерфейса javax.ejb.
TimerService . Объект TimerService может быть внедрен с помощью аннотации
@Resource или получен обращением к javax.ejb.SessionContext . Интерфейс
TimerService предоставляет множество разновидностей метода createTimer ,
упрощающих создание таймеров в разных ситуациях. С помощью TimerService
можно создавать таймеры двух типов: интервальные таймеры (или таймеры за-
держки) и календарные.

Кроме ме-
тода getTimers() , все остальные отвечают за создание таймеров. Каждый метод
возвращает объект javax.ejb.Timer . Объект Timer можно использовать для по-
лучения информации о таймере, такой как возможность сохранения, оставшее-
ся время до срабатывания, а также для остановки таймера. Метод getHandle()
возвращает javax.ejb.TimerHandle , поддерживающий сериализацию.


public interface TimerService {

  // Методы создания календарных таймеров
  Timer createCalendarTimer(ScheduleExpression schedule)
    throws IllegalArgumentException, IllegalStateException,
    EJBException;
  Timer createCalendarTimer(ScheduleExpression schedule,
    TimerConfig timerConfig) throws IllegalArgumentException,
    IllegalStateException, EJBException;

  // Методы создания интервальных таймеров EJB 2.1
  Timer createIntervalTimer( Date initialExpiration,
    long intervalDuration, TimerConfig timerConfig ) throws
    IllegalArgumentException, IllegalStateException, EJBException;
  Timer createIntervalTimer( long initialDuration,
    long intervalDuration, TimerConfig timerConfig ) throws
    IllegalArgumentException, IllegalStateException,
    EJBException;
  Timer createTimer( long duration, Serializable info )
    throws IllegalArgumentException, IllegalStateException,
    EJBException;
  Timer createTimer( long initialDuration, long intervalDuration,
    Serializable info ) throws IllegalArgumentException,
    IllegalStateException, EJBException;
  Timer createTimer( Date expiration, Serializable info )
    throws IllegalArgumentException, IllegalStateException,
    EJBException;
  Timer createTimer( Date initialExpiration, long intervalDuration,
    Serializable info ) throws IllegalArgumentException,
    IllegalStateException, EJBException;
  
  // Методы создания таймеров однократного действия
  Timer createSingleActionTimer( Date expiration,
    TimerConfig timerConfig ) throws IllegalArgumentException,
    IllegalStateException, EJBException;
  Timer createSingleActionTimer(long duration, TimerConfig timerConfig)
    throws IllegalArgumentException, IllegalStateException,
    EJBException;
  Collection<Timer> getTimers() throws IllegalStateException, EJBException;
}

При организации планирования с помощью TimerService , компонент должен
иметь специальный метод для вызова таймером, так как таймер создается для те-
кущего компонента, куда внедряется TimerService – нельзя установить таймер
для другого компонента. Для этого один из методов компонента должен быть от-
мечен аннотацией @TimeOut или сам компонент должен реализовать интерфейс
TimedObject .

Таймеры, созданные с помощью TimerService , участвуют в транзакциях. Когда
новый таймер создается в контексте транзакции, таймер останавливается в слу-
чае отката транзакции. Метод, вызываемый таймером, может выполняться в кон-
тексте транзакции. Если транзакция потерпит неудачу, контейнер позаботится об
отмене всех изменений, выполненных методом, и повторно вызовет его.


7.3.2. Пример использования программных таймеров

@Stateless
public class FlyerBean {

  private static final Logger logger = Logger.getLogger(“FlyerBean”);
  
  // Внедрить службу таймеров
  @Resource
  private TimerService timerService;

  public List<Timer> getScheduledFlyers() {
    // Получить список таймеров для этого компонента
    Collection<Timer> timers = timerService.getTimers();
    return new ArrayList<Timer>(timers);
  }

  public void scheduleFlyer(ScheduleExpression se, Email email) {
    // Создать новый объект TimerConfig
    // для включения сообщения электронной почты
    TimerConfig tc = new TimerConfig(email,true);
    // Запланировать рассылку
    Timer timer = timerService.createCalendarTimer(se,tc);
    // Зафиксировать в журнале время расссылки
    logger.info(“Flyer will be sent at: “+ timer.getNextTimeout());
  }

  // Аннотировать метод для вызова таймером
  @Timeout
  public void send(Timer timer) {
    if(timer.getInfo() instanceof Email) {
      // Извлечь рекламное сообщение
      Email email = (Email)timer.getInfo();
      // Извлечь списки покупателей/продавцов и выполнить рассылку
    }
  }
}


Компонент FlyerBean , представленный в этом листинге, отвечает за планиро-
вание рассылки рекламных сообщений и осуществляет рассылку при срабатыва-
нии таймера. Объект TimerService внедряется посредством аннотации. Метод
getScheduledFlyers предназначен для отображения расписания на веб-странице,
чтобы сотрудники коммерческого отдела могли видеть, рассылка каких реклам-
ных сообщений, и на какое время запланирована. Метод scheduleFlyer осу-
ществляет планирование рассылки. Пользовательский интерфейс создает экзем-
пляр ScheduleExpression , который затем передается интерфейсу TimerService .
Экземпляр TimerConfig создается с целью сохранения рекламного сообщения,
а также, чтобы указать, что таймер должен восстанавливаться при перезапуске
сервера. Объект таймера Timer создается обращением к службе TimerService ,
которой передается расписание ScheduleExpression и настройки TimerConfig.
После создания таймера из него можно извлечь информацию о моменте сраба-
тывания. Метод send отмечен аннотацией @TimeOut s, которая указывает, что
данный метод будет вызываться таймером.

Однако в листинге отсутствует один важный фрагмент кода, который конструи-
рует объект ScheduleExpression . Объект ScheduleExpression , как упомина-
лось выше, поддерживает возможность составления цепочек из вызовов методов,
способствуя уменьшению числа строк кода. Ниже показано, как сконструировать
объект расписания для организации рассылки рекламы в день Святого Валентина
непосредственно перед обедом:

ScheduleExpression se = new ScheduleExpression();
se.month(2).dayOfMonth(14).year(2012).hour(11).minute(30); // 2/14/2012 @11:30


7.3.3. Эффективное использование программных
таймеров EJB

программные таймеры универсальны и, в отличие от декларативных таймеров, могут
создаваться и настраиваться во время выполнения, не требуя изменять конфигу-
рационный файл или перекомпилировать приложение. Декларативные таймеры,
в свою очередь, с успехом могут применяться для выполнения операций, извест-
ных на стадии разработки, таких как удаление неактивных учетных записей раз в
месяц.

При использовании программных таймеров важно подумать о том, как они бу-
дут сохраняться контейнером приложения. Повторное развертывание приложе-
ния может уничтожить имеющиеся таймеры. Такое поведение может быть неже-
лательным, если, к примеру, вы просто остановили приложение, чтобы исправить
ошибку. Поэтому очень важно понимать, как обеспечить сохранение таймеров в
моменты перезапуска сервера. Что должно происходить при переносе приложе-
ния на другой сервер? Разработчики серверов приложений уже решили многие из
этих проблем, поэтому вам остается только исследовать свой контейнер и точно
определить, как должно вести себя приложение в разных ситуациях, помимо про-
стого перезапуска сервера.


7.4. В заключение

Как было показано в этой главе, средства планирования в EJB можно разделить
на декларативные и программные. Декларативное планирование осуществляет-
ся путем размещения аннотаций перед методами сеансовых компонентов без со-
хранения состояния, определяющих когда и как часто они должны вызываться.
Программное планирование осуществляется во время выполнения, посредством
объекта javax.ejb.TimerService .

Оба подхода, программный и декларативный,
поддерживают не только интервальные таймеры, перекочевавшие из предыдущих
версий EJB, но и календарные. Выбор типа таймера зависит от решаемой им за-
дачи и зависит от того, известно ли расписание на момент разработки или опре-
деляется во время выполнения.

--//-------------------------------------------------------------------------

# Глава 8.
# Компоненты EJB
# как веб-службы


В этой главе мы займемся исследованием возможности экспортирования компо-
нентов EJB в виде веб-служб SOAP и REST. Веб-службы давно превратились в
промышленный стандарт связи между приложениями (Application-To-Application,
A2A ) и электронной коммерции (Business-To-Business, B2B ). Они составляют ос-
нову разработки программного обеспечения в соответствии с принципами сер-
вис-ориентированной архитектуры (Service-oriented Architecture, SOA), согласно
которому функциональность приложений экспортируется в виде слабосвязанных
служб.

8.1. Что такое «веб-служба»?

Очень непросто дать некое универсальное определение веб-служб, с которым бы
согласились все без исключения. Тем не менее, говоря простым языком, веб-служ-
ба – это стандартная платформа, обеспечивающая возможность взаимодействий
между сетевыми приложениями.

8.1.1. Свойства веб-служб

Когда клиент обращается к веб-службе , в конечном счете происходит вызов мето-
да, который обрабатывает запрос и возвращает ответ. Если рассуждать в терминах
методов Java, параметрами запроса могут быть примитивы Java или объекты. То
же справедливо и для ответа. Как следует из названия, веб-служба – это, в первую
очередь, служба, выполняющая определенные операции, такие как размещение
заказа, проверка состояния заказа, отмена заказа и так далее.

8.1.2. Транспорты

Обычно для обмена сообщениями веб-службы используют протокол HTTP или
HTTPS из-за их вездесущности.

8.1.3. Типы веб-служб

Двумя самыми заметными стандартами реализации веб-служб являются SOAP
и REST. В соответствии со стандартом SOAP, сообщения определяются посредст-
вом языка описания веб-служб (Web Services Description Language, WSDL) и
кодируются в формат XML . Описание на языке WSDL определяет структуру
входящих запросов и исходящих ответов. В соответствии с этим описанием специ-
ализированные инструменты могут генерировать код, вызывающий веб-службу
и обрабатывающий ответ. Такие инструменты существуют практически для всех
языков и платформ.

В технологии передачи репрезентативного состояния (Representational State
Transfer, REST), как и SOAP, используется формат XML и протокол HTTP. Но
веб-службы REST используют совершенно иной, значительно более простой
подход, чем веб-службы SOAP. каждая
веб-служба отображается в один из методов протокола HTTP: GET , PUT , DELETE ,
POST , HEAD и OPTIONS . Эти операции документированы в RFC 2616. Веб-служба,
возвращающая значение и не вносящая никаких изменений в состояние веб-при-
ложения, должна быть реализована как операция GET . Метод PUT используется
для определения операций, сохраняющих данные на сервере, такие как ставка в
приложении ActionBazaar.

8.1.4. Java EE API для веб-служб

Просматривая спецификацию Java EE
или статьи в Интернете, вы неизбежно столкнетесь с такими аббревиатурами, как
JAX-WS (JSR 224) и JAX-RS (JSR 399), которые в Java EE 7 определяют стан-
дартные API для разработки веб-служб на основе технологий SOAP и RESTful,
соответственно.

В дополнение к только что упомянутым технологиям JAX-WS и JAX-RS, мы так-
же затронем JAXB – средство связывания данных XML для Java (Java Architecture
for XML Binding) . Как следует из названия, этот набор инструментов применяется
для преобразования объектов Java в формат XML и обратно. С помощью инстру-
ментария JAXB можно сгенерировать модель данных из схемы XML и затем со-
хранить ее обратно в XML, или аннотировать программный код.

В Java EE 7 впервые появилась встроенная поддержка JSON (JSR 353). JSON –
формат записи объектов JavaScript (JavaScript Object Notation), обеспечиваю-
щий компактное представление данных.

8.1.5. Веб-службы и JSF

   ---

--//--

8.2. Экспортирование компонентов EJB с использованием SOAP (JAX-WS)

8.2.1. Основы SOAP

SOAP – это протокол распределенных взаимодействий, сродни COBRA и Java
RMI. Он позволяет приложениям общаться друг с другом, обмениваясь сообще-
ниями посредством сетевых протоколов, из которых чаще всего используются
HTTP/HTTPS. Обмен осуществляется сообщениями в формате XML. Структура
сообщений определяется с помощью языка WSDL и схемы XML.

*. Структура сообщения SOAP


Сообщения SOAP имеют относительно простую структуру. 
Внешний элемент – это «конверт», содержащий заголовок и тело сообще-
ния. Заголовок может отсутствовать, а его содержи-
мое никак не связано с содержимым тела сообщения.
Заголовки обычно обрабатываются самим веб-серве-
ром. Тело содержит собственно информацию, переда-
ваемую в сообщении – данные в формате XML, пред-
назначенные для обработки веб-службой.


пример сообщения SOAP из приложения ActionBazaar. В этом сообщении
отсутствует заголовок. В сообщение включена информация для протокола
HTTP – как можно видеть, это сообщение должно быть доставлено службе 
по адресу сообщения SOAP /BidService/MakeBid .


<!-- HTTP-заголовок, который обрабатывается веб-сервером и реализацией SOAP -->
POST /BidService/MakeBid HTTP/1.1
Content-type: text/xml;charset=”utf-8”
Soapaction: “”
Accept: text/xml,multipart/related, text/html, image/gif, image/jpeg,
  *; q=.2, */*;q=.2
User-Agen: JAX-WS RI 2.1.6 in JDK 6
Host: localhost:8090
Connection: keep-alive
Content-Length: 230

<!-- XML-сообщение SOAP, обрабатываемое веб-службой -->
<S:Envelop xmlns:S=”http://schemas.xmlsoap.org/soap/envelope/”>
  <S:Body>
    <bid xmlns=”http://com.actionbazaar/bid”>
      <bidPrice></bidPrice>
      <itemId></itemId>
      <bidderId></bidderId>
    </bid>
  </S:Body>
</S:Envelop>


*. Разновидности веб-служб

Существует две основные разновидности веб-служб: RPC-ориентированные
(вызов удаленных процедур) и документо-ориентированные .

Фактически название «документо-ориентированные» означает, что в обмене
со службами участвуют документы. Эту разновидность веб-служб следует ис-
пользовать, если предполагается обмен документами в формате XML, имеющи-
ми стандартный формат или формат, разработанный у вас на предприятии. При
этом вы можете структурировать сообщения как угодно. Название «RPC», напро-
тив, предполагает вызов метода, соответственно данные в формате XML будут
содержать имя метода и набор параметров.

Независимо от разновидности веб-службы, у вас на выбор имеется два вари-
анта представления данных: литеральное и кодированное представление. Для
документо-ориентированной службы предпочтительнее использовать литераль-
ное представление, а для RPC-ориентированной – кодированное.

Преимущество
литеральных документов становится особенно очевидным, когда предполагается,
что веб-служба будет использоваться клиентами, написанными на разных языках
и действующими на разных платформах.

*. Структура WSDL
Файл на языке WSDL составляет основу любой веб-службы SOAP, потому что
содержит полное ее описание. В нем может присутствовать автоматически сгене-
рированный код для сервера и клиента, осуществляющий трансформацию данных
(маршалинг) и фактическую их передачу.

Структура документа WSDL
  - [ Типы ] 
    Контейнер для определения абстрактных типов с использованием 
    XML Schema.

  - [ Сообщения ] 
    Определение абстрактного сообщения, состоящее из отдельных частей

  - [ Операции ] 
    Абстрактное описание операций для конечной точки

  - [ Привязка ]
    Абстрактное определение операции для протоколов
  
  - [ Служба ]
    Коллекция конечных точек; комбинация операций и адресов.

В разделе «Типы», определяются типы данных, составляющих сообщения. Они
определяются с применением языка XML Schema. В разделе «Сообщение» опре-
деляются сообщения, поддерживаемые службой. Каждое сообщение состоит из
одной или нескольких частей, каждая из которых может описывать входные или
входные данные. В разделе «Операции» определяются группы операций (абстрак-
тный интерфейс). Каждая операция должна иметь уникальное имя и включать
комбинацию входных и выходных элементов, и ссылки на элементы сообщений.
Раздел «Привязка» связывает операции (интерфейсы) с фактическими протоко-
лами, такими как SOAP. Раздел «Служба» описывает привязки как службы и оп-
ределяет конечные точки.


*. Стратегии веб-служб
В процессе создания новой веб-службы необходимо написать два артефакта:
файл WSDL с определением службы и класс Java с ее реализацией. Если предпола-
гается обмениваться данными со сложной структурой, также необходимо создать
файл схемы с определением данных и сослаться на него из определения WSDL.
Имея файл WSDL и файл схемы, с помощью специализированных инструментов
можно сгенерировать код для работы с веб-службой. Например, утилита wsimport
генерирует по заданному файлу WSDL весь программный код на языке Java, необ-
ходимый для вызова веб-службы.

Когда имеется реализация на Java, на ее основе с помощью инструментов
JAX-WS можно сгенерировать файл WSDL. Этот подход убережет вас от необхо-
димости вникать в тонкости WSDL и схем XML. Просто отметьте класс аннота-
цией @WebService , добавьте аннотации @WebMethod перед требуемыми методами
и на свет появится новая веб-служба. Однако, несмотря на практическую целе-
сообразность, этот подход имеет несколько недостатков. Во-первых, сгенериро-
ванный код может неожиданно оказаться зависимым от некоторых особенностей
языка Java, таких как Java Generics. Если параметрами метода являются объекты,
то фреймворк привязки данных вынужден будет сгенерировать схему. Сгенери-
рованная схема может оказаться оптимальной, но несовместимой с другими язы-
ками.

Если в качестве отправной точки избрать файл с описанием на языке WSDL,
тогда с помощью встроенных инструментов Java можно сгенерировать реализа-
цию службы для серверной стороны. Такой подход несколько сложнее, так как
требует полного знания языка WSDL. С помощью инструмента wsimport можно
сгенерировать реализацию службы для серверной стороны (впрочем, он способен
также генерировать код для стороны клиента). В результате вы получите интер-
фейсы, и вам останется лишь написать классы, реализующие их. После того, как
интерфейсы будут сгенерированы, вам потребуется обеспечить синхронизацию
этих интерфейсов и реализации.

Третий подход состоит в том, чтобы вручную написать и файл WSDL, и соот-
ветствующий код на языке Java. Этот подход позволяет объединить все самое луч-
шее из двух миров: точное описание WSDL и ясный код Java. При этом устраняют-
ся проблемы, которыми страдают инструменты генерации кода – непереносимое
описание WSDL и неоптимальный код на Java. Однако это самый сложный путь,
так как он требует обеспечить безупречное соответствие между WSDL и кодом на
Java.

Все три решения требуют использования фреймворка связывания данных.
В большинстве окружений, по умолчанию роль такого фреймворка играет JAXB
(JSR 222). Он отвечает за преобразование данных в формате XML в объекты Java,
которые затем будут передаваться службе.

8.2.2. Когда следует использовать службы SOAP

В сравнении с подходами к реализации прикладной функциональности в дру-
гих системах, стек Java EE 7 предоставляет выбор из нескольких совершенно раз-
ных технологий, включая SOAP. Экспортировать прикладные службы можно так-
же посредством веб-служб Java RMI, JMS и RESTful. Каждая из этих технологий
имеет свои достоинства и компромиссы, в зависимости от ваших требований.

Самой первой технологией экспортирования прикладных служб на языке Java
была Java Remote Method Invocation (RMI). Она сделала возможным появление
EJB и по умолчанию поддерживается для всех компонентов. Java RMI оптималь-
но подходит для ситуаций, когда клиентами являются приложения на Java. Техно-
логия RMI менее требовательна к вычислительным ресурсам в сравнении с SOAP.
Но она непригодна, когда необходимо обеспечить доступность служб для прило-
жений, написанных на других языках, так как не является кроссплатформенной.

Веб-службы можно также экспортировать посредством JMS. Многие разработ-
чики едва ли заметят сходство JMS и SOAP, тем не менее, обе технологии осно-
ваны на обмене сообщениями. Механизмы обмена сообщениями имеют длинную
историю развития, намного более длинную, чем веб-службы. JMS реализует асин-
хронную передачу сообщений с хранением в промежуточной очереди, тогда как
SOAP предполагает синхронные взаимодействия. Технология SOAP имеет четко
очерченный интерфейс, благодаря чему есть возможность использовать инстру-
менты, автоматического создания клиентского программного кода. Такое немыс-
лимо при использовании JMS, зато эта технология лучше подходит для интегра-
ции двух систем, когда не требуется, чтобы одна система предоставляла внешний
интерфейс другой системе.

Следует также отметить, что веб-службы на основе SOAP, в отличие от служб
на основе Java RMI или JMS, легко доступны через корпоративные брандмауэры.
Сообщения SOAP обычно передаются с использованием вездесущих протоколов
HTTP/HTTPS.


8.2.3. Когда следует экспортировать компоненты EJB в виде веб-служб SOAP

Механизм JAX-WS позволяет экспортировать в виде веб-служб обычные классы Java
(POJO), а также сеансовые компоненты EJB без сохранения состояния или компо-
ненты-одиночки. Если сравнить исходный код веб-служб на основе POJO и веб-служб
на основе компонентов EJB, вы не найдете существенных отличий. Веб-службы на
основе компонентов EJB будут включать дополнительную аннотацию @Stateless /
@Singleton и, возможно, другие аннотации или особенности EJB, с которыми мы уже
знакомы, такие как использование службы таймеров или транзакции. Обе разновид-
ности веб-служб – на основе POJO и EJB – поддерживают внедрение зависимостей и
события жизненного цикла, такие как @PostConstruct и @PreDestroy , но, экспорти-
руя компоненты EJB, вы получаете ряд важных преимуществ.

Во-первых, веб-службы на основе компонентов EJB автоматически получают
возможности декларативного управления транзакциями и безопасностью, доступ-
ные только для компонентов EJB. Эти две крупные особенности дают компонен-
там EJB огромную фору перед обычными объектами POJO. Кроме того, без каких-
либо дополнительных усилий вы можете использовать интерцепторы и службу
таймеров.
Во-вторых, и самое важное, веб-службы на основе компонентов EJB дают воз-
можность без лишних усилий и дублирования кода экспортировать прикладную
логику. Экспортирование веб-службы EJB ничем не отличается от экспортирова-
ния компонента EJB посредством RMI – достаточно просто заменить аннотацию
@Remote на аннотацию @WebService . Кроме того, компоненты EJB можно одно-
временно экспортировать с применением обеих технологий.


8.2.4. Веб-служба SOAP для ActionBazaar

****----**** 
Дальше пошло не понимание, мало информации о том что такое SOAP в EJB.
Поэтому решено погуглить и разобраться с оснавными понятиями.

WSDL - (англ. Web Services Description Language) — язык описания веб-сервисов 
и доступа к ним, основанный на языке XML.

Каждый документ WSDL 1.1 можно разбить на следующие логические части:

    1) определение типов данных (types) — определение вида отправляемых и 
       получаемых сервисом XML-сообщений
    2) элементы данных (message) — сообщения, используемые web-сервисом
    3) абстрактные операции (portType) — список операций, которые могут 
       быть выполнены с сообщениями
    4) связывание сервисов (binding) — способ, которым сообщение будет доставлено


--- структура WSDL

<definitions>
   <types>
      definition of types........
   </types>

   <message>
      definition of a message....
   </message>

   <portType>
      <operation>
         definition of a operation.......  
      </operation>
   </portType>

   <binding>
      definition of a binding....
   </binding>

   <service>
      definition of a service....
   </service>
</definitions>


--- пример !!!
--- Предположим , служба предоставляет единую общедоступную функцию, 
--- которая называется sayHello . Эта функция ожидает один параметр 
--- строки и возвращает одну строку приветствия. Например, если вы 
--- передаете параметр world , то сервисная функция sayHello возвращает 
--- приветствие, "Hello, world!" , 


<definitions name="HelloService"
   targetNamespace="http://www.examples.com/wsdl/HelloService.wsdl"
   xmlns="http://schemas.xmlsoap.org/wsdl/"
   xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
   xmlns:tns="http://www.examples.com/wsdl/HelloService.wsdl"
   xmlns:xsd="http://www.w3.org/2001/XMLSchema">
 
   <message name="SayHelloRequest">
      <part name="firstName" type="xsd:string"/>
   </message>
  
   <message name="SayHelloResponse">
      <part name="greeting" type="xsd:string"/>
   </message>

   <portType name="Hello_PortType">
      <operation name="sayHello">
         <input message="tns:SayHelloRequest"/>
         <output message="tns:SayHelloResponse"/>
      </operation>
   </portType>

   <binding name="Hello_Binding" type="tns:Hello_PortType">
      <soap:binding style="rpc"
         transport="http://schemas.xmlsoap.org/soap/http"/>
      <operation name="sayHello">
         <soap:operation soapAction="sayHello"/>
         <input>
            <soap:body
               encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
               namespace="urn:examples:helloservice"
               use="encoded"/>
         </input>
    
         <output>
            <soap:body
               encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
               namespace="urn:examples:helloservice"
               use="encoded"/>
         </output>
      </operation>
   </binding>

   <service name="Hello_Service">
      <documentation>WSDL File for HelloService</documentation>
      <port binding="tns:Hello_Binding" name="Hello_Port">
         <soap:address
            location="http://www.examples.com/SayHello/" />
      </port>
   </service>
</definitions>


---- разбираем пример

*. WSDL <definition> Element
<definitions> элемент должен быть корневым элементом всех WSDL документов. 
Он определяет имя веб-службы.
    представляет собой контейнер из всех других элементов.

    указывает , что этот документ называется HelloService .

    определяет targetNamespace атрибут. targetNamespace пространство является 
    условностью XML - схемы , которая позволяет документ WSDL ссылаться на себя. 
    В этом примере мы определили targetNamespace из 
    http://www.examples.com/wsdl/HelloService.wsdl

    определяет пространство имен по умолчанию: XMLNS = HTTP: 
    //schemas.xmlsoap.org/wsdl/. Все элементы без префикса пространства имен, 
    таких как message или portType , поэтому считаются частью пространства 
    имен по умолчанию WSDL.

    определяет множество имен, которые используются на протяжении 
    оставшейся части документа. 


*. WSDL <definition> Element
 Веб-сервис должен определить свои входы и выходы, и как они отображаются 
 в и из услуг. WSDL <types> элемент ухаживает определения типов данных, 
 которые используются веб - службы. Типы являются XML-документы или 
 части документов.

    Типы элемент описывает все типы данных, используемых между клиентом и
    сервером.

    WSDL не привязан исключительно к конкретной системе печати.

    WSDL использует спецификацию W3C XML Schema в качестве своего выбора 
    по умолчанию для определения типов данных.

    Если служба использует только XML - схемы встроенный в простых типов, 
    таких как строки и целые числа, то types элементов не требуется.

    WSDL позволяет типы должны быть определены в отдельных элементов, 
    так что типы могут быть использованы повторно с несколькими веб-сервисов. 


<types>
   <schema targetNamespace="http://example.com/stockquote.xsd"
      xmlns="http://www.w3.org/2000/10/XMLSchema">
    
      <element name="TradePriceRequest">
         <complexType>
            <all>
               <element name="tickerSymbol" type="string"/>
            </all>
         </complexType>
      </element>
    
      <element name="TradePrice">
         <complexType>
            <all>
               <element name="price" type="float"/>
            </all>
         </complexType>
      </element>
    
   </schema>
</types>


*. WSDL <message> Element
     <message> элемент описывает данные , которыми обмениваются между 
     поставщиками веб - услуг и потребителей.

    Каждый веб-служба имеет два сообщения: вход и выход.

    Вход описывает параметры для веб-службы, а выход описывает 
    возвращаемые данные из веб-службы.

    Каждое сообщение содержит ноль или более <part> параметров, по 
    одному для каждого параметра функции веб - службы.

    Каждый <part> ассоциатов параметров с конкретным типом , определенным 
    в <types> элементе контейнер. 


Здесь определены два элемента сообщения. Первый представляет собой 
сообщение с запросом на SayHelloRequest , а второй представляет собой 
сообщение ответа SayHelloResponse . 

<message name="SayHelloRequest">
   <part name="firstName" type="xsd:string"/>
</message>

<message name="SayHelloResponse">
   <part name="greeting" type="xsd:string"/>
</message>


*. WSDL <portType> Element
<portType> элемент сочетает в себе несколько элементов сообщения , 
чтобы сформировать полный одностороннюю или операцию туда-обратно.
Например, <portType> можно комбинировать один запрос и одно ответное 
сообщение в одной операции запроса / ответа.

<portType name="Hello_PortType">
   <operation name="sayHello">
      <input message="tns:SayHelloRequest"/>
      <output message="tns:SayHelloResponse"/>
   </operation>
</portType>

    Элемент PortType определяет одну операцию, которая называется sayHello .
    Операция состоит из входного сообщения одного SayHelloRequest и
    Выход сообщение SayHelloResponse . 

Порядок описания [ input, output ] имеет значение

1) [ Ответ на запрос ] Служба принимает сообщение и отправляет ответ.
<wsdl:definitions .... >
   <wsdl:portType .... > *
      <wsdl:operation name="nmtoken" parameterOrder="nmtokens">
         <wsdl:input name="nmtoken"? message="qname"/>
         <wsdl:output name="nmtoken"? message="qname"/>
         <wsdl:fault name="nmtoken" message="qname"/>*
      </wsdl:operation>
   </wsdl:portType >
</wsdl:definitions>

2) [ Запрашивать-ответ ] Служба посылает сообщение и получает ответ. 
<wsdl:definitions .... >
   <wsdl:portType .... > *
      <wsdl:operation name="nmtoken" parameterOrder="nmtokens">
         <wsdl:output name="nmtoken"? message="qname"/>
         <wsdl:input name="nmtoken"? message="qname"/>
         <wsdl:fault name="nmtoken" message="qname"/>*
      </wsdl:operation>
   </wsdl:portType >
</wsdl:definitions>

3) [ В одну сторону ]
<wsdl:definitions .... > 
   <wsdl:portType .... > *
      <wsdl:operation name="nmtoken">
         <wsdl:input name="nmtoken"? message="qname"/>
      </wsdl:operation>
   </wsdl:portType >
</wsdl:definitions>

4) [ уведомление  ]
<wsdl:definitions .... >
   <wsdl:portType .... > *
      <wsdl:operation name="nmtoken">
         <wsdl:output name="nmtoken"? message="qname"/>
      </wsdl:operation>
   </wsdl:portType >
</wsdl:definitions>


*. WSDL <binding> Element
<binding> элемент обеспечивает конкретную информацию о том , как 
portType операция будет фактически передается по проводам.

    Крепления могут быть доступны через несколько транспортов, 
    включая HTTP GET, HTTP POST или SOAP.

    Привязки предоставить конкретную информацию о том , что протокол 
    используется для передачи portType операций.

    Привязки предоставить информацию, где находится служба.

    Для протокола SOAP, связывание является <soap:binding> , а также 
    транспорт SOAP сообщений поверх протокола HTTP.

    Можно указать несколько привязок для одного portType . 

Связывание элемент имеет два атрибута: name и type атрибута. 
[  <binding name="Hello_Binding" type="tns:Hello_PortType">  ]


*. WSDL <ports> Element
<port> элемент определяет индивидуальную конечную точку, указав один 
адрес для привязки.

<wsdl:definitions .... >
   <wsdl:service .... > *
      <wsdl:port name="nmtoken" binding="qname"> *
         <-- extensibility element (1) -->
      </wsdl:port>
   </wsdl:service>
</wsdl:definitions>

    Элемент порт имеет два атрибута: name и binding .

    name атрибут обеспечивает уникальное имя среди всех портов , 
    определенных в документе вшита WSDL.

    binding атрибут относится к связыванию с использованием связывающих 
    правил , определенных WSDL.

    Связующие элементы растяжимости используются для указания информации 
    об адресе для порта.

    Порт не должен указывать более одного адреса.

    Порт НЕ ДОЛЖНЫ указать любую информацию о связывании, кроме адресной
    информации. 


*. WSDL <service> Element
 <service> элемент определяет порты , поддерживаемые службой Wweb. 
 Для каждого из поддерживаемых протоколов, есть один порт элемент. 
 Сервисный элемент представляет собой набор портов.

    Клиенты веб-служб можно узнать следующее из элемента службы:
        где получить доступ к службе,
        через какой порт для доступа к веб-службы, и
        как определяются информационные сообщения. 

    Элемент службы включает в документации элемент для обеспечения 
    читаемого человека документации. 


****----****


Рассмотрим два примера, демонстрирующих порядок экспортирования компо-
нентов EJB в виде веб-служб. С их помощью мы покажем два разных подхода к
созданию веб-служб. Первый пример демонстрирует возможность автоматичес-
кого создания файла WSDL контейнером. А во втором примере мы расскажем, как
написать файл WSDL и файл схемы JAXB, как на их основе сгенерировать ком-
поненты и как написать код, реализующий полученные интерфейсы.


*. Служба PlaceBid
В первом примере мы экспортируем в виде веб-службы компонент PlaceBid .
С ее помощью клиенты, написанные на других языках программирования, смогут
отправлять ставки. Данный компонент EJB будет экспортироваться как RPC-ко-
дированная веб-служба SOAP. Файл WSDL будет генерироваться во время вы-
полнения автоматически, с помощью механизма JAX-RS.


@WebService                               // Экспортирует веб-службу
@SOAPBinding(style=SOAPBinding.Style.RPC, // Определяет параметры
use=SOAPBinding.Use.ENCODED)              // связывания
public interface PlaceBidWS {
public long submitBid(long userId, long itemId, double bidPrice);
}


@Stateless
// Определяет конечную точку
@WebService(endpointInterface = “com.actionbazaar.ws.PlaceBidWS”)
public class PlaceBid implements PlaceBidWS{

  @Override
  // Этот метод экспортируется
  public long submitBid(long userId, long itemId, double bidPrice) {
    ...
  }

  // Этот метод не экспортируется
  public List<Bid> getBids() {
    ...
  }
}


Аннотация @WebService в этом листинге определяет интерфейс экспорти-
руемой веб-службы. Вслед за ней определяются параметры связывания конечной
точки с протоколом SOAP: с применением кодирования RPC. Реализация клас-
са тоже отмечена аннотацией @WebService , со ссылкой endpointInterface , ука-
зывающей на интерфейс веб-службы; компонент также реализует этот интер-
фейс. Далее следует реализация экспортируемого метода. Обратите внимание,
что метод getBids не экспортируется, потому что он отсутствует в определении
интерфейса.


*. Служба UserService
В этом примере мы экспортируем новый метод createUser сеансового компо-
нента UserService . Но на этот раз мы начнем не с объектов Java, а с файлов WSDL
и XSD.

Существующий метод createUser компонента UserService принимает объект
com.actionbazaar.account.User . Это абстрактный объект. Он наследует классы
Bidder , Employee и SellerI , а также ссылается на другие объекты. Инструмен-
ты автоматического создания кода для такого сложного объекта могут добавить в
описание WSDL нежелательные зависимости, которые сделают его несовмести-
мым с другими языками программирования.
Чтобы избежать этих проблем, новый метод createUser компонента
UserService будет использовать объект передачи данных (Data Transfer Object,
DTO). Объект передачи данных – это упрощенная версия прикладного объек-
та, созданная специально для передачи данных. Так как такие объекты передачи
данных не имеют сложной иерархии наследования, инструментам автоматизации
проще справляться с ними. В данном случае мы начнем с создания схемы XSD с
определением объекта UserDTO.

-- Это файл [ UserDTO.xsd ]

<?xml version=”1.0” encoding=”UTF-8”?>
<xs:schema
  version=”1.0”
  targetNamespace=”http://com.actionbazaar/user”
  xmlns:xs=”http://www.w3.org/2001/XMLSchema”
  xmlns:tns=”http://com.actionbazaar/user”
  elementFormDefault=”qualified”>
  <xs:element name=”user” type=”tns:UserDTO”/>
  <xs:element name=”createUserResponse” type=”tns:CreateUserResponse”/>
  <xs:complexType name=”UserDTO”>
    <xs:sequence>
      <xs:element id=”firstName” name=”firstName” type=”xs:string”
        minOccurs=”1” maxOccurs=”1” nillable=”false”/>
      <xs:element id=”lastName” name=”lastName” type=”xs:string”
        minOccurs=”1” maxOccurs=”1” nillable=”false”/>
      <xs:element id=”birthDate” name=”birthDate” type=”xs:date”
        minOccurs=”1” maxOccurs=”1” nillable=”false”/>
      <xs:element id=”username” name=”username” type=”xs:string”
        minOccurs=”1” maxOccurs=”1” nillable=”false”/>
      <xs:element id=”password” name=”password” type=”xs:string”
        minOccurs=”1” maxOccurs=”1” nillable=”false”/>
      <xs:element id=”email” name=”email” type=”xs:string”
        minOccurs=”1” maxOccurs=”1” nillable=”false”/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name=”CreateUserResponse”>
    <xs:sequence>
      <xs:element name=”userId” type=”xs:integer”/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>


Кроме описания объекта UserDTO схема включает также описание объект
CreateUserResponse . Этот объект используется для передачи идентификатора
пользователя обратно, клиентскому коду, чтобы его можно было использовать при
последующих обращениях к службе.

Теперь, когда у нас имеется готовая схема, можно воспользоваться генератором
JAXB, входящего в библиотеку JDK, и с его помощью превратить схему в настоя-
щие объекты Java:

xjc -d <базовый_каталог>/ActionBazaar-ejb/src/main/java/ -p
com.actionbazaar.ws.dto UserDTO.xsd

После создания объектов Java можно перейти к формированию файла WSDL
для веб-службы. Наш файл WSDL представлен в листинге 8.4. Его следует со-
хранить в каталоге META-INF/wsdl. Так как описание WSDL содержит ссыл-
ки на файл UserDTO.xsd, последний следует сохранить в том же каталоге. Файл
UserService.wsdl определяет одну службу, createUser , которую еще предстоит ре-
ализовать.


-- Это файл [ UserService.wsdl ]


<?xml version=”1.0” encoding=”UTF-8”?>
<definitions
xmlns:soap=”http://schemas.xmlsoap.org/wsdl/soap/”
xmlns:xsd=”http://www.w3.org/2001/XMLSchema”
xmlns:tns=”http://com.actionbazaar/user”
xmlns=”http://schemas.xmlsoap.org/wsdl/”
targetNamespace=”http://com.actionbazaar/user”
name=”UserService” xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”>

  <types>
    <xsd:schema>
      <!-- Импортирует схему с определением объектов -->
      <xsd:import namespace=”http://com.actionbazaar/user” schemaLocation=”UserDTO.xsd”/>
    </xsd:schema>
  </types>

  <message name=”createUserRequest”>
    <!-- UserDTO -->
    <part name=”user” element=”tns:user”/>
  </message>

  <message name=”createUserResponse”>
    <!-- ResponseDTO -->
    <part name=”response” element=”tns:createUserResponse”/>
  </message>

  <portType name=”CreateUser”>
    <operation name=”createUser”>
      <input message=”tns:createUserRequest”/>
      <output message=”tns:createUserResponse”/>
    </operation>
  </portType>

  <binding name=”UserPortBinding” type=”tns:CreateUser”>
    <soap:binding transport=”http://schemas.xmlsoap.org/soap/http”
      style=”document”/>
    <operation name=”createUser”>
      <soap:operation soapAction=””/>
      <input>
        <soap:body use=”literal”/>
      </input>
      <output>
        <soap:body use=”literal”/>
      </output>
    </operation>
  </binding>

  <!-- Экспортирует UserService -->
  <service name=”UserService”>
    <port name=”UserPort” binding=”tns:UserPortBinding”>
    <soap:address
      location=”http://localhost:8080/UserService/CreateUser”/>
    </port>
  </service>

</definitions>


На основе этого документа WSDL можно автоматически сгенерировать код для ис-
пользования на стороне клиента.

Дальше приводится реализация веб-службы, соответствующая документу 
WSDL из листинга

@WebService(
  name=”CreateUser”,
  serviceName=”UserService”,
  targetNamespace=”http://com.actionbazaar/user”,
  portName = “UserPort”,
  wsdlLocation= “UserService.wsdl”)
@SOAPBinding(style=SOAPBinding.Style.DOCUMENT)
public interface UserServiceWS {
  @WebMethod(operationName=”createUser”)
  @SOAPBinding(style=SOAPBinding.Style.DOCUMENT,
    use=SOAPBinding.Use.LITERAL,
    parameterStyle = SOAPBinding.ParameterStyle.BARE)
  public @WebResult(name=”response”,
    targetNamespace=”http://com.actionbazaar/user”)
  CreateUserResponse
  createUser(
    @WebParam(name=”user”, mode= WebParam.Mode.IN,
      targetNamespace=”http://com.actionbazaar/user”)
    UserDTO user);
  }

@Stateless(name=”UserService”)
@WebService(endpointInterface = “com.actionbazaar.ws.UserServiceWS”)
public class UserServiceBean implements UserService, UserServiceWS {
  ...
  @Override
  public CreateUserResponse createUser(UserDTO user) {
    ...
  }
}


Код в этом листинге реализует веб-службу, соответствующую документу
WSDL. Теперь реализация получилась намного сложнее, чем в
первом примере. Нам потребовалось с помощью аннотаций отобразить параметр
и возвращаемое значение в сущности, которые определены в схеме. Кроме того,
нам потребовалось отобразить метод в соответствующий элемент WSDL.

*. Генерирование клиентского кода
Сгенерировать клиентский код на Java для взаимодействия с этой службой можно с
помощью команды wsimport. Эта команда генерирует все классы, описанные в фай-
ле UserDTO.xsd, наряду с заготовками методов, вызывая которые можно обращаться к
веб-службе. Благодаря этой особенности, команду wsimport удобно использовать для
быстрого тестирования создаваемых служб.


8.2.5. Аннотации JAX-WS

Теперь, после знакомства с простым примером реализации веб-службы на осно-
ве SOAP в приложении ActionBazaar, мы займемся более детальным изучением
аннотаций.

Чтобы создать и запустить веб-службу SOAPнеобходимо добавить, как мини-
мум, следующие две аннотации:
 - @javax.jws.WebService – отмечает интерфейс или класс веб-службы;
 -  @javax.jws.soap.SOAPBinding – определяет разновидность (документ/
RPC) и необходимость кодирования (документ, кодированный/литераль-
ный).
С помощью этих двух аннотаций можно создавать простейшие веб-службы
SOAP.


*. Аннотация @WebService
Аннотация @WebService применяется к классам или интерфейсам компонен-
тов. Когда она применяется к классу компонента, контейнер EJB автоматически
генерирует интерфейс. Если интерфейс уже имеется, аннотацию @WebService
можно применить к интерфейсу и класс компонента получит следующие методы:

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface WebService {
  String name() default “”;
  String targetNamespace() default “”;
  String serviceName() default “”;
  String portName() default “”;
  String wsdlLocation() default “”;
  String endpointInterface() default “”;
}

*. Аннотация @WebMethod
Аннотация @javax.jws.WebMethod применяется к методам, которые должны
экспортироваться как веб-службы. По умолчанию экспортируются все методы
класса, поэтому данную аннотацию можно использовать, чтобы сделать метод не-
доступным или изменить свойства экспортируемого метода, такие как имя опера-
ции или действие SOAP.

@ Retention(RetentionPolicy.RUNTIME)
@ Target({ElementType.METHOD})
public @interface WebMethod {
  String operationName() default “”;
  String action() default “”;
  boolean exclude() default false;
}

Параметры operationName и action аннотации @WebMethod определяют имя
операции и действие SOAP, соответственно.

@WebMethod(operationName = “addNewBid”, action = http://actionbazaar.com/NewBid)
public Long addBid(...) {
  ...
}

Параметр operationName отражается на сгенерированном описании WSDL,
как показано ниже:

<portType name=”PlaceBidBean”>
  <operation name = “addNewBid”>
  ...
  </operation>
</portType>

Обратите внимание, что метод с фактическим именем addBid экспортируется
в веб-службе под именем addNewBid . Этот прием можно использовать для отоб-
ражения контракта службы в фактическую реализацию. Даже если с течением
времени реализация изменится, контракт останется неизменным. Если параметр
operationName не указан, по умолчанию его значением становится фактическое
имя метода в реализации. Этот же прием может пригодиться в ситуациях, когда
файл WSDL создается отдельно и по каким-то причинам невозможно экспорти-
ровать метод под его фактическим именем.

Аналогично параметр action используется для создания элемента SOAPAction
в файле WSDL:

<operation name =”addNewBid”>
  <soap:operation soapAction = “http://actionbazaar.com/NewBid”/>
</operation>

Элемент SOAPAction определяет содержимое элемента header в HTTP-запросе
с сообщением. Клиенты используют его при взаимодействии с веб-службой SOAP
по протоколу HTTP. По значению поля SOAPAction заголовка конечная точка оп-
ределяет истинного получателя сообщения, что избавляет ее от необходимости
выуживать эту информацию из тела сообщения SOAP.


*. Аннотация @WebParam
Аннотация @javax.jws.WebParam применяется с целью настройки параметра
сообщения в генерируемом документе WSDL.

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface WebParam {
  String name() default “”;
  String partName() default “”;
  String targetNamespace() default “”;
  Mode mode() default Mode.IN;
  boolean header() default false;
  static final enum Mode {
    public static final IN,
    public static final OUT,
    public static final INOUT;
  }
}


Следующий фрагмент демонстрирует порядок использования аннотации, где
видно, что параметры можно использовать для передачи данных в веб-службу,
возврата результатов из нее или для того и другого одновременно:

@WebMethod
public Long addBid(
 @WebParam(name=”user”, mode= WebParam.Mode.IN) String userId) {
    ...
  }
  ...
}


Свойство name определяет имя параметра для сообщения в WSDL. Если имя не
указано, по умолчанию используется фактическое имя аргумента.
Свойство targetNamespace определяет пространство имен XML для сообще-
ния. Если свойство targetNamespace не указано, сервер будет использовать про-
странство имен веб-службы.
Свойство mode определяет направление параметра и может принимать одно из
трех значений: IN , OUT и INOUT . Оно указывает направление передачи данных: в
параметре типа IN передаются входные данные для службы, в параметре типа OUT
возвращаются результаты и в параметре типа INOUT данные передаются в обоих
направлениях. Параметр типа INOUT действует подобно указателю в C++, пере-
дача которого дает методу возможность вернуть более чем один результат. Если
в свойстве mode указано значение OUT или INOUT , сам параметр должен иметь тип
javax.xml.ws.Holder <T> .


Свойство header определяет, откуда должны извлекаться параметры – из тела
сообщения или из заголовка. Значение true в этом свойстве означает, что пара-
метры должны извлекаться из заголовка. Эта настройка применяется в ситуациях,
когда сообщение SOAP подвергается промежуточной обработке перед передачей,
такой как маршрутизация между серверами. Промежуточные обработчики иссле-
дуют только содержимое заголовка. Значение true в свойстве header генерирует
следующий код WSDL:

<operation name = “addNewBid”>
  <soap:operation soapAction=”urn:NewBid”/>
  <input>
    <soap:header message=”tns:PlaceBid_addNewBid” part=”user” use=”literal”/>
    <soap:body use=”literal” parts=”parameters”/>
  </input>
</operation>

Свойство partName управляет созданием элемента name в wsdl:part или эле-
ментом схемы XML параметра, если для веб-службы выбран тип связывания RPC
или, если выбран тип связывания document с параметром BARE .


*. Аннотация @WebResult
Аннотация @WebResult очень похожа на аннотацию @WebParam . Она применя-
ется совместно с аннотацией @WebMethod и определяет имя значения, возвращае-
мого в ответ на сообщение, в WSDL, как показано ниже:

@WebMethod
@WebResult(name=”bidNumber”
public Long addBid(...) {}

Определение аннотации @WebResult практически полностью повторяет опре-
деление аннотации @WebParam , кроме свойства mode :

@Retention(value = RetentionPolicy.RUNTIME)
@Target(value = {ElementType.METHOD})
public @interface WebResult {
  public String name() default “”;
  public String partName() default “”;
  public String targetNamespace() default “”;
  public boolean header() default false;
}

Как можно догадаться, свойство name определяет имя возвращаемого значения
в WSDL. Свойство targetNamespace определяет пространство имен XML для
возвращаемого значения. Эти свойства имеют смысл для документо-ориентиро-
ванных веб-служб, где возвращаемые значения связываются с определенным про-
странством имен XML.
Если свойство header установлено в значение true , возвращаемое значение
будет включено в заголовок. Как и в аннотации @WebParam , свойство partName
используется, чтобы определить имя возвращаемого значения.


*. Аннотации @OneWay и @HandlerChain
В спецификации метаданных веб-служб определены еще две аннотации:
@OneWay и @HandlerChain . Мы дадим здесь лишь краткое описание, так как под-
робное обсуждение этих аннотаций далеко выходит за рамки книги.
Аннотация @OneWay используется для определения веб-служб, не имеющих
возвращаемого значения. То есть, когда метод имеет тип void . Например:

@WebMethod
@OneWay
public void pingServer() {
  ...
}

В данном случае метод pingServer ничего не возвращает. Аннотация @OneWay
оптимизирует сообщение, отражая факт отсутствия возвращаемого значения.

Аннотация @HandlerChain используется для определения набора обработчи-
ков, которые должны вызываться в ответ на сообщение SOAP. С логической точки
зрения, обработчики похожи на интерцепторы EJB. Обработчики могут быть двух
типов:
 - логические обработчики ( @javax.xml.ws.handler.LogicalHandler ),
   оперирующие свойствами контекста сообщения и данными в теле сообще-
   ния;
 - обработчики протокола ( @javax.xml.ws.handler.soap.SOAPHandler ),
   оперирующие свойствами контекста сообщения и сообщениями, характер-
   ными для протокола.

8.2.6. Эффективное использование веб-служб SOAP в EJB

Если предполагается предоставлять услуги третьим сторонам, тогда SOAP
является хорошим выбором. Но если услуги предоставляются внутренним Java-
системам, RMI и JMS выглядят предпочтительнее.

--//--

8.3. Экспортирование компонентов EJB с использованием REST (JAX-RS)

веб-службы RESTful основаны на использовании базовых операций
HTTP – DELETE , GET , HEAD , OPTIONS , POST и PUT – и URI. Таким образом, основу
CRUD-функциональности составляют операции HTTP. Телом сообщений для
этих служб может быть все, что угодно – XML, графика, текст и так далее. В отли-
чие от технологии SOAP, где операция определяется содержимым сообщения, для
обращения к веб-службам RESTful используются уникальные адреса URL. Пара-
метры передаются в виде запросов.


8.3.1. Основы REST

*. Отладка обращений к веб-службам
При разработке веб-служб часто бывает необходимо отладить сообщения, участвую-
щие в обмене. Перехватывать запросы и ответы можно с помощью дополнительных инс-
трументов, таких как tcpmon.

Запрос, описанный выше, использует метод GET . Для каждого HTTP-запроса к
серверу должен быть выбран один из восьми методов. Метод определяет порядок
обработки запроса и операцию, которую сервер должен выполнить. Мы сосредо-
точимся только на шести методах, потому что другие два – TRACE и CONNECT – не
имеют отношения к веб-службам RESTful. Вот эти методы:

  GET     – операция чтения, которая не изменяет данных, хранящихся на 
            сервере.
  DELETE  – удаляет указанный ресурс. Многократное выполнение этой опе-
            рации не вызывает никакого эффекта. После удаления ресурса 
            все последующие попытки удалить его просто игнорируются.
  POST    – изменяет данные на сервере. Запрос может включать или не вклю-
            чать данные, которые требуется сохранить, а ответ на него может 
            содержать или не содержать возвращаемые данные.
  PUT     – сохраняет на сервере данные, переданные в теле запроса, с 
            идентификатором ресурса, указанном в URL. Многократное 
            выполнение этой операции не вызывает никакого эффекта, 
            потому что при этом обновляется один и тот же ресурс.
  HEAD    – возвращает только код ответа и заголовки, связанные с запросом.
  OPTIONS – запрос на получение информации о доступных вариантах взаи-
             модействий в цепочке запрос/ответ для указанного URI.


8.3.2. Когда следует использовать REST/JAX-RS

  ---

8.3.3. Когда следует экспортировать компоненты
EJB в виде веб-служб REST

Так как веб-службы RESTful не имеют хранимого состояния, комбинация REST
и EJB имеет смысл только в контексте сеансовых компонентов EJB без сохранения
состояния. Компоненты с сохранением состояния и компоненты, управляемые со-
общениями, несовместимы с природой REST и такая комбинация теряет всякий
смысл. Компоненты-одиночки можно экспортировать в виде веб-служб REST, но
такие службы не будут иметь высокой производительности из-за того, что только
один компонент сможет обрабатывать запросы. В итоге, роль веб-служб REST мо-
гут играть только сеансовые компоненты без сохранения состояния.


8.3.4. Веб-служба REST для ActionBazaar

Учитывая быстрое распространение смартфонов, таких как iPhone,
есть смысл экспортировать ряд основных услуг приложения ActionBazaar в виде
веб-служб RESTful, чтобы упростить создание клиентов для этих устройств. При-
менение технологии SOAP могло бы потребовать значительных вычислительных
ресурсов и большого объема трафика. Хотя смартфоны вполне пригодны для об-
работки запросов SOAP, реализация RESTful все же больше подходит для них.
Чтобы начать процесс разработки, необходимо сформулировать идентификато-
ры URI для основных операций в BidService :
 - вернуть список ставок, сделанных указанным пользователем в указанной
   категории за указанный диапазон дат:
   /bidService/list/{userId}/{category}?startDate=x&endDate=x
 - добавить новую ставку и принять XML в качестве входных данных:
   /bidService/addBid
 - вернуть экземпляр ставки в формате XML или JSON:
   /bidService/getBid/{bidId}
 - отменить ставку с указанным идентификатором:
   /bidService/cancel/{bidId}


// Отмечает класс, как содержащий веб-службу RESTful;
// параметр аннотации – путь к корню службы
@Local @Path(“/bidService”)
public interface BidServiceRS {

  @POST                        // Вызывается HTTP-методом POST
  @Path(“/addBid”)             // Полный путь: /bidService/addBid
  @Consumes(“application/xml”) // Объект Bid поступает в формате XML
  public void addBid(Bid bid);

  @GET                         // Вызывается HTTP-методом GET
  @Path(“/getBid/{bidId}”)
  @Produces({“application/json”,application/xml”})   // Возвращает JSON или XML
  public Bid getBid(@PathParam(“bidId”) long bidId); // bidId – параметр метода

  @DELETE                      // Вызывается HTTP-методом DELETE
  @Path(“delete/{bidId}”)
  public void cancelBid(@PathParam(“bidId”) long bidId);

  @GET
  @Produces(“text/plain”)
  @Path(“/list/{userId}/{category}”)
  public String listBids(
      @PathParam(“category”)String category,
      @PathParam(“userId”)long userId,
      @QueryParam(“startDate”) String startDate, // Извлекаются из
      @QueryParam(“endDate”) String endDate);    // параметров запроса
}


Один метод в этом листинге получает объект Bid в формате XML и один воз-
вращает его в этом формате. Фактически экземпляр Bid – это объект DTO, было
бы крайне нежелательно, чтобы преобразование применялось также к ссылкам на
Item и Bidder . За преобразование отвечает фреймворк JAXB. Так как класс Bid
является чрезвычайно простым DTO, мы вручную добавили аннотации JAXB –
объект не генерируется на основе схемы XML, как это обычно делается.


@XmlRootElement(name=”Bid”) // Корневой элемент XML-документа
// Сериализовать все нестатические, нетранзитивные поля
@XmlAccessorType(XmlAccessType.FIELD)
public class Bid {

  @XmlElement   // Сериализовать в отдельный элемент
  // Использовать кроссплатформенный объект Date, совместимый с .NET
  private XMLGregorianCalendar bidDate;

  @XmlAttribute        // Сериализовать в атрибут корневого элемента
  private Long bidId; 

  @XmlElement
  private double bidPrice;

  @XmlElement
  private long itemId;

  @XmlElement
  private long bidderId;

  public Bid() {
  }
  
  // Методы доступа к полям объекта не показаны
}


Пример вывода Bid DTO в формате XML


<Bid bidId=”10”>
  <bidDate>2012-05-15T20:01:35.088-04:00</bidDate>
  <bidPrice>10.0</bidPrice>
  <itemId>45</itemId>
  <bidderId>77</bidderId>
</Bid>


Если при обращении к методу getBid клиент сообщит, что желает получить
результат в формате JSON, веб-служба вернет данные в виде строки JSON

{
  “@bidId”:”10”,
  “bidDate”:”2012-05-15T21:52:58.771-04:00”,
  “bidPrice”:”10.0”,
  “itemId”:”45”,
  “bidderId”:”77”
}

Если попытаться выполнить этот код, реализация JAX-RS почти наверняка
сообщит, что не знает, как создать экземпляр интерфейса BidServiceRS . Чтобы
связать сеансовый компонент без сохранения состояния со службой, необходимо
реализовать javax.ws.rs.core.Application и вернуть экземпляры всех интер-
фейсов, отмеченных аннотациями JAX-RS.


public class SystemInit extends Application {
  public Set<Class<?>> getClasses() {
    return Collections.emptySet();
  }

  public Set<Object> getSingletons() {
    Set<Object> classes = new HashSet<Object>();
    try {
        InitialContext ctx = new InitialContext();
        Object bidServiceRS =
          ctx.lookup(“java:global/WebServiceExperiment/BidService”);
        classes.add(bidServiceRS);
        } catch (Throwable t) {
            t.printStackTrace();
        }
        return classes;
  }
}


8.3.5. Аннотации JAX-RS

Веб-службы RESTful намного проще в реализации, чем веб-службы SOAP.
Чтобы создать веб-службу RESTful, достаточно применить следующие аннота-
ции:
 - @javax.ws.rs.Path – эта аннотация должна присутствовать перед клас-
   сом, реализующим веб-службу RESTful;
 - @javax.ws.rs.GET/POST/PUT/DELETE – эти аннотации должны помещать-
   ся перед методами. Они определяют реализации обработчиков запросов
   для разных HTTP-методов и не имеют параметров .

Чтобы определить простейшую действующую веб-службу RESTful, достаточно
применить аннотацию @Path к классу и аннотации, определяющие HTTP-методы,
к методам класса.


*. Аннотация @GET
Аннотация @javax.ws.rs.GET является аннотацией-меткой, определяющей
метод веб-службы, который должен вызываться в ответ на запрос HTTP GET.
Ниже приводится определение аннотации GET :

@Target(value = {ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
@HttpMethod(value = “GET”)
public @interface GET {}


*. Аннотация @POST
Аннотация @javax.ws.rs.POST является аннотацией-меткой, определяющей
метод веб-службы, который должен вызываться в ответ на запрос HTTP POST.
Ниже приводится определение аннотации POST :

@Target(value = {ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
@HttpMethod(value = “POST”)
public @interface POST {}

В одном запросе
POST можно передавать несколько вложений, если объявить его как включаю-
щий составные MIME-данные; смотрите для примера аннотацию @Consumes .


*. Аннотация @DELETE
ннотация @javax.ws.rs.DELETE является аннотацией-меткой, определяющей
метод веб-службы, который должен вызываться в ответ на запрос HTTP DELETE.
Ресурс, идентифицируемый строкой URI, должен быть удален, при этом все по-
следующие операции с тем же идентификатором ресурса не должны производить
никакого эффекта, так как ресурс уже удален. Ниже приводится определение ан-
нотации DELETE :

@Target(value = {ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
@HttpMethod(value = “DELETE”)
public @interface DELETE {}


*. Аннотация @PATH
Аннотация @javax.ws.rs.Path помещается перед классом и перед методами.
Когда она помещается перед классом, она объявляет класс службой JAX-RS. Класс,
экспортируемый как веб-служба RESTful, обязательно должен быть отмечен этой
аннотацией. Когда аннотация помещается перед методом, этот метод экспортиру-
ется как веб-служба RESTful.

Параметр аннотации @Path определяет относительный URI службы. Иденти-
фикатор URI, указанный в аннотации перед методом, объединяется с URI в анно-
тации перед классом и определяет полный путь к веб-службе RESTful. Аннотация
определена, как показано ниже:

@Target(value = {ElementType.TYPE, ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Path {
  public String value();
}

Параметры запроса связываются с параметрами метода с помощью аннотации @java.
ws.rs.PathParam , которая описывается далее. Фигурных скобок с аннотациями
может быть столько, сколько потребуется.


*. Аннотация @PathParam
Аннотация @javax.ws.rs.PathParam отображает параметры, указанные в
@javax.ws.rs.Path , в фактические параметры Java-метода. Механизм JAX-RS
автоматически будет выполнять преобразование типов при вызове методов. Ниже
приводится определение аннотации:

@Target(value = {ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface PathParam {
  public String value();
}

Взгляните на следующий пример, где показано, как объявить метод веб-служ-
бы, принимающий два параметра, userId и category :

@GET
@Path(“/list/{userId}/{category}”)
public List<Item> listBids( 
    @PathParam(“category”)String category,
    @PathParam(“userId”)long userId
 ) {
  ...
}

В этом примере параметры URI запроса, category и userID , отображаются в
фактические параметры метода. Если предположить, что класс отмечен аннотацией
@Path(“/bidService”) , тогда строка вызова метода будет выглядеть примерно так:

http://localhost:8080/actionbazaar/bidService/list/14235/cars


*. Аннотация @QueryParam
Аннотация @javax.ws.rs.QueryParam позволяет извлекать параметры запроса
и отображать их в фактические параметры метода. Эта аннотация определена, как
показано ниже:

@Target(value = {ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface QueryParam {
  public String value();
}


Следующий фрагмент демонстрирует применение аннотации:


@Path(“/bidService”)
@Stateless(name=”BidService”)
public class BidServiceBean {
  @GET @Produces(“text/plain”)
  @Path(“/list/{userId}/{category}”)
  public String listBids(
    @PathParam(“category”)String category,
    @PathParam(“userId”)long userId,
    @QueryParam(“startDate”) String startDate,
    @QueryParam(“endDate”) String endDate
  ) {
  ...
  }
}

Эту службу можно вызвать из веб-браузера, введя следующую строку 
URL: http://localhost:8080/wse/bidService/list/3232/cars?startDate=10252012&
endDate=10302012 . Параметры запроса, например startDate и endDate , будут
отображены в одноименные параметры метода.


*. Аннотация @Produces
Аннотация @javax.ws.rs.Produces определяет типы данных многоцеле-
вых расширений электронной почты Интернета (Multipurpose Internet Mail
Extensions, MIME), которые службы могут возвращать клиентам. Клиенту может
возвращаться один или более типов. Типы, поддерживаемые клиентом, служба
должна определить по заголовкам запроса. Ниже приводится определение анно-
тации:

@Inherited
@Target(value = {ElementType.TYPE, ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Produces {
    public String[] value() default {“*/*”};
}

Следующий пример демонстрирует применение этой аннотации к методу, кото-
рый может возвращать данные в формате XML или JSON, в зависимости от тре-
бований клиента:

@GET
@Path(“/getBid/{bidId}”)
@Produces({“application/json”,”application/xml”})
public Bid getBid(@PathParam(“bidId”) long bidId) {
  ...
}


В число часто используемых MIME-типов, которые могут возвращаться мето-
дами веб-служб, входят:
 - application/xml – XML;
 - application/json – текст в формате JSON;
 -  text/plain – простой текст;
 - text/html – разметка HTML;
 - application/octet-stream – произвольные двоичные данные;


*. Аннотация @Consumes
ннотация @javax.ws.rs.Consumes похожа на аннотацию @Produces . Единст-
венное различие в том, что данная аннотация определяет MIME-тип, принимае-
мый службой. Эта аннотация используется, когда метод может принимать данные
разных типов. Она определена, как показано ниже:

@Inherited
@Target(value = {ElementType.TYPE, ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Consumes {
  public String[] value() default {“*/*”};
}

  Следующий пример демонстрирует применение аннотации:

@POST @Path(“/addBid”)
@Consumes(“application/xml”)
public void addBid(Bid bid) {
  ...
}

Этот метод принимает объект Bid в формате XML. Преобразование документа
XML в экземпляр com.actionbazaar.dto.Bid реализация JAX-RS выполняет с
помощью фреймворка JAXB.


8.3.6. Эффективное использованиевеб-служб REST в EJB

Прежде всего следует стремиться сохранить веб-службы RESTful максимально
простыми. Под веб-службами RESTful в первую очередь подразумевается легко-
весность. Признаком простоты может служить возможность вызова веб-службы из
браузера. Если для вызова веб-службы необходим дополнительный код, вероятно,
такую службу лучше реализовать с применением технологии SOAP.

--//--

8.4. Выбор между SOAP и REST

  ---

8.5. В заключение

  ---

--//--

--//-------------------------------------------------------------------------

# Глава 9.
# Сущности JPA


Java Persistence API (JPA) – это стандартный прикладной интерфейс Java, позво-
ляющий создавать, извлекать, изменять и удалять данные в реляционных базах
данных. Возможность взаимодействий с базами данных в языке Java имелась прак-
тически с самых первых дней его существования. JDBC API дает разработчикам
прямой доступ к базе данных и возможность выполнять запросы SQL. Но, несмот-
ря на все свои преимущества, интерфейс JDBC оказался слишком прост – в нем
отсутствуют многие необходимые возможности. Вследствие этого поверх JDBC
было разработано множество сторонних инструментов объектно-реляционного
отображения (Object-Relational Mapping, ORM). Интерфейс JPA является стан-
дартом объектно-реляционного отображения для платформ Java SE и Java EE.
С точки зрения разработчика это означает возможность создания приложений баз
данных без использования сторонних классов.


9.1. Введение в JPA

JPA – это стандартное решение задачи, известной как объектно-реляционное отоб-
ражение. Выражаясь простым языком, объектно-реляционное отображение – это
транслятор (переводчик). Представьте двух человек, ведущих беседу. Один гово-
рит на английском, а другой – на французском языке. Им нужен третий человек,
переводчик, который знает оба языка. Объектно-реляционное отображение как
раз и есть такой переводчик, знающий язык базы данных и язык предметной мо-
дели вашего приложения на Java. В данном случае роль переводчика будет играть
JPA. Он отвечает за передачу данных в обе стороны между базой данных и пред-
метной моделью на Java.

9.1.1. Несоответствие интерфейсов

Под термином несоответствие интерфейсов (impedance mismatch) подразумева-
ются различия между объектно-ориентированной и реляционной парадигмами, и
сложности, которые несут эти различия. Чаще всего проблема несоответствия ин-
терфейсов возникает на уровне хранения, где находится предметная модель. Ко-
рень проблемы заключается в отличии фундаментальных целей двух технологий.

Когда полю объекта Java присваивается другой объект, обычно копируется толь-
ко ссылка (указатель), а не сам объект. Иными словами, доступ к объектам в языке
Java осуществляется по ссылке, а не по значению. Если бы это было невозможно,
вам, вероятно, потребовалось бы сохранять идентичность присваиваемого объек-
та (например, в переменной типа int ) и разыменовывать ее при необходимости.
С другой стороны, в реляционных базах данных отсутствует понятие доступа к
объектам по ссылке. Реляционные базы данных практически всегда используют
идентичности. Эти идентичности указывают, где находится фактический объект,
и запросы к базе данных используют эти идентичности для поиска требуемых дан-
ных.

Кроме того, язык Java предлагает такую роскошь, как наследование и полимор-
физм, отсутствующие в реляционном мире. Наконец, объекты Java включают и
данные (переменные экземпляра), и поведение (методы). Таблицы баз данных,
напротив, хранят только данные в строках и столбцах, и не обладают поведенчес-
кими характеристиками.

9.1.2. Взаимосвязь между EJB 3 и JPA

 ---

--//--

9.2. Предметное моделирование

Зачастую первым этапом разработки промышленных приложений является со-
здание предметной модели (domain model). То есть, составление списка сущностей
предметной области и определение отношений между ними.

9.2.1. Введение в предметное моделирование

Предметная модель – это концептуальное представление задачи, решаемой при-
ложением. Предметная модель состоит из объектов Java, представляющих данные
приложения и отношения, или связи, между данными. Данные могут представ-
лять нечто фактически существующее, например заказчика, или что-то более эфе-
мерное, как, например, предпочтения заказчика.

9.2.2. Предметная модель приложения ActionBazaar

основными в приложении ActionBazaar являются следующие действия:

 - продавец размещает объявление на сервере ActionBazaar;
 - объявления организуются в категории, удобные для поиска и просмотра;
 - покупатели делают ставки;
 - высшая ставка выигрывает.

Чтобы определить объекты предметной области, достаточно просмотреть этот
список и выделить имена существительные: продавец, объявление, категория, по-
купатель, ставка и заказ. Наша цель – выявить объекты предметной области, или
сущности, которые необходимо хранить в базе данных.

- Продавец
- Товар
- Категория
- Покупатель
- Заказ
- Ставка

Теперь, когда имеется модель объектов, необходимо обозначить, как они взаимо-
действуют друг с другом. Для этого достаточно нарисовать стрелки между объек-
тами, показывающие связи между ними (эти стрелки отражают отношения между
объектами) и модель закончена.


*. Объекты предметной области в виде классов Java
Теперь перейдем к исследованию кода, использующего JPA. Но перед этим пос-
мотрим на самые обычный объект Java, представляющий относительно сложный
объект предметной области, Category . Определение класса Category приводится
в листинге 9.1. Как можно заметить – это самый обычный POJO, без каких-либо
аннотаций JPA. Обычно так начинается реализация предметной модели. POJO –
это только кандидат на превращение в сущность, хранимую в базе данных.


package com.actionbazaar.listing01;
import java.sql.Date;

// Класс Category – обычный POJO
public class Category {

  // Атрибут id уникально идентифицирует экземпляр Category
  protected Long id;

  // Следующие два атрибуты хранят сведения о категории
  protected String name;
  protected Date modificationDate;

  // Следующие три атрибуты определяют
  // отношения категории с другими объектами
  protected Set<Item> items;
  protected Category parentCategory;
  protected Set<Category> subCategories;

  // Конструктор без аргументов
  public Category() { }

  public Long getId() {
    return this.id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public String getName() {
    return this.name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Date getModificationDate() {
    return this.modificationDate;
  }

  public void setModificationDate(Date modificationDate) {
    this.modificationDate = modificationDate;
  }

  public Set<Item> getItems() {
    return this.items;
  }

  public void setItems(Set<Item> items) {
    this.items = items;
  }

  public Set<Category> getSubCategories() {
    return this.subCategories;
  }

  public void setSubCategories(Set<Category> subCategories) {
    this.subCategories = subCategories;
  }

  public Category getParentCategory() {
    return this.parentCategory;
  }

  public void setParentCategory(Category parentCategory) {
    this.parentCategory = parentCategory;
  }
}


Класс Category имеет несколько защищенных ( protected ) переменных экзем-
пляра, для каждой из которых имеются методы чтения и записи, соответствую-
щие соглашениям об именовании, принятым в JavaBeans. Свойства, кроме name и
modificationDate , играют особую роль в предметном моделировании. Свойство
id используется для хранения уникального номера, идентифицирующего кате-
горию. Свойство items хранит все товары, относящиеся к данной категории, и
представляет отношение «многие ко многим» между элементами и категориями.
Свойство parentCategory представляет самоссылочное (self-referential) отноше-
ние «многие к одному» между родительской и дочерней категориями. Свойство
subCategories представляет отношение «один ко многим» между категорией и
подкатегориями.


9.3. Реализация объектов предметной области с помощью JPA

В первую очередь мы познакомимся с аннотацией
@Entity , превращающей любой POJO в сущность, управляемую механизмом JPA.
Затем мы расскажем вам об отличиях полей и свойств с точки зрения хранения
данных и об идентичности сущностей. В заключение мы обсудим встроенные объ-
екты.

9.3.1. Аннотация @Entity

ннотация @Entity отмечает простой объект POJO предметной области как сущ-
ность, управляемую механизмом JPA. Ее можно считать своеобразным аналогом
аннотаций @Stateless , @Stateful и @MessageDriven . Ниже показано, как пре-
вратить класс Category в сущность:

@Entity
public class Category {
  //...
  public Category() { /**/ }
  public Category(String name) { /**/ }
  //...
}

Вот и все! Благодаря аннотации @Entity , JPA теперь будет знать, что это – сущ-
ность, которая будет участвовать во взаимодействиях с базой данных. Как видно
из этого фрагмента, все неабстрактные сущности должны иметь либо общедоступ-
ный ( public ), либо защищенный ( protected ) конструктор без аргументов. Этот
конструктор будет использоваться механизмом JPA для создания новых экземп-
ляров сущностей – вам никогда не придется создавать эти экземпляры вручную
при получении данных средствами JPA.


9.3.2. Определение таблиц

Данные предметной модели хранятся в множестве таблиц в базе данных. Некото-
рые сущности легко отображаются в единственную таблицу. Более сложные сущ-
ности могут храниться в двух и более таблицах.
Важно помнить, что ведя речь о работе с несколькими таблицами, в данном
случае мы подразумеваем данные для единственной сущности, хранящиеся в не-
скольких таблицах. Возьмем в качестве примера таблицу пользователей. В одной
таблице может храниться основная информация о пользователях, а картинки, свя-
занные с пользователями, – в другой. Это пример того, как данные о пользовате-
лях могут храниться в нескольких таблицах. Именно об этом мы и будем говорить
в данном разделе.


*. Отображение сущности в единственную таблицу

Аннотация @Table определяет таблицу, в столбцы которой отображается сущ-
ность. Параметр name является наиболее важным. По умолчанию все сохраняемые
данные из сущности отображаются в таблицу с именем, указанным в параметре
name аннотации. Как видно из определения аннотации, она имеет еще ряд пара-
метров:

@Target(TYPE)
@Retention(RUNTIME)
public @interface Table {
  String name() default “”;
  String catalog() default “”;
  String schema() default “”;
  Index[] indexes() default {};
  UniqueConstraint[] uniqueConstraints() default {};
}

Параметры catalog и schema предусмотрены на тот случай, если потребуется
определить местоположение таблицы в базе данных.
Но примера ради предположим, что таблица ITEM_CATEGORY находится в схе-
ме ACTIONBAZAAR . В этом случае схему можно было бы указать, как показано
ниже:

@Table(name=”ITEM_CATEGORY”, schema=”ACTIONBAZAAR”))
public class Category

Параметр uniqueConstraints также используется достаточно редко. Кроме
того, нет никаких гарантий, что он будет использоваться вашей реализацией JPA.
Большинство реализаций поддерживают весьма дружественную для разработчика
особенность, известную как автоматическое создание схемы, когда реализация ав-
томатически создает для сущностей отсутствующие объекты базы данных. Это по-
ведение не обозначено в спецификации JPA и в разных реализациях настраивается
по-разному.

С помощью аннотации @Table можно определить только одну таблицу. Но в
реляционных базах данных информация часто хранится в нескольких таблицах.
Далее мы посмотрим, как с помощью аннотаций @SecondaryTable определить две
или более таблиц.


*. Отображение сущности в множество таблиц

Аннотации @SecondaryTables (во множественном числе) и @SecondaryTable
(в единственном числе) позволяют определять сущности, которые должны хра-
ниться в двух или более таблицах.

Аннотация @SecondaryTable , определение которой приводится ниже, поз-
воляет получать данные для сущности более чем из одной таблицы:

@Target({ TYPE })
@Retention(RUNTIME)
public @interface SecondaryTable {
  String name();
  String catalog() default “”;
  String schema() default “”;
  PrimaryKeyJoinColumn[] pkJoinColumns() default {};
  UniqueConstraint[] uniqueConstraints() default {};
}

Обратите внимание, что за исключением элемента pkJoinColumns , опре-
деление этой аннотации идентично определению аннотации @Table . Элемент
pkJoinColumns является ключевой особенностью данной аннотации.

@Entity
@Table(name=”USERS”)
@SecondaryTable(name=”USER_PICTURES”,pkJoinColumns=@PrimaryKeyJoinColumn(name=”USER_ID”))
public class User

Параметр pkJoinColumns=@PrimaryKeyJoinColumn(name=”USER_ID”) сооб-
щает JPA, что столбец USER_PICTURES.USER_ID является внешним ключом, свя-
занным с одноименным столбцом, являющимся первичным ключом в таблице
USERS (о настройке первичного ключа в таблице USERS рассказывается в следую-
щем разделе, в описании аннотации @Id ). Для извлечения сущности User из двух
таблиц JPA будет использовать операцию соединения. В этом примере участвуют
только две таблицы. Если потребуется организовать хранение сущностей более
чем в двух таблицах, можно воспользоваться аннотацией @SecondaryTables (во
множественном числе).


9.3.3. Отображение свойств в столбцы

Отображение свойства хранимого
объекта в столбец таблицы осуществляется с помощью аннотации @Column .

*. Аннотация @Column

@Entity
@Table(name=”USERS”)
public class User {
  // Свойство userId отображается в столбец USER_ID
  @Column(name=”USER_ID”)
  String userId;

  // Свойство username отображается в столбец USER_NAME
  @Column(name=”USER_NAME”)
  String username;

  // Свойство email отображается в столбец EMAIL,
  // поэтому нет необходимости использовать аннотацию @Column
  String email;

  //...Другие методы доступа опущены для краткости
  //   Методы доступа к свойству email
  //   с именами, соответствующими соглашениям для JavaBean
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }
}

В этом листинге демонстрируется использование аннотации @Column для опре-
деления правил отображения свойств в столбцы таблицы USERS . Например, для
свойства userId предполагается, что в таблице USERS имеется столбец USER_ID , в
котором будет храниться значение свойства userId. Аналогично определяется
отображение свойства username – JPA будет сохранять значение этого свойства в
столбце USER_NAME таблицы USERS.


*. Атрибуты аннотации @Column

@Target ({ METHOD, FIELD })
@Retention(RUNTIME)
public @interface Column {
  String name() default “”;
  boolean unique() default false;
  boolean nullable() default true;
  boolean insertable() default true;
  boolean updatable() default true;
  String columnDefinition() default “”;
  String table() default “”;
  int length() default 255;
  int precision() default 0;
  int scale() default 0;
}

Если атрибуту insertable присвоить значение
false , JPA не будет включать свойство объекта Java в SQL-инструкцию INSERT
при сохранении новых данных. Аналогично, если атрибуту updatable присвоить
значение false , JPA не будет включать свойство в SQL-инструкцию UPDATE при
обновлении хранящихся данных.


*. Доступ к данным на основе полей и свойств

Интерфейс JPA дает определенную свободу размещения аннотации @Column .
Наиболее очевидный выбор – перед переменными экземпляров. Такой способ на-
зывается доступом к данным на основе полей, например:

@Column(name=”USER_ID”)
private Long id;

Когда аннотация размещается перед полем, механизм JPA напрямую обращает-
ся к приватной переменной. Это может быть допустимо, если объект предметной
области является простым компонентом с методами доступа, не выполняющими
никаких промежуточных операций с данными. Другой вариант – размещение ан-
нотаций перед методами чтения (аннотации перед методами записи игнорируют-
ся). Такой способ называется доступом к данным на основе свойств, например:

@Column(name=”USER_ID”)
  public Long getId() { return id; }
  public Long setId(Long id) {
  this.id = (id <= 0) ? 0 : id;
}

Если метод чтения
и/или метод записи содержит некоторую прикладную логику, следует использо-
вать способ доступа к данным на основе свойств, чтобы механизм JPA использовал
методы чтения и записи вместо прямого доступа к приватной переменной.


В версии JPA 1.0 во всех трех
объектах ( User , Seller , Bidder ) можно было использовать доступ к данным либо
только на основе полей, либо только на основе свойств. Положение дел измени-
лось в версии JPA 2.0, с появлением аннотации @Access .
Сначала с помощью аннотации @Access на уровне класса необходимо опре-
делить тип доступа по умолчанию для всей сущности. Тип доступа может быть
определен как AccessType.FIELD или AccessType.PROPERTY . Ниже приводится
пример настройки типа доступа FIELD для сущности User :

@Entity
@Access(FIELD)
public class User { ... }

Теперь можно определить сущность Seller с некоторыми особенностями:

@Entity
@Access(FIELD)
public class Seller extends User {
  //...остальная часть определения класса опущена для краткости

  @Transient
  private double creditWorth;
 
  @Column(name=”CREDIT_WORTH”)
  @Access(AccessType.PROPERTY)
  public double getCreditWorth() { return creditWorth; }
  public void setCreditWorth(double cw) {
    creditWorth = (cw <= 0) ? 50.0 : cw;
  }
}

Обратите внимание, что с помощью аннотации @Access для всего класса Seller
установлен способ доступа к данным FIELD . Но в нем дополнительно используют-
ся аннотации @Transient и @Access , определяющие доступ к creditWorth , как к
свойству. То есть, доступ ко всем данным в Seller будет осуществляться прямым
обращением к полям, кроме creditWorth . Когда требуется выполнить подобное
переопределение, всегда следует использовать пару аннотаций, @Transient и
@Access . Это предотвратит попытку механизма JPA отобразить creditWorth
дважды.

В предыдущем примере для класса Seller установлен способ доступа к дан-
ным на основе полей и для поля creditWorth отдельно установлен способ досту-
па как к свойству. Однако легко можно определить и противоположное поведе-
ние.


*. Определение переходных полей

имеется аннотация @Transient , которая сообщает, что отмеченное ею свойство
должно игнорироваться. Если свойство отмечено аннотацией @Transient , JPA не
будет пытаться извлекать, вставлять или обновлять соответствующее значение в
базе данных.


9.3.4. Типы представления времени

Типы представления времени используются для представления дат и времени су-
ток. Большинство баз данных поддерживает несколько разных типов представле-
ния времени с разной степенью точности, таких как DATE (хранит день, месяц и
год), TIME (хранит только время суток, но не хранит день, месяц и год) и TIMESTAMP
(хранит день, месяц, год и время суток). Аннотация @Temporal помогает указать,
какой из этих типов следует использовать.

Для примера представьте, что требуется сохранить дату записи данных в базу
без времени суток. Реализовать это можно любым из следующих способов:

@Temporal(TemporalType.DATE)
protected java.util.Date creationDate;

@Temporal(TemporalType.DATE)
protected java.util.Calendar creationDate;

// Без аннотации
protected javax.sql.Date creationDate;


9.3.5. Перечисления

Взгляните еще раз на рис. 9.4 и представьте, что модель данных включает пере-
числение с типами пользователей приложения. Определение этого перечисления
может выглядеть так:

public enum UserType { SELLER, BIDDER, CSR, ADMIN }

Так как в реляционной базе данных отсутствует понятие объекта или иерархии
типов, используя это перечисление можно организовать хранение в таблице ин-
формации о типе пользователя. В реляционных базах данных также отсутствует
понятие перечислений ( enum ), поэтому UserType нужно преобразовать в что-то
более понятное базе данных. В этом вам поможет аннотация @Enumerated.

@Enumerated(EnumType.STRING)
protected UserType userType1;

@Enumerated(EnumType.ORDINAL)
protected UserType userType2;

Каждый элемент перечисления имеет строковое представление. Так, значение
UserType.SELLER будет представлено строкой SELLER , UserType.BIDDER – стро-
кой BIDDER , и так далее. Соответственно, значение свойства, отмеченного аннота-
цией @Enumerated(EnumType.STRING) , будет сохраняться в базе данных в строко-
вом представлении.
Кроме того, каждый элемент перечисления имеет числовой индекс. Так, для пе-
речисления, объявленного выше, значению UserType.SELLER соответствует ин-
декс 0, значение которого можно получить обращением к перечислению по индексу:
UserType.values()[0]; . Аналогично, значению UserType.BIDDER соответствует
индекс 1, значению UserType.CSR – индекс 2, и так далее. Соответственно, значе-
ние свойства, отмеченного аннотацией @Enumerated(EnumType.ORDINAL) , будет
сохраняться в базе данных в числовом (порядковом) представлении.


9.3.6. Коллекции

Определение сущности User со списком телефонных номеров
@Entity
@Table(name=”USERS”)
public class User {
  private Collection<String> telephoneNumbers;
  //...
}

В этом листинге имеется коллекция объектов String , предназначенных для хра-
нения номеров телефонов. Теперь нужно сообщить механизму JPA, как он должен
извлекать эти данные из базы. В этом нам поможет аннотация @ElementCollection .
Для отображения коллекций простых (таких как java.lang.String , java.util.
Integer , и так далее) или встраиваемых типов (подробнее о встраиваемых типах
рассказывается в описании аннотации @EmbeddedId , в разделе 9.3.7) в JPA 2.0
была реализована аннотация @ElementCollection .


@Entity
@Table(name=”USERS”)
public class User {

  // Используется для определения коллекций
  @ElementCollection  
  // Имя таблицы для хранения коллекции можно переопределить,
  // если имя по умолчанию не подходит
  // Имя столбца в таблице для хранения коллекции так же
  // можно переопределить, если имя по умолчанию не подходит  
  @CollectionTable(name=”PHONE_NUMBERS”, joinColumns=@JoinColumn(name=”USER_ID”))
  @Column(name=”NUMBER”)
  private Collection<String> telephoneNumbers;

  //...

}

Аннотация @ElementCollection определяет таблицу для хранения коллекции
в базе данных и используется в сущностях для обозначения свойств-коллекций.
Таблицы, предназначенные для хранения коллекций, это самые обычные таблицы
в базе данных. Имена таких таблиц по умолчанию конструируются из имен сущ-
ностей и свойств. В соответствии с определением в листинге 9.6, таблица получила
бы имя по умолчанию USER_TELEPHONENUMBER , но в аннотации @CollectionTable
явно указано, что таблица должна иметь имя “PHONE_NUMBERS”. В качестве имени
столбца в таблице коллекции по умолчанию выбирается имя свойства. В данном
случае столбец получил бы имя по умолчанию TELEPHONENUMBER . Но в аннотации
@Column явно указано, что столбец должен иметь имя “NUMBER”. И, наконец, атри-
бут joinColumns сообщает, что столбец PHONE_NUMBERS.USER_ID играет роль вне-
шнего ключа, ссылающегося на первичный ключ таблицы USERS .

имейте в виду, что аннотация @ElementCollection может также работать со
встраиваемыми объектами.

@Embeddable
public class Address {
  @Column(name=”HOME_STREET”)
  private String street;
  @Column(name=”HOME_CITY”)
  private String city;
  @Column(name=”HOME_STATE”)
  private String state;
  @Column(name=”HOME_ZIP”)
  private String zipCode;
}

Сущность User может включать свойство, представляющее коллекцию объек-
тов Address :

@Entity
@Table(name=”USERS”)
public class User {
  @ElementCollection
  @CollectionTable(name=”HOMES”)
  private Set<Address> shippingAddresses;
}

При работе с коллекциями особую важность приобретают первичные ключи
в базе данных. Именно с помощью первичных ключей формируются отношения
между таблицами. Используя эти отношения, механизм JPA автоматически извле-
кает необходимые данные из других таблиц в свойства-коллекции.


9.3.7. Определение идентичности сущностей

Под словами «определение идентичности сущностей» в действительности под-
разумевается настройка идентификации первичных ключей. Все таблицы в базе
данных должны поддерживать возможность уникальной идентификации строк,
чтобы при необходимости изменить данные, изменениям подверглась только одна
строка, а остальные оставались нетронутыми. Аналогично, когда механизм JPA из-
влекает данные из базы данных и преобразует их в объекты предметной модели,
ему необходим некоторой способ уникальной идентификации объектов, находя-
щихся в памяти. Для этого требуется определить, какие столбцы таблиц играют
роль первичных ключей. Решить эту задачу можно тремя способами:
 - с помощью аннотации @Id ;
 - с помощью аннотации @IdClass ;
 - с помощью аннотации @EmbeddedId .


*. Аннотация @Id

Когда первичный ключ таблицы состоит из единственного столбца, можно вос-
пользоваться аннотацией @Id . Вернемся к определению объекта Category из лис-
тинга 9.1 и предположим, что свойство id хранит значение столбца первичного
ключа таблицы CATEGORY . В этом случае достаточно просто отметить это свойство
аннотацией @Id , чтобы сообщить JPA, что это значение можно использовать для
уникальной идентификации объектов Category .

*. Аннотация @IdClassАннотация @IdClass

Первый способ определения первичных ключей из нескольких столбцов реали-
зован в виде аннотации @IdClass . Эту аннотацию можно применить к нескольким
свойствам объекта, в паре с аннотацией @Id (столбцам в таблице, составляющим
первичный ключ) и затем определить класс, следующий шаблону компаратора и
определяющий порядок сравнения нескольких значений.

*. Аннотация @EmbeddedId

Второй способ отображения первичного ключа, состоящего из нескольких стол-
бцов, заключается в использовании аннотации @EmbeddedId . Применение этой ан-
нотации очень близко напоминает применение аннотации @IdClass , но в отличие
от нее @EmbeddedId используется в паре с аннотацией @Embeddable и превращает
объект предметной модели в составной объект.


поддержка первичных ключей не является единственным предназначением аннотации
@Embeddable. Любой объект можно отметить аннотацией @Embeddable и использовать
его в рамках предметной модели. Отличным примером может служить представление
адреса. Информацию об адресе могут использовать самые разные объекты предмет-
ной модели, и вместо того, чтобы дублировать эти свойства, можно создать объект
@Embeddable Address и встраивать его с помощью @Embedded в объекты предметной
модели. Мы рекомендуем вам не останавливаться на достигнутом и продолжить самостоя-
тельное исследование аннотаций @Embedded, @Embeddable и @AttributeOverride.


9.3.8. Генерирование значений первичных ключей

Существует пять популярных методов генерации значений первичных ключей, под-
держиваемых в JPA:
 - AUTO;
 - IDENTITY;
 - SEQUENCE;
 - TABLE;
 - CODE.


*. AUTO
Метод AUTO используется по умолчанию и является простейшим случаем ис-
пользования @GeneratedValue . Он освобождает разработчика от необходимости
выполнения каких-то особых операций с базой данных и возлагает создание зна-
чений первичного ключа на механизмы по умолчанию, настроенные в базе дан-
ных.

@Entity
public class User {
  @Id
  @GeneratedValue(strategy=GenerationType.AUTO) // Метод AUTO
  @Column(name=”USER_ID”)
  protected Long userId;
}

*. IDENTITY
Метод IDENTITY основан на использовании столбца специального типа, под-
держивающего возможность автоматического увеличения собственного числово-
го значения для уникальной идентификации строк в таблице. Такой тип столбца
поддерживается в большинстве баз данных. В Microsoft SQL Server этот тип на-
зывается IDENTITY ; в MySQL – AUTO_INCREMENT ; в PostgreSQL – SERIAL ; в Oracle
этот тип столбцов отсутствует. Когда данные вставляются в таблицу, значение
специального поля автоматически увеличивается и его значение сохраняется как
первичный ключ строки.

@Entity
public class User {
  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY) // Метод IDENTITY
  @Column(name=”USER_ID”)
  protected Long userId;
}

*. SEQUENCE
При использовании метода SEQUENCE , для создания уникальных числовых зна-
чений используются последовательности (sequence) базы данных. Этот метод
наиболее популярен в базах данных Oracle, потому что в Oracle отсутствует тип
столбцов с автоматически увеличивающимися значениями, как описывалось в
предыдущем разделе.

Чтобы настроить JPA на использование последовательнос-
ти в базе данных в качестве генератора значений первичного ключа, сначала не-
обходимо определить последовательность. Следующая инструкция SQL создает
последовательность в Oracle:

CREATE SEQUENCE USER_SEQUENCE START WITH 1 INCREMENT BY 10;

Затем указать используемую последовательность с помощью аннотации
@SequenceGenerator и задействовать эту последовательность в аннотации
@GeneratedValue .


@Entity  // Внутреннее имя последовательности для JPA
@SequenceGenerator(name=”USER_SEQUENCE_GENERATOR”,
  // Имя последовательности в базе данных
  sequenceName=”USER_SEQUENCE”, initialValue=1, allocationSize=10)
  public class User {
    @Id
    @GeneratedValue(strategy=GenerationType.SEQUENCE, 
    // Метод SEQUENCE Внутреннее имя используемой последовательности
    generator=”USER_SEQUENCE_GENERATOR”)
    @Column(name=”USER_ID”)
    protected Long userId;
}

ервой в этом листинге следует аннотация @SequenceGenerator , определя-
ющая имя последовательности USER_SEQUENCE_GENERATOR. Это внутреннее
имя для JPA, которое будет использоваться в других аннотациях для ссылки на
по следовательность. В атрибуте sequenceName указывается фактическое имя по-
следовательности в базе данных, в данном случае: USER_SEQUENCE. В аннотации
@GeneratedValue указывается метод Generation_Type.SEQUENCE, а атрибуту
generator присваивается внутреннее имя последовательности.
Действие аннотации @SequenceGenerator распространяется на весь мо-
дуль. То есть, ее необязательно использовать внутри класса. Любая аннотация
@SequenceGenerator определяет настройки для всех сущностей, поэтому внут-
ренние имена последовательностей должны быть уникальными.


*. TABLE
Метод TABLE основан на использовании небольшой таблицы в базе данных для
получения автоматически увеличивающихся числовых значений. Обычно такая
таблица состоит из двух столбцов. В первом столбце определяется уникальное
имя последовательности, а во втором – текущее значение.

CREATE TABLE SEQUENCE_GENERATOR_TABLE (
  SEQUENCE_NAME VARCHAR2(80) NOT NULL,
  SEQUENCE_VALUE NUMBER(15) NOT NULL,
  PRIMARY KEY (SEQUENCE_NAME) );

-- Вставить последовательность с именем USER_SEQUENCE и начальным значением 1
INSERT INTO SEQUENCE_GENERATOR_TABLE
(SEQUENCE_NAME, SEQUENCE_VALUE) VALUES (‘USER_SEQUENCE’, 1);

атем, с помощью аннотации @TableGenerator настраивается подключение к
этой таблице и в аннотации @GeneratedValue – использование данного генерато-
ра последовательности.

@Entity  // Внутреннее имя последовательности для JPA
@TableGenerator (name=”USER_TABLE_GENERATOR”,
  // Имя таблицы в базе данных
  table=”SEQUENCE_GENERATOR_TABLE”,
  // Столбец в таблице с именем последовательноти
  pkColumnName=”SEQUENCE_NAME”,
  // Столбец в таблице со значением последовательности
  valueColumnName=”SEQUENCE_VALUE”,
  // Имя используемой последовательности (в таблице)
  pkColumnValue=”USER_SEQUENCE”)
  public class User {
  @Id
  @GeneratedValue(strategy=GenerationType.TABLE, // Метод TABLE
  // Внутреннее имя используемой последовательности
  generator=”USER_TABLE_GENERATOR”)
  @Column(name=”USER_ID”)
  protected Long userId;
}

Первой в этом листинге следует аннотация @TableGenerator с именем
USER_TABLE_GENERATOR. Это внутреннее имя для JPA, которое будет исполь-
зоваться в других аннотациях для ссылки на последовательность. Атрибут table
определяет имя таблицы. Атрибут pkColumnName определяет имя столбца в
таблице, хранящего имена последовательностей. Атрибут valueColumnName
определяет имя столбца, хранящего значения последовательностей. Наконец,
атрибут pkColumnValue  определяет имя используемой последовательности
(см. инструкцию INSERT в листинге 9.14). В аннотации @GeneratedValue указы-
вается метод GenerationType.TABLE и в атрибуте generator – внутреннее имя
последовательности.


**. Важно отметить, что особое значение для первичных ключей имеют методы equals() и
hashCode(). Обычно для сравнения объектов предметной модели по первичному ключу
требуется предоставить собственные реализации этих методов. Но при использовании
любого из методов автоматической генерации первичных ключей, их значения остаются
неизвестными, пока механизм сохранения не вставит данные в таблицу. То есть, до мо-
мента вставки, значение первичного ключа в объекте предметной модели будет равно
NULL. Соответственно, методы equals() и hashCode() должны корректно обрабаты-
вать пустые значения.


*. CODE 
Метод CODE используется в ситуациях, когда значение первичного ключа же-
лательно было бы вычислять вручную, в прикладном коде, без применения ав-
томатических механизмов базы данных. Для этого JPA поддерживает множество
разных способов, но наиболее популярным является способ, основанный на ис-
пользовании аннотации @PrePersist , с помощью которой можно организовать
присваивание значения свойству первичного ключа перед вставкой данных в базу.

@Entity
public class User {
  @Id
  @Column(name = “USER_ID”)
  protected String userId;
  
  // Этот метод автоматически будет вызван перед вставкой данных
  @PrePersist
  public void generatePrimaryKey() {
    // Генерирует значение первичного ключа
    userId = UUID.randomUUID().toString();
  }
}

В этом листинге можно заметить несколько отличий в классе User . Во-первых,
отсутствует аннотация @GeneratedValue . Это обусловлено тем, что теперь зна-
чение первичного ключа вычисляется вручную, а не автоматически. Во-вторых,
появилась аннотация @PrePersist, сообщающая механизму JPA, что он должен
вызывать метод generatePrimaryKey() перед вставкой данных в базу. И, в-тре-
тьих, используется объект UUID из JDK, как простой пример одного из способов
вычисления значения первичного ключа.

--//--

9.4. Отношения между сущностями

Под отношением в действительности понимается
хранение ссылки на одну сущность в другой. Например, объект предложения цены
(ставки) Bid хранит ссылку на объект объявления Item , для которого это предло-
жение было сделано. Соответственно, между объектами Bid и Item существует
отношение. Напомним, что отношения могут быть одно- и двунаправленными.
Отношения могут относиться к одному из
четырех типов: «один к одному», «один ко многим», «многие к одному» и «мно-
гие ко многим». Все типы отношений выражаются в JPA с помощью аннотаций.


9.4.1. Отношение «один к одному»

Для выражения одно- и двунаправленных отношений «один к одному» использу-
ется аннотация @OneToOne . В структуре модели предметной области приложения
ActionBazaar (рис. 9.3) нет отношений «один к одному». Но такое отношение легко
представить, если вообразить отношение между объектами User и BillingInfo .
Объект BillingInfo может содержать данные, касающиеся кредитной карты
пользователя, счета в банке, и так далее.

Однонаправленное отношение «один к одному»

@Entity
public class User {
  @Id
  protected String userId;
  protected String email;
  
  // Отношение “один к одному” между User и BillingInfo
  @OneToOne
  protected BillingInfo billingInfo;
}

// Сущность, связанная отношением с User
@Entity
public class BillingInfo {
  @Id
  protected Long billingId;
}


В этом листинге класс User хранит ссылку на BillingInfo в свойстве
billingInfo. Так как свойство billingInfo хранит ссылку на единственный эк-
земпляр BillingInfo, отношение относится к типу «один к одному». Аннота-
ция @OneToOne определяет это отношение в базе данных.
Аннотацию @OneToOne, как и большинство других аннотаций JPA, можно при-
менять к свойствам класса или к методам чтения. Она имеет несколько атрибутов

[targetEntity]
Класс объекта, участвующего в отношении. Может пригодиться, когда отно-
шения определяются интерфейсами и имеется несколько классов реализа-
ций.

[cascade]
Определяет, как должны распространяться изменения по данным связанным
отношением.

[fetch]
Определяет момент, когда должны извлекаться связанные данные.

[optional]
Определяет, должно ли отношение интерпретироваться как необязательное

[mappedBy]
Определяет сущность, владеющую отношением. Этот атрибут употребляет-
ся только на стороне, не владеющей отношением


*. Двунаправленное отношение «один к одному»
При использовании однонаправленных отношений навигация в пределах пред-
метной модели может осуществляться только в одном направлении. В реализации,
представленной в листинге 9.17, через объект User можно добраться до объекта
BillingInfo , но обратного пути не существует – нельзя получить объект User ,
имея объект BillingInfo . В двунаправленных отношениях объекты предметной
модели хранят ссылки друг на друга, что позволяет двигаться в любом из двух
направлений. Двунаправленные отношения «один к одному» реализуются путем
применения аннотаций @OneToOne с обеих сторон отношения.

Двунаправленное отношение «один к одному»

@Entity
public class User {
  @Id
  protected String userId;
  protected String email;
  // Отношение “один к одному”
  @OneToOne
  protected BillingInfo billingInfo;
}

@Entity
public class BillingInfo {
  @Id
  protected Long billingId;
  protected String creditCardType;
  // ...

  // Владельцем этого двунаправленного отношения “один к одному”
  // является User.billingInfo
  @OneToOne(mappedBy=”billingInfo”, optional=false)
  protected User user;
}

В этом листинге класс User связан отношением с классом BillingInfo пос-
редством свойства billingInfo. Пока нет никаких отличий от однонаправлен-
ного отношения «один к одному» в листинге 9.17. Но в этом примере отношение
является двунаправленным, потому что класс BillingInfo также имеет ссылку на
класс User в виде свойства user. Аннотация @OneToOne перед свойством user
имеет атрибуты mappedBy и optional . Атрибут mappedBy=”billingInfo” сообща-
ет механизму JPA, что «владельцем» отношения является свойство billingInfo
класса User , а атрибут optional=”false” – что экземпляр BillingInfo не мо-
жет существовать без экземпляра User . Любопытно отметить, что аннотация
@OneToOne в классе User не имеет этого атрибута. Из этого следует, что экземпляр
User может существовать без экземпляра BillingInfo , а экземпляр BillingInfo
без экземпляра User – нет.


9.4.2. Отношения «один ко многим» и «многие к одному»

Состоя в отношениях
этого типа, одна сущность может хранить две ссылки и более на другие сущности.
Обычно это означает, что сущность имеет свойство-коллекцию типа java.util.
Set или java.util.List , хранящее множество экземпляров другой сущности.
Кроме того, если отношение между двумя сущностями является двунаправлен-
ным, с одной стороны это отношение будет относиться к типу «один ко многим»,
а с другой «многие к одному».

С точки зрения Item , для одного объявления Item может быть
сделано несколько предложений цены (ставок) Bid ; соответственно отношение
Item-Bid относится к типу «один ко многим». C точки зрения Bid , множество
предложений цены может быть сделано для одного объявления Item ; соответст-
венно отношение Bid-Item относится к типу «многие к одному».

Двунаправленные отношения «один ко многим» и «многие к одному»

@Entity
public class Bid {
  @Id
  protected Long bidId;
  protected Double amount;
  protected Date timestamp;
  ...
  // Отношение “многие к одному”
  @ManyToOne
  protected Item item;
  ...
}
 

@Entity
public class Item {
  @Id
  protected Long itemId;
  protected String title;
  protected String description;
  protected Date postdate;
  ...
  // Отношение “один ко многим”, владельцем которого является Bid
  @OneToMany(mappedBy=”item”)
  protected Set<Bid> bids;
  ...
}

В терминах отношения
Bid-Item , можно утверждать, что объект Item может существовать без объектов
Bid , а объекты Bid без объекта Item – нет. Поэтому объект Bid является «вла-
дельцем» отношения между Bid и Item .


При использовании аннотаций @ManyToOne и @OneToMany иногда возникает путаница,
какую аннотацию использовать с той или иной стороны. Поэтому часто полезно задавать
себе следующие вопросы.
«Я» один, а «вас» много? Если ответ на этот вопрос утвердительный, значит класс дол-
жен содержать список или множество сущностей, и такое отношение относится к типу
«один ко многим» (аннотация @OneToMany). (См. класс Item в листинге 9.19.)
«Нас» много, а «вы» один? Если ответ на этот вопрос утвердительный, значит класс дол-
жен содержать единственный экземпляр сущности, и такое отношение относится к типу
«многие к одному» (аннотация @ManyToOne). (См. класс Bid в листинге 9.19.)
Самое интересное наступает, когда утвердительный ответ можно дать на оба вопроса.
Чтобы понять, как действовать в этой ситуации, переходите к обсуждению отношения
«многие ко многим» и аннотации @ManyToMany в следующем разделе.


9.4.3. Отношение «многие ко многим»

В отноше-
ниях этого типа обе стороны могут хранить коллекции ссылок на связанные сущ-
ности. В приложении ActionBazaar в отношении «многие ко многим» находятся
объекты Category и Item

В отношении Item-Category объект объявления Item может быть помещено в
несколько категорий, в то же время каждая категория Category может содержать
несколько объявлений. Для определения отношений этого типа используется ан-
нотация @ManyToMany . Обычно отношения «многие ко многим» являются двунап-
равленными.


@Entity
public class Category {
  @Id
  protected Long categoryId;
  protected String name;
  ...
  // Отношение “многие ко многим”
  @ManyToMany
  protected Set<Item> items;
  ...
}


@Entity
public class Item {
  @Id
  protected Long itemId;
  protected String title;
  ...
  // Отношение “многие ко многим”, владельцем которого является Category
  @ManyToMany(mappedBy=”items”)
  protected Set<Category> categories;
  ...
}

В этом листинге свойство items объекта Category отмечено аннотацией
@ManyToMany и оно же является владельцем отношения. Свойство categories
объекта Item , напротив, является подчиненной стороной в двунаправленном от-
ношении «многие ко многим». Как и в примере определения отношения «один ко
многим», в аннотации @ManyToMany опущен атрибут optional , потому что пустое
множество или список неявно подразумевают необязательность отношения, в том
смысле, что сущность может существовать даже в отсутствие связей с другими
сущностями.

--//--


9.5. Отображение наследования

Далее мы посмот-
рим, как наследование объектов Java отражается на строении таблиц. Чтобы было
проще понять, о чем пойдет речь, рассмотрим простой пример. Как вы помните,
в приложении ActionBazaar имеется два разных типа пользователей: покупатели
(bidders) и продавцы (sellers).

Это так очевидно, что Bidder и Seller должны насле-
довать User . Но для администраторов баз данных наследование объектов пред-
ставляет большую проблему. Почему? Потому что большинство баз данных не
поддерживают наследование между таблицами (наследование таблиц имеется
в PostgreSQL, но это редкое явление). Соответственно перед администратором
встает вопрос: как отобразить иерархию наследования объектов

Существует три стратегии, помогающие решить эту задачу:
 - единой таблицы;
 - соединения таблиц;
 - отдельных таблиц для каждого класса.


9.5.1. Стратегия единой таблицы

В соответствии со стратегией единой таблицы, которая является для JPA страте-
гией по умолчанию, все классы в иерархии модели предметной области отобра-
жаются в одну общую таблицу. То есть, все данные из всех объектов в предметной
модели хранятся в общей таблице. Разные объекты в предметной модели иденти-
фицируются с помощью специального столбца, называемого дискриминатором
(discriminator). Столбец-дискриминатор в каждой строке содержит значение,
уникальное для данного типа объектов

Чтобы проще было понять эту схему, рассмотрим ее реа-
лизацию. В настоящий момент в приложении ActionBazaar предполагается, что
объекты всех типов, представляющие пользователей, включая Bidder и Seller ,
отображаются в таблицу USERS .

Как показано на рис. 9.10, таблица USERS содержит данные, общие для всех учет-
ных записей ( USER_IDD , USERNAME ). Она также содержит данные, уникальные для
Bidder ( BID_FREQUENCY ) и для Seller ( CREDIT_WORTH ). Строки 1 и 2 содержат за-
писи, соответствующие классу Bidder , а строка 3 – запись, соответствующую клас-
су Seller . Это обозначено значениями B и S в столбце дискриминатора USER_TYPE .
Дискриминатор USER_TYPE будет содержать значения, соответствующие всем ти-
пам пользователей в предметной модели ActionBazaar. Механизм JPA будет отоб-
ражать каждый тип, сохраняя данные в соответствующих столбцах, устанавливая
нужное значение в столбце USER_TYPE и записывая в остальные столбцы значение
NULL .

Стратегия единой таблицы

@Entity
// Сущность User отображается в таблицу USERS
@Table(name=”USERS”)
// Для предметной модели будет использоваться стратегия единой таблицы
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
// Имя и тип столбца-дискриминатора
@DiscriminatorColumn(name=”USER_TYPE”,discriminatorType=DiscriminatorType.STRING, length=1)
public abstract class User { ... }

@Entity
// Значение столбца-дискриминатора для объектов Bidder
@DiscriminatorValue(value=”B”)
public class Bidder extends User {...}

// Значение столбца-дискриминатора для объектов Seller
@Entity
@DiscriminatorValue(value=”S”)
public class Seller extends User {...}


С помощью аннотаций @Inheritance и @DiscriminatorColumn опреде-
ляется, что для данной предметной модели механизм JPA должен использовать
стратегию единой таблицы. Аннотации @Inheritance и @DiscriminatorColumn
всегда должны помещаться перед корневым объектом модели. В данном приме-
ре таковым является объект User . Обратите внимание, что объект User отмечен
аннотацией @Table(name=”USERS”) с определением имени таблицы, а объекты
Bidder и Seller нет. 
Это обусловлено тем, что в стратегии единой таблицы сущест-
вует только одна таблица, поэтому все данные для разных типов учетных записей
будут храниться вместе, в таблице USERS . Чтобы можно было отличить данные,
соответствующие классу Bidder , с помощью аннотации @DiscriminatorValue
настраивается сохранение значения “B” для этого класса в столбце USER_TYPE
таблицы USERS. Аналогично настраивается сохранение значения “S” для класса
Seller. Применение аннотации @DiscriminatorValue не является обязатель-
ным, в ее отсутствие значениями столбца дискриминатора будут служить имена
классов, например, “Seller” для объекта Seller .


9.5.2. Стратегия соединения таблиц

Стратегия соединения таблиц основана на использовании отношения «один к од-
ному» между предметной моделью и таблицами в базе данных. При ее использо-
вании для каждой сущности в предметной модели создается отдельная таблица.

таблица USERS является родительской и хранит
данные, общие для всех типов учетных записей ( USERNAME ). Таблицы BIDDERS
и SELLERS являются дочерними, о чем свидетельствует тот факт, что столбец
USER_ID в таблицах BIDDERS и SELLERS является внешним ключом, ссылающимся
на столбец USER_ID в таблице USERS . Таблица BIDDERS хранит данные, уникальные
для учетных записей покупателей ( BID_FREQUENCY ), а таблица SELLERS – данные,
уникальные для учетных записей продавцов ( CREDIT_WORTH ). Эти таблицы явля-
ются прямым отображением предметной модели. Так, сущность User отображает-
ся в таблицу USERS , Seller – в таблицу SELLERS и Bidder – в таблицу BIDDERS .


@Entity
// Сущность User отображается в таблицу USERS
@Table(name=”USERS”)
// Для предметной модели будет использоваться стратегия соединения таблиц
@Inheritance(strategy=InheritanceType.JOINED)
// Имя и тип столбца-дискриминатора
@DiscriminatorColumn(name=”USER_TYPE”,discriminatorType=DiscriminatorType.STRING, length=1)
public abstract class User { ... }

@Entity
// Сущность Bidder отображается в таблицу BIDDERS
@Table(name=”BIDDERS”)
// Значение столбца-дискриминатора для объектов Bidder
@DiscriminatorValue(value=”B”)
// Использовать BIDDERS.USER_ID для соединения с USERS.USER_ID
@PrimaryKeyJoinColumn(name=”USER_ID”)
public class Bidder extends User {...}

@Entity
// Сущность Seller отображается в таблицу SELLERS
@Table(name=”SELLERS”)
// Значение столбца-дискриминатора для объектов Seller
@DiscriminatorValue(value=”S”)
// Использовать SELLERS.USER_ID для соединения с USERS.USER_ID
@PrimaryKeyJoinColumn(name=”USER_ID”)
public class Seller extends User {...}


Аннотации @DiscriminatorColumn и @DiscriminatorValue в этом лис-
тинге используются точно так же, как в реализации стратегии единой таблицы.
В атрибуте strategy аннотации @Inheritance указано значение JOINED . Кроме
того, посредством применения аннотаций @PrimaryKeyJoinColumn в обеих сущ-
ностях, Bidder и Seller, между родительской и дочерними таблицами реа-
лизованы отношения «один к одному». В обоих случаях атрибут name определяет,
что столбцы BIDDER.USER_ID и SELLER.USER_ID являются внешними ключами,
ссылающимися на USER.USER_ID . Сущности Bidder и Seller также отмечены ан-
нотациями @Table , определяющими имена таблиц для отображения.


9.5.3. Стратегия отдельных таблиц для каждого класса

При использовании стратегии отдельных таблиц , для каждой сущности в пред-
метной модели создается отдельная таблица, почти как в стратегии соединения
таблиц, но между ними есть важное отличие: в стратегии отдельных таблиц для
каждого класса отсутствуют какие-либо отношения между таблицами. Все дан-
ные, которые являются разделяемыми в стратегии соединения таблиц, не являют-
ся разделяемыми в стратегии отдельных таблиц и дублируются в каждой таблице.

Из-за дублирования данных, при использовании стратегии отдельных таблиц
необходимо проявлять осторожность, сохраняя данные, особенно если эти данные,
такие как USER_ID и USERNAME , должны быть уникальны. Данные должны быть
уникальными не только в «дочерней» таблице, но и в «родительской» (слова «ро-
дительская» и «дочерняя» взяты в кавычки, потому что в действительности табли-
цы не связаны отношениями). Например, допустим, что потребовалось сохранить
новую учетную запись покупателя со следующими данными: USER_ID = 10 , US
ERNAME = “ActionBazaarUser123” . Эти значения могут быть уникальными для
таблицы BIDDERS , но при использовании стратегии отдельных таблиц эти же дан-
ные необходимо сохранить в таблице USERS . Однако для таблицы USERS эти зна-
чения могут оказаться неуникальными, из-за того, что могут уже использоваться
в учетной записи продавца.

@Entity
// Сущность User отображается в таблицу USERS
@Table(name=”USERS”)
// Для предметной модели будет использоваться стратегия отдельных таблиц
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
public class User { ... }

@Entity
// Сущность Bidder отображается в таблицу BIDDERS
@Table(name=”BIDDERS”)
public class Bidder extends User {...}
@Entity
// Сущность Seller отображается в таблицу SELLERS
@Table(name=”SELLERS”)
public class Seller extends User {...}


В этом листинге видно, что атрибут strategy аннотации @Inheritance опреде-
ляет стратегию TABLE_PER_CLASS. Разумеется, в этом листинге отсутствуют ан-
нотации @DiscriminatorColumn и @DiscriminatorValue – в данном случае они
не нужны, потому что все данные для каждой сущности сохраняются в отдельной
таблице, соответственно нет необходимости различать записи по типу учетной
записи. Наконец, с помощью аннотаций @Table реализовано отображение каждой
сущности в собственную таблицу.

9.6. В заключение

  ---

--//-------------------------------------------------------------------------

# Глава 10.
# Управление сущностями

В этой главе мы познакомимся с объектами
EntityManager и посмотрим, как управлять сущностями. Обсудим назначение
объекта EntityManager и как внедрять его в классы EJB. Вы познакомитесь с жиз-
ненным циклом сущностей и как с помощью EntityManager сохранять, находить,
объединять и удалять сущности, то есть, выполнять обычные операции создания,
чтения, изменения и удаления в базе данных. Здесь вы также познакомитесь с раз-
ными областями видимости контекста сохранения.

10.1. Введение в использование EntityManager

Объект EntityManager является, пожалуй, самым важным и интересным элемен-
том Java Persistence API. Он управляет жизненным циклом сущностей. В этом
разделе вы познакомитесь с интерфейсом EntityManager и его методами.

10.1.1. Интерфейс EntityManager

В некотором смысле EntityManager играет роль моста между объектно-ориенти-
рованным и реляционным мирами. когда прикладной
код создает сущность, объект EntityManager преобразует ее в новую запись в базе
данных. Когда прикладной код изменяет сущность, объект EntityManager нахо-
дит соответствующие данные в базе и приводит их в соответствие с изменениями
в сущности. Аналогично EntityManager удаляет данные из базы, когда запраши-
вается удаление сущности. С другой стороны моста, когда выполняется попытка
«найти» сущность в базе данных, EntityManager создает объект сущности, запол-
няет его данными из базы и «возвращает» в объектно-ориентированный мир.

Помимо выполнения этих явных CRUD-операций создания, чтения изменения
и удаления, EntityManager также старается автоматически синхронизировать
сущности с базой данных, пока они находятся в его области досягаемости (именно
такую синхронизацию мы будем подразумевать под «управлением» сущностями
в следующем разделе). Можно смело утверждать, что EntityManager является
важнейшим интерфейсом в JPA и реализует большую часть волшебства объектно-
реляционного отображения.


[ public void persist (Object entity); ]
Сохраняет сущность в базе данных и делает ее управляемой сущностью.

[ public <T> T merge (T entity); ]
Подключает сущность к контексту сохранения EntityManager и возвращает 
подключенную сущность.

[ public void remove (Object entity); ]
Удаляет сущность из базы данных

[ public <T> T find (Class<T> entityClass, Object primaryKey); ]
Находит экземпляр сущности по первичному ключу. Этот метод имеет перегруженные
версии и доступен в разных формах.

[ public void flush (); ]
Синхронизирует данные в базе с состоянием сущностей в контексте сохранения
EntityManager.

[ void setFlushMode(FlushModeType flushMode); ]
Изменяет режим синхронизации для контекста сохранения объекта EntityManager.
Поддерживается два режима сохранения: AUTO и COMMIT. По умолчанию использует-
ся режим AUTO, в соответствии с которым EntityManager пытается автоматически
синхронизировать сущности с базой данных.

[ public FlushModeType getFlushMode (); ]
Возвращает текущий режим синхронизации.

[ public void refresh(Object entity); ]
Обновляет сущности, читая данные из базы. Этот метод имеет перегруженные версии 
и доступен в разных формах.

[ public Query createNamedQuery (String name); ]
Создает экземпляр запроса на основе именованного запроса в экземпляре сущности.
Этот метод имеет перегруженные версии и доступен в разных формах.

[ public Query createNativeQuery (String sqlString); ]
Создает динамический запрос с использованием инструкций SQL. Этот метод имеет
перегруженные версии и доступен в разных формах.

[ public StoredProcedureQuery createStoredProcedureQuery (String procedureName); ]
Создает StoredProcedureQuery для выполнения хранимой процедуры. Этот метод
имеет перегруженные версии и доступен в разных формах.

[ public void close (); ]
Закрывает управляемый приложением объект EntityManager.

[ public void clear (); ]
Отсоединяет все управляемые сущности от контекста сохранения. Изменения в сущ-
ностях при этом не сохраняются и утрачиваются.

[ public boolean isOpen (); ]
Проверяет, открыт ли объект EntityManager.

[ public EntityTransaction getTransaction (); ]
Возвращает объект транзакции, который можно использовать для запуска и завер-
шения транзакции вручную.

[ public void joinTransaction (); ]
Предлагает объекту EntityManager присоединиться к текущей транзакции JTA.


10.1.2. Жизненный цикл сущностей

Сущность, находящаяся под управлением EntityManager , называется под-
ключенной (attached), или управляемой (managed).С другой стороны, когда
EntityManager прекращает управление сущностью, такая сущность называется
отключенной (detached). Сущность, которая никогда не находилась под управле-
нием, называется переходной (transient), или новой.


*. Подключенные сущности
Когда речь идет о сущности в подключенном состоянии, подразумевается, что
ее синхронизацию с базой данных обеспечивает EntityManager . То есть, объект
EntityManager гарантирует, во-первых, загрузку данных из базы в сущность, как
только она будет передана под его управление, и, во-вторых, запись данных в базу
при изменении свойств сущности (например, в результате вызова ее методов).
Достигается это за счет хранения ссылки на сущность объектом EntityManager
и периодической проверки необходимости синхронизации. Если EntityManager
обнаружит изменение данных в сущности, он автоматически синхронизирует из-
менения с базой данных. Управление сущностью прекращается, когда она удаля-
ется или выходит из области досягаемости диспетчера.

Подключить сущность к контексту EntityManager можно вызовом метода
persist или merge . Также подключение выполняется при извлечении сущности
из базы данных вызовом метода find или query внутри транзакции. Состояние
сущности определяется вызываемым методом. Управляемую сущность в любой
момент можно обновить данными из базы вызовом метода refresh .


Сразу после создания экземпляра, как показано в следующем фрагменте, сущ-
ность оказывается в новом, или переходном состоянии, потому что EntityManager
пока не знает о ее существовании:

Bid bid = new Bid();

В таком переходном состоянии сущность будет пребывать, пока вызовом метода
persist объекта EntityManager не будет создана новая запись в базе данных, 
соответствующая сущности. Это самый естественный способ подключить сущность
Bid из предыдущего фрагмента к контексту EntityManager :

manager.persist(bid);

Управляемая сущность отключается от контекста, когда выходит из его облас-
ти видимости, удаляется, сериализуется или клонируется. Например, экземпляр
сущности Bid будет отключен в результате подтверждения транзакции.

Сущность, извлеченная из базы данных вызовом метода find объекта
EntityManager или одного из методов запроса в контексте транзакции, автомати-
чески становится управляемой. Извлеченная сущность тут же становится непод-
ключенной, если извлечение произошло вне транзакции.

Подключить отключенную сущность можно одним из двух способов. 
(*) Первый –
вызовом метода merge . Метод merge принимает отключенную сущность и возвра-
щает подключенную сущность. С помощью переданной ему отключенной сущнос-
ти метод merge находит данные в базе, создает новую подключенную сущность,
копирует в нее изменения из исходной неподключенной сущности и возвращает
новую, подключенную сущность. Прежде чем транзакция завершится, любые из-
менения в новой подключенной сущности будут сохранены в базе – таким спосо-
бом можно записать изменения из неподключенной сущности в базу данных.

(*) Второй способ – вызовом метода find . Чтобы получить новую подключенную
сущность, достаточно передать первичный ключ из отключенной сущности в за-
прос. Раз уж мы заговорили об отключенных сущностях, рассмотрим их подроб-
нее.


*. Отключенные сущности
Отключенная сущность – это сущность, не управляемая объектом EntityManager
и для нее не гарантируется синхронизация с базой данных. Операции отключения
и подключения могут пригодиться при необходимости передачи сущностей меж-
ду различными слоями приложения. Например, можно отключить сущность, пе-
редать ее в веб-слой, обновить, вернуть обратно в слой компонентов EJB и вновь
подключить к контексту сохранения данных.

Механика отключения сущностей имеет некоторые особенности. По сути, под-
ключенная сущность отключается, как только выходит из области видимости
контекста EntityManager . Это можно представить, как разрыв связи между сущ-
ностью и объектом EntityManager в конце логической единицы обработки, или
сеанса. Сеанс взаимодействия с EntityManager можно ограничить единственным
вызовом метода или распространить во времени до бесконечности.

Если сеанс взаимодействия с EntityManager ограничен
единственным вызовом метода, все подключенные сущности отключатся, как
только метод вернет управление, даже если они продолжат использоваться за
пределами метода.

Экземпляры сущностей также отключаются при клонировании или сериализа-
ции. Это объясняется тем, что EntityManager следит за сущностями, используя
ссылки на объекты Java. Так как клонированные или сериализованные экземпля-
ры не могут адресоваться ссылками на оригинальные сущности, у EntityManager
нет никакой возможности узнать об их существовании.

Кроме того, вызов метода clear объекта EntityManager принудительно отклю-
чит все сущности, управляемые этим объектом. Вызов метода remove также от-
ключит сущность, но это вполне логично: он удалит все данные из базы, связанные
с сущностью, а так как данные будут удалены, бессмысленно продолжать управ-
лять ими.

manager.remove(bid);


10.1.3. Контекст сохранения, области видимости и EntityManager

Контекст сохранения (persistence context) играет важную роль в работе внутрен-
них механизмов EntityManager . Вы можете выполнять операции сохранения, вы-
зывая методы EntityManager , но сам объект EntityManager не будет следить за
жизненным циклом отдельных сущностей. В действительности, EntityManager
делегирует задачу управления состоянием сущностей текущему доступному кон-
тексту сохранения.
В самом простом представлении, контекст сохранения – это автономная кол-
лекция сущностей, управляемых диспетчером EntityManager в данной области
видимости. Область видимости – это промежуток времени, в течение которого
сущности в коллекции остаются управляемыми.

Существует два типа областей видимости контекста сохранения: область види-
мости транзакции и расширенная область видимости.


*. Транзакционный EntityManager
Объект EntityManager , связанный с контекстом, область видимости которо-
го ограничена рамками транзакции, называется транзакционным. Если контекст
сохранения действует только в пределах транзакции, сущности, подключенные
во время действия транзакции, автоматически отключатся после ее завершения.
(Все операции, связанные с изменением данных, должны выполняться внутри
транзакции, независимо от типа области видимости.) Проще говоря, контекст
сохранения продолжает управлять сущностями, пока охватывающая транзакция
остается активной. Как только контекст сохранения обнаружит, что транзакция
была подтверждена или отменена, он отключит все управляемые им сущности,
предварительно синхронизировав их с базой данных.


*. EntityManager с расширенной областью видимости
Диспетчер EntityManager с расширенной областью видимости распространяет
свое действие на несколько транзакций. Однако он может работать только с сеан-
совыми компонентами с сохранением состояния и продолжает действовать, пока
компонент не будет уничтожен. Поэтому в контекстах сохранения с расширен-
ной областью видимости продолжительность периода, когда сущности остаются
управляемыми, никак не зависит от продолжительности отдельных транзакций.
После подключения сущности остаются управляемыми, пока продолжает сущест-
вовать экземпляр EntityManager .

Термин область видимости (scope), применительно к контекстам сохранения,
имеет тот же смысл, что и применительно к переменным Java. Он описывает, как
долго остается активным тот или иной контекст. Транзакционные контексты
можно сравнить с локальными переменными в методах – они действуют только
в рамках транзакций. Контексты с расширенной областью видимости, напротив,
больше похожи на переменные экземпляров, которые остаются активными в тече-
ние всего времени существования объекта – они действуют, пока существует сам
объект EntityManager .


10.1.4. Использование EntityManager в ActionBazaar

Займемся далее исследованием интерфейса EntityManager на примере реали-
зации сеансового компонента без сохранения состояния ItemManagerBean для
приложения ActionBazaar. Данный компонент реализует операции для работы с
объявлениями.

сеансовый компонент предоставля-
ет методы, добавляющие, изменяющие и удаляющие сущности Item с помощью
EntityManager . Это очень важный компонент, потому что объявления составля-
ют основу приложения ActionBazaar. Пользователи просматривают объявления,
делают ставки, а по окончании торгов для победителей генерируются заказы.

@Stateless
public class ItemManager {

  @PersistenceContext
  private EntityManager entityManager;

  public void addItem(String name, String description, byte[] picture,
    BigDecimal initialPrice, long sellerId) {}

  public void saveItem(Item item) {}
  public void deleteItem(Item item) {}
  public Item updateItem(Item item) {}
  public List<Item> findItemByName(String name) {}
  public List<Item> findByDate(Date startDate , Date endDate) {}
  public List<String> getAllItemsNames() {}
  public List<Object[]> getAllItemNamesWithIds() {}
  public List<WinningBidWrapper> getWinningBid(Long itemId) {}
  public List<Tuple> getWinningBidTuple(Long itemId) {}
}


10.1.5. Внедрение EntityManager

Первое, что необходимо сделать перед выполнением каких-либо операций с хра-
нилищем данных, – получить экземпляр EntityManager. Сделать это совсем не-
сложно; достаточно отметить переменную-член типа EntityManager аннотацией
@PersistenceContext, а все остальное – поиск, открытие и закрытие – 
автоматически сделает контейнер.
Внедренный экземпляр EntityManager получит область видимости транзакции, если 
явно не указатьиное.

@Target(value = {ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface PersistenceContext {
  public String name() default “”;
  public String unitName() default “”;
  public PersistenceContextType type() default PersistenceContextType.TRANSACTION;
  public PersistenceProperty[] properties() default {};
}

Первый атрибут аннотации, name , определяет имя контекста сохранения в ка-
талоге JNDI. Этот атрибут используется в тех редких случаях, когда данная реа-
лизация контейнера требует указать имя экземпляра EntityManager в каталоге
JNDI, чтобы найти его. В большинстве случаев этот атрибут можно не указывать,
за исключением ситуаций, когда @PersistenceContext применяется к классу для
установки ссылки на контекст сохранения.

Атрибут unitName определяет имя единицы хранения (persistence unit). Едини-
цы хранения – это группы сущностей, используемых в приложении. Возможность
деления на группы может пригодиться в больших приложениях Java EE для от-
деления друг от друга разных логических областей (таких как пакеты Java). На-
пример, сущности в приложении ActionBazaar можно было бы разделить на две
группы: general и admin .
Единицы хранения можно определить только в дескрипторе развертывания
persistence.xml .

для получения экземпляра
EntityManager , управляющего определенной единицей хранения – например,
admin – необходимо указать ее имя, как показано ниже:
@PersistenceContext(unitName=”admin”)
EntityManager entityManager


*. Настройка области видимости для EntityManager

Атрибут type определяет область видимости для EntityManager . Как уже го-
ворилось выше, экземпляры EntityManager , управляемые контейнером, могут
иметь либо расширенную область видимости, либо область видимости, ограни-
ченную рамками транзакции. Если атрибут type отсутствует, он получает зна-
чение по умолчанию TRANSACTION .

@PersistenceContext(type=PersistenceContexType.EXTENDED)
EntityManager entityManager;

Для компонентов без сохранения состояния или MDB нельзя использовать
расширенную область видимости. Причина достаточно очевидна: задача расши-
ренной области видимости заключается в том, чтобы обеспечить синхронизацию
сущностей между вызовами методов компонента, даже если все вызовы методов
будут осуществляться в разных транзакциях. А так как ни сеансовые компонен-
ты без сохранения состояния, ни компоненты MDB не предполагают такой воз-
можности, бессмысленно поддерживать расширенную область видимости для
компонентов этих типов.

Отметьте, что EntityManager не под-
держивает работу в многопоточной среде, что требует особой осторожности при
внедрении экземпляров EntityManager в компоненты CDI, сервлеты, компонен-
ты JSF и им подобные.

*. EntityManager и многопоточность
Объекты EntityManager не поддерживают работу в многопоточной среде и
потому не должны использоваться в ситуациях, когда обращения к ним могут
выполняться более чем из одного потока выполнения. Это означает, что их не-
безопасно использовать в сервлетах или страницах JSP. Сервлет создается один
раз и используется для одновременной обработки множества запросов.

Лучше всего использовать экземпляры EntityManager
внутри компонентов EJB. Если по каким-то причинам понадобится обращаться к
объектам EntityManager непосредственно, можно использовать прием, представ-
ленный ниже, или задействовать EntityManagerFactory :

@PersistenceContext(name=”pu/actionBazaar” unitName=”ActionBazaar”)
public class ItemServlet extends HttpServlet {

  @Resource
  private UserTransaction ut;

  public void service(HttpSerlvetRequest req, HttpServletResponse resp)
    throws ServletException, IOException {

    Context ctx = new InitialContext();
    EntityManager em = (EntityManager)ctx.lookup(“java:comp/env/pu/actionBazaar”);
    ...
    ut.begin();
    em.persist(item);
    ut.commit();
    ...
  }
}

Другой способ – использовать управляемые приложением экземпляры
EntityManager и транзакции JTA. Стоит так же отметить, что EntityManagerFactory
можно безопасно использовать в многопоточном окружении.

10.1.6. Внедрение EntityManagerFactory

В предыдущем разделе было показано, как внедрить экземпляр EntityManager с
помощью контейнера. Когда EntityManager внедряется контейнером, у вас почти
не остается рычагов управления жизненным циклом диспетчера. В некоторых си-
туациях бывает желательно иметь более полный контроль как над самим экземп-
ляром EntityManager , так и над транзакциями. По этой причине, а также для боль-
шей гибкости, JPA предоставляет поддержку внедрения EntityManagerFactory .
С помощью EntityManagerFactory можно создавать экземпляры EntityManager ,
полностью находящиеся в вашей власти.


@Stateless
public class ItemManager {

  @PersistenceUnit // Переменная для внедрения экземпляра EntityManagerFactory
  private EntityManagerFactory entityManagerFactory;

  private EntityManager entityManager;

  @PostConstruct
  private void init() {
    // Создает EntityManager
    entityManager = entityManagerFactory.createEntityManager();
  }

  public Item updateItem(Item item) {
    // Явно подключает транзакцию JTA
    entityManager.joinTransaction();
    entityManager.merge(item);
    return item;
  }

  @PreDestroy
  private void cleanup() {
    if(entityManager.isOpen()) {
      // Закрывает EntityManager
      entityManager.close();
  }
}


аннотация PersistenceUnit

@Target({TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface PersistenceUnit {
  String name() default “”;
  String unitName() default “”;
}

Атрибуты name и unitName служат в точности тем же целям, что и одноимен-
ные атрибуты аннотации @PersistenceContext . Элемент name определяет имя
экземпляра EntityManagerFactory в каталоге JNDI, а атрибут unitName – имя
единицы хранения.

объект EntityManagerFactory имеет ме-
тод createEntityManager , который создает и возвращает новый экземпляр
EntityManager . После вызова этого метода на вас возлагается вся ответственность
за своевременное уничтожение EntityManager – если этого не сделать, приложе-
ние могут ожидать разные неприятности.
Из этого примера следует один важный вывод: экземпляр EntityManager , управ-
ляемый приложением, не включается автоматически в управление транзакциями,
поэтому необходимо использовать EntityTransaction , чтобы присоединиться к
имеющейся транзакции. На практике все же лучше использовать EntityManager ,
управляемый контейнером, потому что чем меньше операций приходится выпол-
нять вручную, тем меньше вероятность допустить ошибку.

  --//--

10.2. Операции с хранилищем

несмотря на
простоту интерфейса EntityManager , он обеспечивает полный комплект методов
для работы с хранилищем.

10.2.1. Сохранение сущностей

сохраняет сущность Item в базе данных.


public void addItem(String name, String description, byte[] picture,
      BigDecimal initialPrice, long sellerId) {

  Item item = new Item();
  item.setItemName(name);
  item.setPicture(picture);
  item.setInitialPrice(initialPrice);
  BazaarAccount seller = entityManager.find(BazaarAccount.class,sellerId);
  item.setSeller(seller);
  // Сохранение сущности
  entityManager.persist(item);
}

сущность Item связана отношением
«многие к одному» с сущностью Seller . Соответствующая сущность с информа-
цией о продавце извлекается с помощью метода find объекта EntityManager и
записывается в поле сущности Item . Затем вызывается метод persist , сохраняю-
щий сущность в базе данных

Обратите внимание, что
метод persist предназначен для создания новых записей в базе данных, а не для
обновления существующих. Это означает, что вы должны обеспечить уникаль-
ность идентичности (первичного ключа) сущности. Если попытаться сохранить
сущность со значением первичного ключа, уже имеющимся в базе данных, будет
возбуждено исключение EntityExistsException , либо в момент вызова метода
persist , либо в момент подтверждения транзакции.


10.2.2. Извлечение сущностей по ключу

Интерфейс JPA поддерживает несколько способов извлечения экземпляров сущ-
ностей из базы данных. Самый простой – извлечение сущности по первичному
ключу с использованием метода find . Все остальные способы основаны на исполь-
зовании прикладного интерфейса запросов и языка JPQL

пример:

Seller seller = entityManager.find(Seller.class, sellerId);

В первом параметре методу find передается Java-тип извлекаемой сущности.
Во втором параметре – значение идентичности сущности, которую надлежит из-
влечь.

идентичностью сущности может быть зна-
чение прос того типа, определяемое с помощью аннотации @Id , или класс состав-
ного первичного ключа, определяемый с помощью аннотации @EmbeddedId или
@IdClass .

Метод find до-
пускается вызывать вне контекста транзакции, но в этом случае он вернет непод-
ключенную сущность, поэтому в общем случае желательно вызывать find внутри
транзакции. Одной из важнейших особенностей метода find является использо-
вание им внутреннего кэша диспетчера EntityManager. Если реализация механиз-
ма хранения поддерживает кэширование и сущность уже присутствует в кэше,
EntityManager вернет экземпляр из кэша, минуя обращение к базе данных.

Интерфейс JPA обладает еще более важной особенностью, которую можно рас-
сматривать как оптимизацию, – отложенная и немедленная загрузка.


*. Режимы извлечения сущностей

Как уже говорилось, при извлечении сущности EntityManager обычно загру-
жает все ее данные из базы. На языке ORM это называется «жадной» (или немед-
ленной) загрузкой. Если вам приходилось решать проблемы производительности
приложений, связанные с досрочным или избыточным кэшированием, вы навер-
няка уже знаете, что немедленная загрузка не всегда является удачным решением.

В JPA имеется несколько средств поддержки отложенного извлечения. Самое
простое – отметить поле, подлежащее отложенному извлечению, аннотацией
@Basic .

Например, организовать отложенное извлечение свойства picture для
сущности Item можно следующим образом:

@Column(name=”PICTURE”)
@Lob
@Basic(fetch=FetchType.LAZY)
public byte[] getPicture() {
  return picture;
}

В этом случае инструкция SELECT , сгенерированная методом find , не будет за-
гружать данные из столбца ITEMS.PICTURE в поле picture . Изображение будет
автоматически загружаться при первом обращении к свойству вызовом метода
getPicture .


*. Загрузка связанных сущностей

Как известно, метод find
объекта EntityManager должен извлечь все сущности, связанные отношения-
ми с возвращаемой. Возьмем в качестве примера сущность Item из приложения
ActionBazaar, которая отлично подходит на роль испытуемого, так как связана
отношениями «многие к одному», «один ко многим» и «многие ко многим» с дру-
гими сущностями.

Перед тем, как вернуть экземпляр Item , метод find автоматически извлекает
также сущности Seller , Bid и Category , связанные с ним, и заполняет ими соот-
ветствующие свойства.

Все аннотации отношений, представленные в главе 9, включая @ManyToOne ,
@OneToMany и @ManyToMany , имеют атрибут fetch , управляющий режимами из-
влечения, точно так же, как одноименный атрибут аннотации @Basic , описанной
в предыдущем разделе. Ни одна из аннотаций отношений в следующем листинге
не определяет атрибут fetch , поэтому для всех отношений используется режим
извлечения по умолчанию.

Отношения в сущности Item:

public class Item {
  // “Один ко многим” с сущностями Bid
  @OneToMany(mappedBy = “item”, cascade = CascadeType.ALL)
  private List<Bid> bids;

  // “Многие к одному” с сущностями Seller
  @ManyToOne
  @JoinColumn(name = “SELLER_ID”, referencedColumnName = “USER_ID”)
  private BazaarAccount seller;

  // “Многие ко многим” с сущностями Category
  @ManyToMany(mappedBy = “items”)
  private Set<Category> category;
  
  ...
}

По умолчанию для некоторых отношений используется отложенный режим
извлечения, а некоторые загружаются немедленно.

Сущность Seller , связанная с Item ,
извлекается немедленно, потому что в аннотации @ManyToOne по умолчанию
используется режим EAGER . То же самое относится и к аннотации @OneToOne ,
поэтому для нее по умолчанию так же используется режим немедленной загрузки.


*. Отложенная и немедленная загрузка связанных сущностей

Для аннотаций @OneToMany и @ManyToMany , напротив, используется режим отло-
женной загрузки. Обусловлено это тем, что оба отношения возвращают множество
сущностей, соответствующих заданной.


10.2.3. Изменение сущностей

Как уже говорилось выше, EntityManager гарантирует автоматическое сохране-
ние в базе данных изменений, произведенных в подключенных сущностях. Это
означает, что по большей части вам не придется беспокоиться о вызове каких-либо
методов вручную, чтобы сохранить изменения.

Прозрачное управление подключенной сущностью:

@TransactionAttribute(REQUIRED)
public void updateItem(Long itemId, byte picture[],
    String description, StarRating starRating) {
  
  // Следующие инструкции прозрачно
  // сохраняют изменения в базе данных
  Item item = this.findItem(itemId);
  item.setPicture(picture);
  item.setDescription(description);
  item.setStarRating(starRating);
}

(*) Поиск сущности Item – единственное, для чего используется EntityManager
в методе updateItem . Однако, когда метод завершит свою работу, EntityManager
автоматически сохранит внесенные изменения в базе данных. Обычно фактичес-
кая запись производится в момент завершения транзакции, когда EntityManager
пытается подтвердить все изменения. Но у вас есть возможность произвести со-
хранение принудительно в любой момент вызовом метода flush . Метод flush
применяется ко всем сущностям, которые были подключены на этот момент. Мо-
мент синхронизации определяется параметром типа FlushModeType . Если пере-
дать в нем значение FlushTypeMode.AUTO , изменения будут сохранены в момент
выполнения запроса. Если передать значение FlushTypeMode.COMMIT , изменения
будут сохранены по завершении транзакции, в момент ее подтверждения.


*. Операции подключения и отключения сущностей 

Управляемые сущности – это чрезвычайно удобно, но проблема в том, что до-
вольно сложно обеспечить постоянное подключение сущностей. Иногда сущнос-
ти приходится отключать и сериализовать для передачи в веб-слой, где они из-
меняются, находясь за пределами досягаемости EntityManager .

Рано или поздно может понадобиться повторно подключить сущность к кон-
тексту сохранения для синхронизации с базой данных. Для этой цели объект
EntityManager предоставляет метод merge

public Item updateItem(Item item) {
  entityManager.merge(item);
  return item;
}

(*) Экземпляр сущности можно отключить, сериализовать и передать
в веб-слой, где клиент внесет в него изменения и отправит обратно на сервер.
После этого на сервере можно выполнить операцию merge, чтобы подключить
сущность к контексту сохранения


*. Подключение отношений

По умолчанию сущности, связанные с подключаемой сущностью, не подклю-
чаются автоматически. Например, сущности Seller , Bid и Category , связанные
с сущностью Item , не будут подключены предыдущим фрагментом кода вмес-
те с сущностью Item . Но такое поведение можно изменить с помощью атрибута
cascade аннотаций @OneToOne , @OneToMany , @ManyToOne и @ManyToMany . Атрибут
cascade должен добавляться в аннотацию на стороне владельца отношения. Если
атрибуту cascade присвоить значение ALL или MERGE , связанные сущности будут
подключаться автоматически. Например, следующий фрагмент подключит сущ-
ность Seller , связанную с сущностью Item , потому что атрибуту cascade при-
своено значение MERGE :

public class Item {
  @ManyToOne(cascade=CascadeType.MERGE)
  public Seller getSeller() {

Нужно признать, что антишаблон DTO в свое время был необходимым злом из-за сущнос-
тей-компонентов. Однако с выходом EJB 3 отключенные сущности превратились в POJO
и надобность в антишаблоне DTO исчезла. Вместо того, чтобы создавать отдельные DTO
для передачи предметных данных между уровнями прикладной логики и представления,
для этой цели достаточно использовать отключенные сущности.


10.2.4. Удаление сущностей

Метод deleteItem компонента ItemManagerBean , определение которого приво-
дится ниже, удаляет сущность Item из базы данных. Обратите внимание на одну
важную особенность: перед удалением сущность Item подключается к контексту
сохранения вызовом метода merge объекта EntityManager :

public void deleteItem(Item item) {
  entityManager.remove(entityManager.merge(item));
}

Объясняется это тем, что метод remove может удалять только подключен-
ные сущности, а методу deleteItem передается отключенная сущность Item .
Если методу remove передать отключенную сущность, он возбудит исключение
IllegalArgumentException . Перед тем, как метод deleteItem вернет управле-
ние, запись, соответствующая указанной сущности, будет удалена из базы данных
с помощью инструкции DELETE

(*) Как и в случае с методами persist и merge , инструкция DELETE необязательно
будет выполнена немедленно – гарантируется лишь, что она будет выполнена в
некоторый момент. Однако EntityManager отметит сущность как удаленную и
последующие попытки изменить ее потерпят неудачу


*. Каскадирование операций удаления

Так же как при подключении и сохранении сущностей, чтобы обеспечить каскад-
ное удаление сущностей, связанных отношениями с указанной, атрибуту cascade
аннотаций отношений следует присвоить значение ALL или REMOVE . Например,
ниже показано, как указать, что сущность BillingInfo , связанная с сущностью
Bidder , должна удаляться вместе с родительской сущностью Bidder :

@Entity
public class Bidder {
  @OneToOne(cascade=CascadeType.REMOVE)
  public BillingInfo setBillingInfo() {

Если рассуждать логически, в этом есть определенный смысл. Нет никаких
причин хранить сущность BillingInfo после удаления родительской сущности
Bidder . Вообще говоря, необходимость каскадного удаления определяется пред-
метной областью. Часто такой способ удаления имеет смысл только для отноше-
ний «один к одному» и «один ко многим». Но даже для этих отношений следует
проявлять осторожность, применяя каскадное удаление, потому что связанные
сущности также могут быть связаны отношениями с другими сущностями.


*. Обслуживание отношений

Если вам действительно необходимо обеспечить каскадное удаление сущнос-
тей Item , связанных с удаляемой сущностью Seller , необходимо сначала обойти
в цикле все экземпляры Category , ссылающиеся на удаляемые сущности Item , и
разорвать связь, как показано ниже:

(*) Обратите внимание: здесь имеются в виду не категории в базе данных, а 
уже извлеченные сущности Category, хранящиеся в памяти приложения.

List<Category> categories = getAllCategories();
List<Item> items = seller.getItems();
for (Item item: items) {
  for (Category category: categories) {
    category.getItems().remove(item);
  }
}

entityManager.remove(seller);


Этот код извлечет все экземпляры Category в системе и удалит все ссылки
на сущности Item , связанные с удаляемой сущностью Seller из списков ссылок.
Затем он удалит указанную сущность Seller и связанные с ней сущности Item .

--//--


10.3. Запросы сущностей

В JPA имеется несколько разных способов выполнения запросов, от JQL
до Criteria API, низкоуровневые запросы SQL и запросы к хранимым процедурам.

До настоящего момента мы извлекали сущности с помощью метода find экземп-
ляра EntityManager . Метод find позволяет выполнять запросы, извлекающие
сущности по первичному ключу. Хотя это и удобно, но часто бывает желательно
выполнить поиск по каким-то другим критериям. Для этого можно воспользо-
ваться интерфейсом javax.persistence.Query . Этот интерфейс позволяет оп-
ределять запросы, передавать им параметры, выполнять и извлекать данные по-
странично.

 - javax.persistence.Query – представляет запрос на языке JPQL или
   SQL. Для типизированных запросов возвращается экземпляр javax.
   persistence.TypeQuery<T> , избавляющий от необходимости выполнять
   приведение типов результатов.
 - javax.persistence.StoredProcedureQuery – представляет запрос, вы-
   зывающий хранимую процедуру.
 - javax.persistence.criteria.CriteriaQuery – представляет запрос,
   сконструированный с помощью метамодели.

В дополнение к запросам этих типов имеются также динамические и именован-
ные запросы. Динамические запросы – это запросы, создаваемые программно, в
процессе выполнения приложения, и передаваемые экземпляру EntityManager
для выполнения. Именованные запросы – это запросы, определяемые в аннотаци-
ях или в конфигурационных файлах ORM XML. Именованные запросы упрощают
многократное их использование и помогают избежать захламления программного
кода.


10.3.1. Динамические запросы

Динамические запросы конструируются «на лету», во время выполнения про-
граммы. Обычно динамические запросы используются однократно – то есть один
запрос не используется совместно множеством компонентов. Если у вас есть опыт
использования JDBC ( Statements или PreparedStatements ), этот подход пока-
жется вам хорошо знакомым. Динамические запросы могут включать код на языке
JPQL или SQL. Например:

@PersistenceContext
private EntityManager entityManager;
public List<Category> findAllCategories() {
  TypedQuery<Category> query = entityManager.createQuery(
    “SELECT c FROM Category c”,Category.class);
  return query.getResultList();
}

Метод findAllCategories создает экземпляр
TypedQuery , используя поддержку обобщенных типов (Generics) в Java, чтобы
избежать необходимости выполнять приведение типов результатов. После созда-
ния запроса вызывается его метод getResultList() , который выполняет запрос
и возвращает результаты. Динамические запросы можно также использовать для
выполнения инструкций на языке SQL и вызова хранимых процедур, создавая их
с помощью методов createNativeQuery и createStoredProcedureQuery , соот-
ветственно.


10.3.2. Именованные запросы

В отличие от динамических запросов, именованные запросы должны создавать-
ся заранее. Их можно определять в аннотациях или в XML-файле с настройками
объектно-реляционного отображения. Обращение к именованному запросу осу-
ществляется по его имени, что позволяет многократно использовать его в разных
программных компонентах. Именованный запрос можно определить с помощью
аннотации @javax.persistence.NamedQuery


@Entity
@NamedQuery(
  name = “findAllCategories”,
  query = “SELECT c FROM Category c WHERE c.categoryName LIKE :categoryName “)  
  public class Category implements Serializable {
    public List<Category> findAllCategories() {
      TypedQuery<Category> query =  
        entityManager.createNamedQuery(“findAllCategories”,Category.class);
    }
  }
}


В больших приложениях может потребоваться определить множество имено-
ванных запросов. В таких ситуациях можно воспользоваться аннотацией @javax.
persistence.NamedQueries


@Entity
@NamedQueries({
  @NamedQuery(
    name = “findCategoryByName”,
    query = “SELECT c FROM Category c WHERE c.categoryName 
      LIKE :categoryName order by c.categoryId”
  ),
  @NamedQuery(
    name = “findCategoryByUser”,
    query = “SELECT c FROM Category c JOIN c.user u WHERE u.userId = ?1”
)})
@Table(name = “CATEGORIES”)
public class Category implements Serializable {
  ...
}

--//--

10.4. В заключение

  ---

--//-------------------------------------------------------------------------

# Глава 11.
# JPQL

В этой главе мы подробнее исследуем операцию чтения данных с применением
языка запросов Java Persistence Query Language (JPQL), Criteria API и языка за-
просов SQL. Каждый из этих способов по-своему подходит к извлечению объектов
из реляционной базы данных и к решению разных проблем. В конце этой главы мы
рассмотрим поддержку вызова хранимых процедур – новой особенности, появив-
шейся в Java EE 7.

11.1. Введение в JPQL

Чем отличается JPQL от SQL?
(*) JPQL оперирует классами и объектами (сущностями) в пространстве Java. SQL опе-
рирует таблицами, столбцами и строками в пространстве баз данных. Хотя JPQL и SQL
очень похожи, они оперируют разными мирами.

Все запросы JPQL преобразуются в запросы SQL процессором JPQL
и затем выполняются базой данных. Процессор запросов входит в состав JPA
и обычно реализуется производителем сервера приложений

11.1.1. Типы инструкций

Типы инструкций, поддерживаемые JPQL:
1) [Выборка]   Извлекают сущности и связанные с ними данные.
2) [Изменение] Изменяют одну или более сущностей.
3) [Удаление]  Удаляют одну или более сущностей.


*. Инструкция SELECT

SELECT c
FROM Category c
WHERE c.categoryName LIKE :categoryName
ORDER BY c.categoryId

Этот запрос включает (или может включать) следующие элементы:
 - обязательную инструкцию SELECT , определяющую тип объекта, сущность
или значения, подлежащие извлечению;
 - обязательное предложение FROM , определяющее объявление сущности, ис-
пользуемой другими инструкциями;
 - необязательное предложение WHERE , выполняющее фильтрование резуль-
татов, возвращаемых запросом;
 - необязательное предложение ORDER BY , выполняющее сортировку резуль-
татов;
 - необязательное предложение GROUP BY , выполняющее агрегирование;
 - необязательное предложение HAVING , выполняющее фильтрование в соче-
тании с агрегированием.


*. Инструкции UPDATE и DELETE

Подобно языку SQL, JPQL имеет инструкции UPDATE и DELETE , вы-
полняющие изменение и удаление сущностей, и также допускают использование
предложения WHERE . Эти инструкции очень похожи на подобные им инструкции
в языке SQL. Их часто называют инструкциями массового изменения или удале-
ния, потому что в первую очередь используются для изменения и удаления мно-
жества сущностей, соответствующих определенным критериям.


*. Использование инструкции UPDATE

В инструкции UPDATE можно указать только один тип сущностей и определить
предложение WHERE , чтобы сузить круг сущностей, затрагиваемых инструкцией.
Вот как выглядит синтаксис инструкции UPDATE :

UPDATE entityName indentifierVariable
SET single_value_path_expression1 = value1, ...
single_value_path_expressionN = valueN
WHERE where_clause

В предложении SET можно использовать любые хранимые поля и поля-отноше-
ния, представляющие одиночные значения. Допустим, что мы захотели присвоить
«золотой» статус и комиссионную скидку 10% всем продавцам, фамилия кото-
рых начинается с «Packrat». Сделать это можно с помощью следующего запроса
JPQL:

UPDATE Seller s
SET s.status = ‘Gold’, s.commissionRate = 10
WHERE s.lastName like ‘Packrat%’


*. Использование инструкции DELETE

Вот как выглядит синтаксис инструкции DELETE :

DELETE entityName indentifierVariable
WHERE where_clause

Например, удалить все экземпляры сущностей, представляющие «серебряных»
продавцов, можно с помощью следующего запроса:

DELETE Seller s
WHERE s.status = ‘Silver’


11.1.2. Предложение FROM

Предложение FROM является едва ли не самым важным в языке JPQL. Оно опреде-
ляет область действия запроса – имена сущностей, на которые будет распростра-
нено действие запроса. Чтобы создать запрос, извлекающий сущности Category ,
предложение FROM следует определить так:

FROM Category c

Category – это область действия запроса, а c – это идентификатор типа Category .


*. Идентификация области действия запроса: именование сущностей

Имена сущностей, которые будут играть роль области действия запроса, можно
определять в аннотациях @Entity , с помощью атрибута name . Если атрибут name
не определен, по умолчанию ему присваивается имя класса сущности. Имя сущ-
ности должно быть уникальным в пределах единицы хранения.

В предыдущем примере предполагалось, что аннотация @Entity перед классом
Category не имеет атрибута name . Однако ничто не мешает определить другое имя
сущностей класса Category для использования в запросах:

@Entity(name = “CategoryEntity”)
public class Category

и тогда предложение FROM в запросе должно быть изменено, как показано ниже:

FROM CategoryEntity c


*. Переменные
В примере выше определена переменная c , которую можно использовать в дру-
гих инструкциях и предложениях, таких как SELECT и WHERE . В общем случае син-
таксис определения простой переменной имеет следующий вид:

FROM entityName [AS] identificationVariable

Квадратные скобки ( [] ) не являются частью синтаксиса, а лишь показывают,
что оператор AS является необязательным. Идентификатор переменной (который,
кстати, не чувствителен к регистру) должен быть допустимым идентификатором
с точки зрения синтаксиса Java и не должен совпадать с зарезервированными
идентификаторами языка JPQL


*. Выражение маршрута

В примерах запросов JPQL выше использовались выражения, такие как
c.categoryName и c.categoryId . Их называют выражениями маршрутов (path
expressions). Выражение маршрута – это переменная, за которой следует оператор
навигации ( . ) и хранимое поле или поле связи. Обычно выражения маршрутов
используются для сужения области действия запроса в предложениях WHERE или
для сортировки – в предложениях ORDER BY .
Поле связи может содержать либо единичное значение-объект, либо коллек-
цию. Поля связи, представляющие отношения «один ко многим» и «многие ко
многим» имеют тип коллекции, соответственно и выражение маршрута имеет
тип коллекции. Например, в запросе можно использовать отношение «многие ко
многим» между Category и Item для поиска всех сущностей Category , имеющих
связанные с ними объявления:

SELECT distinct c
FROM Category c
WHERE c.items isn’t EMPTY

Здесь c.items имеет тип коллекции. Такие выражения известны как выра-
жения-коллекции. Поля связи, представляющие отношения «один к одному» и
«многие к одному», имеют тип одиночного объекта, соответственно и выражение
маршрута имеет тип одиночного объекта.

С помощью выражения маршрута, имеющего тип одиночного объекта, можно
обращаться к другим хранимым полям и полям связи. Например, если допустить,
что между Category и User имеется отношение «многие к одному», используя
поле связи user в выражении маршрута можно обратиться к хранимому полю,
такому как firstName :

c.user.firstName

или, используя поле связи contactDetails , обратиться к полю email с адресом
электронной почты:

c.user.contactDetails.email

Используя выражения маршрутов, имейте в виду, что они не позволяют обра-
щаться к значениям-коллекциям хранимых полей или полей связи, как показано
в следующем примере:

c.items.itemName
или
c.items.seller

Это обусловлено отсутствием поддержки доступа к отдельным элементам
коллекций. выражение c.items.itemName на языке JPQL сродни выражению
category.getItems().getItemName() на языке Java, которое является недопус-
тимым.


*. Фильтрация с помощью предложения WHERE

требуется извлечь только экземпляры Category , соответст-
вующие некоторому условию. Например, чтобы извлечь экземпляры Category со
значением поля categoryId больше 500, этот запрос необходимо переписать, как
показано ниже:

SELECT c
FROM Category c
WHERE c.categoryId > 500

В предложении WHERE поддерживаются литералы практически всех типов язы-
ка Java, таких как boolean , float , enum , String , int и так далее. Однако вы не
сможете использовать восьмеричные и шестнадцатеричные числа, а также типы
массивов, такие как byte[] или char[] . Не забывайте, что инструкции JPQL пре-
образуются в инструкции языка SQL – именно SQL ограничивает возможность
использования типов BLOB и CLOB в предложении WHERE .


*. Передача параметров: позиционных и именованных

Как уже говорилось выше, запросы JPQL поддерживают два типа параметров:
позиционные и именованные. Далее в этой главе будет показано, как устанавли-
вать значения в этих параметрах.
В параметрах можно передавать не только числовые или строковые значения –
тип значения зависит от типа выражения маршрута в предложении WHERE . Пара-
метры могут иметь более сложные типы, такие как типы других сущностей, но в
условных выражениях допускается использовать только выражения маршрутов,
имеющие тип одиночного значения.


*. Условные операторы и выражения

Условия в предложении WHERE , осуществляющем фильтрацию результатов за-
проса, называют условными выражениями. Условные выражения можно констру-
ировать из выражений маршрутов и операторов, поддерживаемых языком. JPQL
может вычислять выражения маршрутов и сопоставлять их с числовыми, стро-
ковыми или логическими значениями с помощью операторов отношений. Ниже
приводится пример условного выражения:

c.categoryName = ‘Dumped Cars’


Типы операторов, поддерживаемые JPQL
[ Навигационные ]          .
[ Унарные ]                +, -
[ Арифметические ]         *, /, +, -
[ Операторы отношений ]    =, >, >=, <, <=, <>, [NOT] BETWEEN, [NOT] LIKE, 
                           [NOT] IN, IS [NOT] NULL, IS [NOT] EMPTY, 
                           [NOT] MEMBER [OF]
[ Логические ]             NOT, AND, OR


Сложные условные выражения могут включать другие условные выражения,
объединенные логическими операторами, такими как AND или OR . Например, вот
как можно реализовать извлечение категорий, соответствующих любому из двух
условий:

WHERE c.categoryName = ‘Dumped Cars’
OR c.categoryName = ‘Furniture from Garbage’

С выражениями маршрутов числовых типов можно использовать все типы опе-
раторов отношений. А с операндами типов String и Boolean – операторы равенст-
ва ( = ) и неравенства ( <> ).


*. Проверка на вхождение в диапазон с помощью BETWEEN

Оператор BETWEEN используется для сравнения переменной с диапазоном зна-
чений. Его можно использовать для сопоставления выражений маршрутов с ниж-
ней и верхней границами, представленными арифметическими или строковыми
выражениями, а также датами и временем, как показано ниже:

path_expression [NOT] BETWEEN lowerRange and upperRange

Допустим, что необходимо отфильтровать результаты так, чтобы значение
categoryId находилось внутри указанного диапазона. С этой целью можно ис-
пользовать предложение WHERE и именованные параметры, определяющие грани-
цы диапазона:

WHERE c.categoryId BETWEEN :lowRange AND :highRange


*. Оператор IN

Оператор IN позволяет создавать условные выражения, проверяющие вхожде-
ние значения выражения маршрута в список значений. Ниже приводится синтак-
сис оператора IN :

path_expression [NOT] IN (List_of_values)

Список может быть статическим списком значений, разделенных запятой, или
динамическим, создаваемым с помощью подзапроса. Допустим, что требуется из-
влечь только сущности User , значение поля userId в которых входит в статичес-
кий список. Эту задачу решает следующее предложение WHERE :

WHERE u.userId IN (‘viper’, ‘drdba’, ‘dumpster’)

Если потребуется определить обратное условие, то есть извлечь сущности User ,
значение поля userId в которых не входит в статический список, можно восполь-
зоваться следующим предложением WHERE :

WHERE u.userId not IN (‘viper’, ‘drdba’, ‘dumpster’)

Подзапрос – это запрос внутри запроса. Подзапросы могут возвращать единс-
твенные значения или множество значений. Давайте рассмотрим пример 
использования подзапроса в операторе IN :

WHERE c.user IN (SELECT u FROM User u WHERE u.userType = ‘A’)


*. Оператор LIKE

Оператор LIKE позволяет определять соответствие выражение маршрута типа
одиночного значения строковому шаблону и имеет следующий синтаксис:

string_value_path_expression [NOT] LIKE pattern_value_

Здесь pattern_value – это строковый литерал или входной параметр, который
может содержать символы подчеркивания ( _ ) и знаки процента ( % ). Символ под-
черкивания соответствует любому одиночному символу. Взгляните на следующее
предложение WHERE :

WHERE c.itemName LIKE ‘_ike’

Это выражение вернет TRUE для любого поля c.itemName , имеющего значение
mike , bike и так далее. Следуя этой аналогии можно сконструировать сколь угод-
но сложную строку шаблона, замещая изменяющиеся символы символом подчер-
кивания. Если строка шаблона состоит из единственного символа подчеркивания,
соответствовать ей будут только односимвольные строки.
Знак процента ( % ) соответствует любому числу символов. Если потребуется
найти все категории, названия которых начинаются с «Recycle», это можно сде-
лать с помощью следующего предложения WHERE :

WHERE c.categoryName LIKE ‘Recycle%’

Выражение будет возвращать TRUE для полей c.categoryName , имеющих, на-
пример, такие значения: «Recycle from Garbage», «Recycle from Mr. Dumpster» и
«RecycleMania – the Hulkster strikes again!».
Допустим, что нужно отфильтровать результаты так, чтобы остались только те
данные, для которых строковое выражение не соответствует шаблону. Для этого
в сочетании с оператором LIKE можно использовать оператор NOT , как показано в
следующем примере:

WHERE c.categoryName NOT LIKE ‘%Recycle%’

Выражение будет возвращать FALSE для всех полей c.categoryName , значение
которых включает слово «Recycle» в любом месте, потому что в этом шаблоне при-
сутствует два символа % – до и после слова «Recycle».


В большинстве приложений, для большей гибкости, предпочтительнее приме-
нять параметры вместо строковых литералов. С этой целью можно использовать
позиционные параметры, как показано ниже:

WHERE c.categoryName NOT LIKE ?1

Запрос с этим предложением WHERE вернет все категории, в которых значение
c.categoryName не соответствует шаблону, переданному в позиционном парамет-
ре ?1 .


*. Значения NULL и пустые коллекции

Вы должны помнить, что значение null отличается от пустой строки и в за-
просах на языке JPQL они интерпретируются по-разному. Но не все базы данных
интерпретируют значение null и пустые строки по-разному.

Когда условное выражение встречает пустое значение, оно возвращает значе-
ние null или UNKNOWN . Сложное предложение WHERE , состоящее из нескольких
условных выражений, объединенных логическими операторами, такими как AND ,
может производить пустые или неизвестные результаты.

Для проверки результата выражения, возвращающего единственное значение,
можно использовать оператор IS NULL или IS NOT NULL . Для выражения, име-
ющего пустое значение, оператор IS NULL вернет TRUE , а оператор IS NOT NULL
вернет FALSE . Например, если потребуется определить, возвращает ли выражение
маршрута непустое значение, используйте следующее предложение WHERE :

WHERE c.parentCategory IS NOT NULL

С помощью сравнения IS NULL нельзя проверить выражение, возвращающее
коллекцию. Проще говоря, IS NULL не позволяет проверить, является ли коллек-
ция пустой. Для этой цели в языке JPQL предусмотрена конструкция IS [NOT]
EMPTY . Ниже приводится предложение WHERE , которое оставит в возвращаемом
наборе только те категории, которые не содержат ни одного объявления:

WHERE c.items IS EMPTY

в языке SQL отсутствует конструкция, эквивалентная конструкции
IS EMPTY . Поэтому многим из вас будет любопытно узнать, какие инструкции SQL
генерируются оператором IS EMPTY .

сгенерированная инструкция SQL определит, возвращает ли инструкция
JOIN для указанного отношения хотя бы одну запись в подзапросе.


*. Проверка присутствия сущности в коллекции

Проверить присутствие переменной, результата выражения, возвращающего
единственное значение, или входного параметра в коллекции можно с помощью
оператора MEMBER OF , синтаксис которого показан ниже:

entity_expression [NOT] MEMBER [OF] collection_value_path_expression

Ключевые слова OF и NOT являются необязательными и их можно опустить. Ниже
приводится пример использования входного параметра с оператором MEMBER OF :

WHERE :item MEMBER OF c.items

Это условное выражение вернет TRUE , если экземпляр сущности ( :item ), пере-
данный в параметре, присутствует в коллекции c.items конкретной категории c .


*. Использование функций JPQL
 - строковые функции;
 - арифметические функции;
 - функции для работы с датами и временем.

*. Строковые функции
Если вам потребуется
выполнять какие-либо промежуточные операции с полученными данными, ис-
пользуйте для этого функции, имеющиеся в языке Java. Главная причина такой
рекомендации в том, операции со строками в памяти приложения, выполняются
намного быстрее, чем операции в базе данных .

-- CONCAT (string1, string2)
Возвращает строку, составленную из двух исходных строк.

-- SUBSTRING (string, position, length)
Возвращает подстроку в строке, начиная с позиции position и длиной length.

-- TRIM ([LEADING | TRAILING | BOTH] [trim_character] FROM] string_to_trimmed)
Отсекает указанный символ trim_character на концах исходной стро-
ки (LEADING – в начале, TRAILING – в конце или BOTH – с обоих концов). Если
символ trim_character не указан, предполагается, что удалению подле-
жат пробельные символы.

-- LOWER (string)
Возвращает строку после преобразования символов в нижний регистр.

-- UPPER (string)
Возвращает строку после преобразования символов в верхний регистр.

-- LENGTH (string)
Возвращает длину строки.

-- LOCATE (searchString, stringToBeSearched[initialPosition])
Возвращает позицию строки searchString в строке stringToBeSearched, поиск начина- 
ется с позиции initialPosition.


*. Арифметические функции
Арифметические функции редко применяются в простых CRUD-операциях,
зато они часто используются при формировании отчетов. В языке JPQL подде-
рживается только самый минимум таких функций, но некоторые производители
могут добавлять собственные инструменты, специально для создания отчетов.

-- ABS (simple_arithmetic_expression)
Возвращает абсолютное значение simple_arithmetic_expression.

-- SQRT (simple_arithmetic_expression)
Возвращает корень квадратный от simple_arithmetic_expression в виде 
значения типа double.

-- MOD (num, div)
Возвращает остаток деления num на div. от целочисленного

-- SIZE (collection_value_path_expression)
Возвращает число элементов в коллекции.


*. Функции для работы со временем
Большинство языков включает функции, возвращающие текущие дату, время
или временную метку (timestamp). Язык JPQL также предлагает ряд функций для
работы со временем

-- CURRENT_DATE
Возвращает текущую дату.

-- CURRENT_TIME
Возвращает текущее время.

-- CURRENT_TIMESTAMP
Возвращает текущую временную метку.


11.1.3. Инструкция SELECT

Инструкция SELECT может включать идентификаторы переменных, выраже-
ния маршрутов, возвращающие единственное значение, или агрегатные функции,
разделенные запятыми. В предыдущих примерах мы использовали переменные в
инструкции SELECT , как показано ниже:

SELECT c
FROM Category AS c

Здесь также можно использовать выражения маршрутов:

SELECT c.categoryName, c.createdBy
FROM Category c

Выражения в инструкции SELECT должны возвращать единственное значение.
То есть, выражения маршрутов, возвращающие коллекции, в этой инструкции не-
допустимы. Выражения маршрутов могут быть полями связи, как в предыдущем
примере, где c.createdBy – это поле связи в сущности Category .

Предыдущий запрос может возвращать повторяющиеся сущности. Чтобы пред-
отвратить появление повторяющихся данных в результате, используйте ключевое
слово DISTINCT :

SELECT DISTINCT c.categoryName, c.createdBy
FROM Category c


*. Использование выражения-конструктора в инструкции SELECT

Чтобы получить один или более экземпляров Java-объектов в инструкции
SELECT можно использовать конструктор. Эта возможность может пригодиться,
когда в запросе требуется создать экземпляры, инициализированные данными,
полученными из подзапроса:

SELECT NEW actionbazaar.persistence.ItemReport (c.categoryID, c.createdBy)
FROM Category
WHERE categoryId.createdBy = :userName

Указанный класс не обязательно должен быть сущностью или отображаться в
базу данных.

*. Агрегатные функции
В языке JPQL поддерживаются все обычные агрегатные функции: AVG , COUNT ,
MAX , MIN и SUM.

-- AVG -- тип возвращаемого значения Double
Возвращает среднее для всех значений указанного поля.

-- COUNT -- тип возвращаемого значения Long
Возвращает число результатов, возвращаемых запросом.

-- MAX -- тип возвращаемого значения Зависит от типа хранимого поля.
Возвращает максимальное значение для указанного поля.

-- MIN -- тип возвращаемого значения Зависит от типа хранимого поля.
Возвращает минимальное значение для указанного поля.

-- SUM -- тип возвращаемого значения Long или Double.
Возвращает сумму всех значений указанного поля


*. Группировка с помощью GROUP BY и HAVING

В промышленных приложениях нередко требуется объединить данные по зна-
чению некоторого хранимого поля. Если принять, что сущности User и Category
связаны отношением «один ко многим», тогда следующий запрос вернет список с
числом сущностей Category , созданных каждым пользователем c.user :

SELECT c.user, COUNT(c.categoryId)
FROM Category c
GROUP BY c.user

Этот запрос осуществляет группировку по связанной сущности. Группировку
допускается выполнять с использованием выражения, возвращающего единст-
венное значение, которое может быть хранимым полем или полем связи. При
выполнении агрегирования с использованием GROUP BY , разрешается использо-
вать только агрегатные функции. Результаты агрегированного запроса можно
фильтровать с помощью предложения HAVING . Допустим, что необходимо извлечь
информацию только о тех пользователях, которые создали более пяти сущностей
Category . Для этого достаточно лишь немного изменить предыдущий запрос:

SELECT c.user, COUNT(c.categoryId)
FROM Category c
GROUP BY c.user
HAVING COUNT(c.categoryId) > 5

Кроме того, вместе с предложением GROUP BY допускается использовать пред-
ложение WHERE :

SELECT c.user, COUNT(c.categoryId)
FROM Category c
WHERE c.createDate is BETWEEN :date1 and :date2
GROUP BY c.user
HAVING COUNT(c.categoryId) > 5

При наличии предложения WHERE в запросе, содержащем оба предложения,
GROUP BY и HAVING , этот запрос обрабатывается в несколько этапов. Сначала вы-
полняется фильтрация результатов с применением предложения WHERE . Затем к
отфильтрованным результатам применяется агрегирование, описываемое предло-
жением GROUP BY . И, наконец, применяется предложение HAVING , выполняющее
фильтрацию агрегированных результатов.


11.1.4. Управление результатами

Подзапрос – это запрос внутри запроса. Подзапросы можно использовать в пред-
ложениях WHERE , HAVING и GROUP BY для фильтрации результатов. В отличие от
SQL, JPQL в EJB 3 не поддерживает подзапросы в предложении FROM . Подзапро-
сы всегда выполняются первыми и только потом выполняется главный запрос,
использующий результаты, возвращаемые подзапросом.


*. Использование оператора IN с подзапросами

SELECT i
FROM Item i
WHERE i.user IN (SELECT c.user
FROM Category c
WHERE c.categoryName LIKE :name)

В этом запросе сначала выполняется подзапрос в скобках, возвращающий спи-
сок пользователей, а затем выясняется, входит ли значение выражения i.item в
список.


*. Оператор EXISTS

Оператор EXISTS (или NOT EXISTS ) помогает узнать, возвращает ли подзапрос
какие-нибудь результаты. Если подзапрос возвращает хотя бы один результат, опе-
ратор EXISTS вернет TRUE , в противном случае будет возвращено значение FALSE .

SELECT i
FROM Item i
WHERE EXISTS (SELECT c FROM Category c WHERE c.user = i.user)


*. Операторы ANY, ALL и SOME

Операторы ANY , ALL и SOME своим действием напоминают оператор IN . Их мож-
но использовать в комбинации с любыми операторами сравнения чисел, такими
как: = , > , >= , < , <= и <> .
Ниже приводится пример, демонстрирующий применение оператора ALL к под-
запросу:

SELECT c
FROM Category c
WHERE c.createDate >= ALL
(SELECT i.createDate FROM Item i WHERE i.user = c.user)

Оператор ALL возвращает TRUE , если все результаты, возвращаемые подзапро-
сом, соответствуют условию; в противном случае он возвращает FALSE .


11.1.5. Соединение сущностей
Если у вас есть опыт использования реляционных баз данных и SQL, вы долж-
ны быть знакомы с оператором соединения JOIN . Его можно использовать, чтобы
получить декартово произведение двух сущностей. Обычно оператор JOIN сопро-
вождается предложением WHERE , определяющим условие соединения сущностей


*. Внутренние соединения
Часто в приложениях возникает необходимость выполнить соединение двух
или более сущностей, опираясь на некоторое общее отношение между ними. Та-
кое соединение называется внутренним соединением и выполняется с помощью
оператора INNER JOIN

Сущности Category и User в приложении ActionBazaar связаны отношением
«многие к одному». Чтобы получить список всех пользователей, соответствую-
щих определенному критерию, можно воспользоваться следующим запросом:

SELECT u
FROM User u INNER JOIN u.Category c
WHERE u.userId LIKE ?1

Предложение INNER является необязательным. Запомните, что когда в запросе
присутствует оператор JOIN , по умолчанию подразумевается INNER JOIN , если
явно не указано предложение OUTER .


*. Внешние соединения

SELECT u
FROM User u LEFT OUTER JOIN u.Category c
WHERE u.userId like ?1

Этот запрос извлечет также все сущности User , не имеющие соответствующих сущ-
ностей Category . Следует заметить, что если бы использовалось не внешнее соедине-
ние, запрос вернул бы только пользователей, имеющих соответствующие категории.


*. Оператор FETCH JOIN
В типичном приложении для коммерции может потребоваться запросить оп-
ределенную сущность и одновременно извлечь связанные сущности. Например,
одновременно с сущностью Bid в приложении ActionBazaar может понадобиться
извлечь и инициализировать связанный экземпляр покупателя. Для этой цели в
JPQL имеется оператор FETCH JOIN :

SELECT b
FROM Bid b FETCH JOIN b.bidder
WHERE b.bidDate >= :bidDate

Такой способ выборки часто бывает удобно использовать, когда включен ре-
жим отложенной загрузки отношений, но в данном конкретном запросе требуется
обеспечить немедленную загрузку. Оператор FETCH JOIN можно использовать и
во внутренних, и во внешних соединениях.

*. Тета-соединения
Тета-соединения редко используются на практике, и основаны на соединении
сущностей по произвольным хранимым полям или полям связи, а не на отноше-
ниях между ними.

Допустим, что имеются
сущности обоих типов, хранящие в этих полях общие значения, такое как GOLD , и
требуется реализовать их соединение по полям rating и star . Эту задачу решает
следующий запрос:

SELECT i
FROM Item i, Category c
WHERE i.star = c.rating


11.1.6. Операции массового удаления и изменения

@PersistenceContext em;
...
// начало транзакции
Query query = em.createQuery(“DELETE USER u WHERE u.status = :status “);
query.setParameter(“status”, ‘GOLD’);
int results = query.executeUpdate();
// конец транзакции

Порядок использования инструкций UPDATE и DELETE , как показано в этом
фрагменте, близко напоминает использование любых других инструкций JPQL,
кроме двух важных отличий. Во-первых, для выполнения массового изменения
или удаления вместо метода getResultList или getSingleResult используется
метод executeUpdate интерфейса Query . Во-вторых, метод executeUpdate дол-
жен вызываться внутри активной транзакции


11.2. Запросы Criteria
Запросы JPQL являются чрезвычайно мощным инструментом, но этот инстру-
мент все еще опирается на простые текстовые строки, встроенные в программный
код на Java, которые интерпретируются только во время выполнения программы.
Это означает, что успешные компиляция и развертывание приложения не гаран-
тируют отсутствие в запросах синтаксических ошибок. Единственный способ убе-
диться в корректности запросов – выполнить каждый из них в модульных или
интеграционных тестах.
Criteria API – механизма создания типизированных запросов.


Поиск объявления по названию товара с использованием Criteria API

public List<Item> findItemByName(String name) {
  // Получить экземпляр CriteriaBuilder от EntityManager
  CriteriaBuilder builder = entityManager.getCriteriaBuilder();
  
  // Создать новый экземпляр запроса CriteriaQuery для поиска объявления
  CriteriaQuery<Item> query = builder.createQuery(Item.class);
  
  // Сконструировать запрос на основе метамодели
  Root<Item> root = query.from(Item.class);
  Predicate condition = builder.like(root.get(Item_.itemName),name);
  query.where(condition);
  TypedQuery<Item> q = entityManager.createQuery(query);
  return q.getResultList();
}


11.2.1. Метамодели

Метамодель является представлением сущностей в базе данных. Она имеет не-
которое сходство с Reflection API в языке Java и метаданными JDBC. Как и при
использовании Reflection API, с помощью метамодели можно выполнять обход
атрибутов сущностей и получать базовую информацию о них, включая имена и
типы.

Процессор аннотаций – это
модуль расширения компилятора javac , который обрабатывает аннотации на эта-
пе компиляции. В случае с JPA, он обрабатывает аннотации, а также конфигураци-
онный файл persistence.xml . Для всех классов, управляемых механизмом JPA,
генерируются файлы с исходным кодом на языке Java, которые затем компили-
руются вместе с проектом и образуют статическую метамодель, используемую во
время выполнения.

Чтобы задействовать метамодель, нужно выполнить следующие действия:
1. Снабдить POJO аннотациями JPA.
2. Скомпилировать код, задействовав в процедуре компиляции процессор
мета моделей.
3. Реализовать Criteria-запросы с использованием сгенерированных классов.
4. При изменении модели повторить предыдущие этапы.

*. Процессор аннотаций
Вам потребуется настроить процедуру сборки и, возможно, среду разработки на ис-
пользование процессора метамодели. О том, как это сделать, можно узнать в докумен-
тации к вашей реализации JPA.


*. Интроспекция
Основу любой метамодели составляет интерфейс Metamodel . Получить ссыл-
ку на реализацию Metamodel можно вызовом метода getMetamodel() объекта
EntityManager . С помощью экземпляра Metamodel можно получить какую-то оп-
ределенную сущность или список всех управляемых сущностей. Информация о
любой сущности возвращается в виде экземпляра EntityType . Объект EntityType
имеет методы для получения дополнительной информации о сущности, включая
информацию об атрибутах.


*. Интерфейс Metamodel

public interface Metamodel {
  // Извлекает информацию об управляемой сущности в виде EntityType
  public <X extends Object> EntityType<X> entity(Class<X> type);
  public <X extends Object> ManagedType<X> managedType(Class<X> type);
  public <X extends Object> EmbeddableType<X> embeddable(Class<X> type);
  public Set<ManagedType<?>> getManagedTypes();
  
  // Извлекает список экзепляров EntityType для всех управляемых сущностей
  public Set<EntityType<?>> getEntities();
  public Set<EmbeddableType<?>> getEmbeddables();
}


*. Интроспекция с помощью интерфейса Metamodel во время выполнения

// Получить метамодель с помощью EntityManager
Metamodel metaModel = entityManager.getMetamodel() ;
// Получить множество всех управляемых классов в текущей единице хранения
Set<EntityType<? extends Object>> types = metaModel.getEntities();
for(EntityType<? extends Object> type : types) {
  // Вывести имя сущности
  logger.log(Level.INFO, “--> Type: {0}”, type);
  // Получить список типов атрибутов сущности
  Set attributes = type.getAttributes();
  for(Object obj : attributes) {
    // Вывести имя атрибута
    logger.log(Level.INFO, “Name: {0}”, ((Attribute)obj).getName());
    // Вывести TRUE, если атрибут является коллекцией
    logger.log(Level.INFO, “isCollection: {0}”,
      ((Attribute)obj).isCollection());
  }
}


*. Сгенерированный код
Процессор аннотаций сгенерирует класс метамодели для каждой управляемой
сущности. Сгенерированные классы получат те же имена, с дополнительным сим-
волом подчеркивания _ в конце. Сгенерированные классы будут отмечены анно-
тацией @Static-Metamodel.

атрибуты экземпляра клас-
са метамодели, генерируемые в зависимости от типов соответствующих атрибутов
сущности.

public static volatile SingularAttribute<X, Y> y;     Для атрибута, не являюще-
                                                      гося коллекцией.
public static volatile CollectionAttribute<X, Z> z;   java.util.Collection
public static volatile SetAttribute<X, Z> z;          java.util.Set
public static volatile ListAttribute<X, Z> z;         java.utilList
public static volatile MapAttribute<X, K, Z> z;       java.util.Map


класс метамодели, сгенерированный процессором
аннотаций для класса сущности Item в приложении ActionBazaar.

package com.actionbazaar.model;
// Тег, вставляемый автоматически;
// данный пример сгенерирован с помощью EclipseLink
@Generated(value=”EclipseLink-2.5.0.v20130321-rNA”,
  date=”2013-04-12T18:02:56”)
// Отмечает класс, являющийся частью статической метамодели
// и отображаемый в управляемую сущность
@StaticMetamodel(Item.class)
// Имя управляемой сущности с символом подчеркивания в конце
public class Item_ {
  // Простой атрибут, представляющий одиночное значение
  public static volatile SingularAttribute<Item, byte[]> picture;
  public static volatile SingularAttribute<Item, String> itemName;
  // Отношение “многие ко многим”
  public static volatile SetAttribute<Item, Category> category;
  public static volatile SingularAttribute<Item, BigDecimal> initialPrice;
  public static volatile SingularAttribute<Item, Date> bidEndDate;
  public static volatile SingularAttribute<Item, String> description;
  // Отношение “один ко многим”
  public static volatile ListAttribute<Item, Bid> bids;
  public static volatile SingularAttribute<Item, Long> itemId;
  public static volatile SingularAttribute<Item, Date> createdDate;
  // Отношение “многие к одному”
  public static volatile SingularAttribute<Item, BazaarAccount> seller;
  public static volatile SingularAttribute<Item, Date> bidStartDate;
}

статические свойства, которые обеспечивают ста-
тическую типизацию при построении запроса. В Criteria API широко используют-
ся обобщенные типы, которые в сочетании со статическими классами гарантиру-
ют синтаксическую корректность запросов.


11.2.2. CriteriaBuilder

Класс CriteriaBuilder является одной из основ Criteria API. Он отвечает
за констру ирование запросов: стыковку переменных, выражений, предикатов
и предложений сортировки. Это фабричный класс, используемый для созда-
ния запросов на основе статической метамодели. Получить ссылку на экземп-
ляр CriteriaBuilder можно вызовом метода getCriteriaBuilder() объекта
EntityManager

Тип запроса определяет тип ожидаемого возвращаемого значения. Этот тип не-
обязательно должен быть типом управляемой сущности. Например, при констру-
ировании запроса, вычисляющего среднее значение от всех ставок для определен-
ного объявления, можно передать Long.class . Точно так же, как было показано
в примере создания инструкции SELECT , можно указать объект-обертку, не явля-
ющийся управляемой сущностью, а используемый только для промежуточного
хранения результатов.

перечислены пять
разных типов запросов, которые можно создавать с помощью CriteriaBuilder .

-- createQuery ()
Создает новый объект Criteria-запроса.

-- createQuery (java.lang.Class<T> resultClass)
Создает новый объект Criteria-запроса с определенным типом возвращаемого
значения.

-- createTupleQuery ()
Создает новый объект Criteria-запроса, возвращающего кортеж результатов.

-- createCriteriaDelete (Class<T> targetEntity)
Создает новый объект Criteria-запроса, выполняющего массовое удаление.

-- createCriteriaUpdate (Class<T> targetEntity)
Создает новый объект Criteria-запроса, выполняющего массовое изменение.


*. Экземпляр CriteriaBuilder предоставляет также фабричные методы для со-
здания выражений, предложений сортировки, инструкций выборки и предикатов.


11.2.3. CriteriaQuery

Объект CriteriaQuery является еще одной из основ Criteria API. Он стыкует
между собой отдельные элементы – SELECT , FROM и необязательное предложение
WHERE – конструируя объектное представление SQL-запроса. Механизм JPA ис-
пользует это объектное представление для создания инструкций SQL. Затем JPA
выполняет полученную инструкцию, передавая ее базе данных, и упаковывает ре-
зультат в форму объекта, указанного при создании запроса.

Создание объектов CriteriaQuery выполняется с помощью интерфейса
CriteriaBuilder , который мы рассмотрели в предыдущем разделе. Интерфейс
CriteriaBuilder используется также для конструирования отдельных элемен-
тов запросов, которые затем передаются методам экземпляра CriteriaQuery . Вы
можете использовать CriteriaBuilder как фабрику для создания любых необхо-
димых элементов запросов.


*. Основные методы интерфейса CriteriaQuery

-- groupBy
Создает SQL-предложение GROUP BY.

-- having
Создает SQL-предложение HAVING.

-- multiselect
Создает запрос с множеством выбираемых элементов.

-- orderBy
Создает SQL-предложение ORDER BY.

-- select
Создает запрос с единственным выбираемым элементом.

-- where
Создает SQL-предложение WHERE.


11.2.4. Корень запроса

Корень запроса (query root) – это одна из самых сложных для описания абстрак-
ций. Корень запроса определяет начальную точку для навигации – сущности,
содержащие свойства, которые будут использоваться при конструировании SQL-
предложений WHERE , SELECT и JOIN . Запрос может иметь ноль или более корней.
Если вы не собираетесь выполнять соединение нескольких таблиц, определять
конкретные извлекаемые свойства или применять ограничения к извлекаемым
значениям, корень запроса можно не создавать. Говоря иными словами, корень
запроса – это объект, используемый при конструировании выражений.

Создать корень запроса можно вызовом метода from экземпляра CriteriaQuery .
Несмотря свое имя, метод from не используется для формирования SQL-пред-
ложения FROM ; сущности автоматически добавляются в предложение FROM ,
если они используются в выражениях. Возвращаемый объект имеет тип javax.
persistence.criteria.Root . Далее этот объект можно использовать при конс-
труировании выражений.


*. Извлечение названий всех товаров с помощью корня запроса

public List<String> getAllItemsNames() {
  CriteriaBuilder builder = entityManager.getCriteriaBuilder();
  // Создать CriteriaQuery; результатом запроса будет строка
  CriteriaQuery<String> query = builder.createQuery(String.class);
  // Создать корень запроса типа Item;
  // он будет использоваться для навигации
  Root<Item> root = query.from(Item.class);
  // Использовать объект Root, выбрать свойство itemName
  query.select(root.get(Item_.itemName));
  TypedQuery<String> tq = entityManager.createQuery(query);
  return tq.getResultList();
}

Код в этом листинге произведет следующий запрос SQL:
[ SELECT ITEM_NAME FROM ITEMS ]


*. Выражения
Выражения используются в предложениях SELECT , WHERE и HAVING . С помо-
щью выражений определяется, что должен возвращать запрос и какие ограниче-
ния должны быть учтены при выполнении запроса. Все выражения реализуют
интерфейс javax.persistence.criteria.Expression<T> . Существует несколь-
ко особенно примечательных дочерних интерфейсов, включая Predicate , Join и
Path . Получить экземпляр выражения можно вызовом одного из вспомогатель-
ных методов экземпляра CriteriaBuilder . Обратите внимание, что во многих
случаях для создания выражений вам придется использовать другие выраже-
ния.

Predicate lessThanOrEqualTo(Expression<? extends Y> x, Expression<? extends Y> y)


Извлечение объявлений, размещенных в определенный промежуток времени

public List<Item> findByDate(Date startDate , Date endDate) {
  CriteriaBuilder builder = entityManager.getCriteriaBuilder();
  CriteriaQuery<Item> query = builder.createQuery(Item.class);
  // Создать корень запроса, ссылающийся на объекты Item
  Root<Item> itemRoot = query.from(Item.class);
  // Сконструировать выражение Path,
  // использующее метамодель для ссылки на созданные данные
  Path<Date> datePath = itemRoot.get(Item_.createdDate);
  // Сконструировать предикат, отбирающий объявления
  // с датой создания в указанном диапазоне
  Predicate dateRangePred = builder.between(datePath,
  startDate, endDate);
  query.where(dateRangePred);
  TypedQuery<Item> q = entityManager.createQuery(query);
  return q.getResultList();
}

В результате выполнения кода в листинге, базе данных будет на-
правлен следующий запрос:

SELECT ITEM_ID, BID_END_DATE, BID_START_DATE, CREATEDDATE, DESCRIPTION,
INITIAL_PRICE, ITEM_NAME, PICTURE, STARRATING, SELLER_ID
FROM ITEMS
WHERE (CREATEDDATE BETWEEN ? AND ?)


*. Соединения

Интерфейс Criteria API поддерживает возможность соединения классов, свя-
занных отношениями. При этом по умолчанию используется внутреннее соедине-
ние. Соединение выполняется либо по объекту Root , либо по объекту Join . Оба
объекта обладают методом join , способным принимать атрибут из метамодели,
имеющий единственное значение или хранящий коллекцию: SingularAttribute ,
CollectionAttribute , SetAttribute , ListAttribute или MapAttribute .

Получение сводной информации по выигравшей ставке с помощью
соединений

public List<WinningBidWrapper> getWinningBid(Long itemId) {
  CriteriaBuilder builder = entityManager.getCriteriaBuilder();
  CriteriaQuery<WinningBidWrapper> query =
    builder.createQuery(WinningBidWrapper.class);

  Root<Item> itemRoot = query.from(Item.class);
  Root<Order> orderRoot = query.from(Order.class);
  Root<Bid> bidRoot = query.from(Bid.class);
  Root<BazaarAccount> userRoot = query.from(BazaarAccount.class);

  // Выполнить внутреннее соединение по сущностям Order и Bid
  Join<Order,Bid> j1 = orderRoot.join(Order_.bid);
  // Выполнить внутреннее соединение по сущностям Order и Item
  Join<Order,Item> j2 = orderRoot.join(Order_.item);
  // Выполнить внутреннее соединение по сущностям Order и BazaarAccount
  Join<Order,BazaarAccount> j3 = orderRoot.join(Order_.bidder);

  Path<Long> itemIdPath = itemRoot.get(Item_.itemId);

  // Создать объект Path для использования в предикате и
  // конструирования предложения WHERE, чтобы обеспечить
  // извлечение только интересующего объявления
  Predicate itemPredicate = builder.equal(itemIdPath,itemId);
  query.where(itemPredicate);

  // Определить список полей для создания объекта-обертки,
  // включив в него только необходимые поля
  query.select(
    builder.construct(
      WinningBidWrapper.class,
      userRoot.get( BazaarAccount_.username ),
      bidRoot.get( Bid_.bidPrice ),
      itemRoot.get(Item_.itemName) ,
      itemRoot.get(Item_.description)
  ));
  TypedQuery<WinningBidWrapper> q = entityManager.createQuery(query);
  return q.getResultList();
}

Метод getWinningBid создает запрос, выполняющий соединение выбранных
сущностей и возвращающий объект-обертку. Объект-обертка – это синтетический
объект, используемый как хранилище извлекаемых полей. По сути, он является
простым объектом передачи данных (DTO) .

В этом примере используется внутреннее соединение. Чтобы выполнить вне-
шнее соединение, методу join нужно явно передать аргумент типа JoinType . Тип
JoinType является перечислением, включающим три разновидности соединений:
INNER (внутреннее, по умолчанию), RIGHT (внешнее) и LEFT (внешнее).
Объект соединения, возвращаемый методом join , можно использовать для оп-
ределения on -условия. Метод on может принимать объект выражения или преди-
ката, сконструированный с помощью CriteriaBuilder . Ниже приводится при-
мер определения on -условия:

j2.on(builder.like(itemRoot.get(Item_.itemName),”boat”));

В Criteria API также поддерживается выборка по соединению (fetch join), бла-
годаря чему можно организовать одновременное извлечение связанных сущнос-
тей в одном запросе. Например, заказ содержит ссылку на ставку; чтобы извлечь
обе сущности одновременно, можно сконструировать следующий запрос:

orderRoot.fetch(Order_.bid,JoinType.INNER);


11.2.5. Предложение FROM

Предложение FROM создается динамически прикладным интерфейсом Criteria
API, на основе созданных перед этим корней запроса и соединений. То есть, вам
не придется явно определять предложение FROM – все необходимое будет сделано
автоматически. Механизм JPA найдет корни запроса и соединения, и на их основе
сконструирует предложение FROM .


11.2.6. Предложение SELECT

Метод select позволяет извлекать данные в разных представлениях, в зави-
симости от потребностей. При этом вы не ограничены извлечением только лишь
сущностей JPA – вы можете извлекать сущности, одиночные значения, множества
значений и, как было показано выше, синтезировать новые объекты из результа-
тов запросов. Вы можете также работать с кортежами – упорядоченными спис-
ками значений – если не желаете тратить время на обдумывание и определение
объектов-оберток.


*. Выборка сущностей

Самый простой случай использования метода select – выборка сущностей.
Чтобы выбрать сущность, методу select нужно передать объект Root для сущ-
ности. Как это сделать, показано в следующем фрагменте:

CriteriaBuilder builder = entityManager.getCriteriaBuilder();
CriteriaQuery<Item> query = builder.createQuery(Item.class);
Root<Item> root = query.from(Item.class);
query.select(root);
TypedQuery<Item> tq = entityManager.createQuery(query);

Этот фрагмент не требует подробных разъяснений. Объект Root передается в
вызов метода select – в результате мы получаем список объявлений без необхо-
димости выполнять приведение типов, благодаря использованию TypedQuery .


*. Выборка одного значения

С помощью метода select можно выбирать определенные значения.
метод getAllItemsNames() , извлекающий список названий
товаров из всех объявлений, посредством прямого запроса атрибута itemName с
использованием корня запроса. Немного запутанный синтаксис использования
метамодели гарантирует, что запрашиваемое значение будет доступно в корне
запроса. Вы не сможете запросить имя пользователя, если корнем запроса будет
объявление, потому что объявление не содержит имени пользователя.

Root<Item> root = query.from(Item.class);
query.select(root.get(Item_.itemName));


*. Выборка нескольких значений

Следующий логический шаг – выборка нескольких значений. Часто бывает не-
обходимо извлечь не одно, а несколько значений – обычно значение и ключ, с ко-
торым связано это значение. Для этого нужно создать экземпляр CriteriaQuery
с параметром типа Object[] . Затем с помощью экземпляра CritieriaBuilder
создать экземпляр CompoundSelection и указать значения, какие требуется из-
влечь. Значениями являются атрибуты любых извлекаемых экземпляров – если
выполняется соединение нескольких таблиц, значения можно брать из соедине-
ния. Запрос возвращает массив объектов

фрагмент, возвращающий itemId вместе с itemName – что гораздо по-
лезнее, чем извлечение одного только названия:

CriteriaQuery<Object[]> query = builder.createQuery(Object[].class);
Root<Item> root = query.from(Item.class);
query.select(builder.array(root.get(Item_.itemId),
root.get(Item_.itemName)));
TypedQuery<Object[]> tq = entityManager.createQuery(query);


*. Выборка объектов-оберток
Работа с массивами объектов представляет довольно сложную проблему, хотя
бы потому, что ошибки обнаруживаются только во время выполнения. Кроме того,
по ошибке можно обратиться не к тому элементу массива. Например, в зависи-
мости от типа данных, при извлечении ставок в некотором диапазоне дат, можно
выбрать не тот элемент массива из-за «ошибки смещения индекса». Используя
объекты-обертки можно конструировать объекты специально для обработки ре-
зультатов запроса.

(*) Указываемый класс является обычным POJO – он не обязан
быть сущностью JPA

query.select(
  builder.construct(
    // Класс, на основе которого создается экземпляр
    // для каждой строки в результате
    WinningBidWrapper.class,
    // Первый параметр конструктора
    userRoot.get( BazaarAccount_.username ),
    // Второй параметр конструктора
    bidRoot.get( Bid_.bidPrice ),
    // Третий параметр конструктора
    itemRoot.get(Item_.itemName) ,
    // Четвертый параметр конструктора
    itemRoot.get(Item_.description)
));


*. Выборка кортежей
Criteria API предоставляет поддержку извлечения результатов в виде
кортежей. Кортеж – это упорядоченный список элементов, в данном случае – ре-
зультатов. Используя метамодель, вы определяете, какие значения должны быть
выбраны, и затем извлекаете отдельные значений из кортежа. Вы можете также
извлекать значения по строковым ключам, идентификаторам, и так далее.

public List<Tuple> getWinningBidTuple(Long itemId) {
  CriteriaBuilder builder = entityManager.getCriteriaBuilder();
  // Создать новый экземпляр CriteriaBuilder? типизированный как кортеж
  CriteriaQuery<Tuple> query = builder.createTupleQuery();
  Root<Item> itemRoot = query.from(Item.class);
  Root<Order> orderRoot = query.from(Order.class);
  Root<Bid> bidRoot = query.from(Bid.class);
  Root<BazaarAccount> userRoot = query.from(BazaarAccount.class);
  Join<Order,Bid> j1 = orderRoot.join(Order_.bid);
  Join<Order,Item> j2 = orderRoot.join(Order_.item);
  Join<Order,BazaarAccount> j3 = orderRoot.join(Order_.bidder);
  Path<Long> itemIdPath = itemRoot.get(Item_.itemId);
  Predicate itemPredicate = builder.equal(itemIdPath,itemId);
  // Выбрать атрибуты для кортежа
  query.multiselect(
    userRoot.get( BazaarAccount_.username ),
    bidRoot.get( Bid_.bidPrice ),
    itemRoot.get(Item_.itemName) ,
    itemRoot.get(Item_.description));
  // Создать кортеж TypedQuery
  TypedQuery<Tuple> q = entityManager.createQuery(query);
  query.where(itemPredicate);
  // Выполнить запрос и получить результаты в виде кортежа
  List<Tuple> results = q.getResultList();
  for(Tuple result : results) {
    logger.log(Level.INFO, “Item: {0}”,
      // Извлечь значение из кортежа
      result.get(itemRoot.get(Item_.itemName)));
  }
  return q.getResultList();
}

--//--


11.3. Низкоуровневые запросы

Это – запросы на языке SQL, понятном конкретному серверу баз данных: Oracle ,
MySQL , Derby , и так далее.
Низкоуровневые запросы, дают возможность использовать
конкретный диалект языка SQL и отказаться от промежуточного слоя, осущест-
вляющего трансляцию.

(*) Примечание. Механизм JPA выполняет SQL-запросы, как инструкции JDBC, и не сле-
дит за тем, изменились ли данные, которые также хранятся в каких-либо активных сущ-
ностях. Желательно избегать использовать SQL-инструкции INSERT, UPDATE и DELETE в
низкоуровневых запросах, потому что механизм хранения не имеет возможности узнать
о произведенных изменениях в базе данных, что может привести к рассогласованию
данных в сущностях, если ваша реализация JPA использует кэширование.


11.3.1. Динамические SQL-запросы

Создать динамический SQL-запрос можно с помощью метода createNativeQuery
интерфейса EntityManager , как показано ниже:


Query q = em.createNativeQuery(“SELECT user_id, first_name, last_name “
          + “ FROM users WHERE user_id IN (SELECT seller_id FROM “
          + “items GROUP BY seller_id HAVING COUNT(*) > 1)”,
           actionbazaar.persistence.User.class);
return q.getResultList();


Как видно в этом примере, метод createNativeQuery принимает два парамет-
ра: SQL-запрос и класс сущности, которая должна быть возвращена. Это обстоя-
тельство может превратиться в проблему, если потребуется вернуть несколько
сущностей разных классов. В таких ситуациях JPA позволяет использовать анно-
тацию @SqlResultSetMapping в паре с методом createNativeQuery . Аннотация
@SqlResultSetMapping описывает отображение получаемых результатов в одну
или более сущностей.
Например, ниже показано, как с помощью аннотации @SqlResultSetMapping
определить отображение для сущности User :


@SqlResultSetMapping(name = “UserResults”,
  entities = @EntityResult(
    entityClass = actionbazaar.persistence.User.class))

и использовать его в низкоуровневом запросе:

Query q = em.createNativeQuery(“SELECT user_id, first_name, last_name “
          + “ FROM users WHERE user_id IN (SELECT seller_id FROM “
          + “items GROUP BY seller_id HAVING COUNT(*) > 1)”,
            “UserResults”);

return q.getResultList();


11.3.2. Именованные SQL-запросы

Своими особенностями использования именованные SQL-запросы очень похожи
на именованные запросы JPQL. Прежде чем использовать именованный запрос,
его необходимо создать. Определить именованный SQL-запрос можно с помощью
аннотации @NamedNativeQuery :

public @interface NamedNativeQuery {
  String name();
  String query();
  QueryHint[] hints() default {};
  Class resultClass() default void.class;
  String resultSetMapping() default “”; // имя SQLResultSetMapping
}


ип результата можно определить как класс сущности или как отображение,
объявленное с помощью аннотации @NamedNativeQuery . Допустим, что нам пот-
ребовалось преобразовать запрос из примера выше в именованный SQL-запрос.
Первым шагом нужно определить именованный запрос, возвращающий сущность
User :

@NamedNativeQuery(
  name = “findUserWithMoreItems”,
  query = “SELECT user_id , first_name , last_name, birth_date
           FROM users
           WHERE user_id IN
             ( SELECT seller_id
               FROM items
               GROUP BY seller_id HAVING COUNT(*) > ?)”,
  hints = {@QueryHint(name = “toplink.cache-usage”, 
                      value=”DoNotCheckCache”)},
                      resultClass = actionbazaar.persistence.User.class)


Затем, если запрос возвращает более сущности разных классов, нужно опреде-
лить отображение SqlResultSetMapping в атрибуте resultSetMapping , как по-
казано ниже:

@NamedNativeQuery(
  name = “findUserWithMoreItems”,
  query = “SELECT user_id , first_name , last_name, birth_date
           FROM users
           WHERE user_id IN
             (SELECT seller_id
              FROM items
              GROUP BY seller_id
              HAVING COUNT(*) > ?)”,
  resultSetMapping = “UserResults”)


как вызвать именованный SQL-запрос
findUserWithMoreItems (определенный ранее в методе сеансового компонента):

return em.createNamedQuery(“findUserWithMoreItems”)
           .setParameter(1, 5)
           .getResultList();

Эта инструкция сначала создает экземпляр именованного низкоуровневого
запроса findUserWithMoreItems . Затем определяются позиционные параметры
запроса. Наконец, запрос выполняется и возвращается полученный набор резуль-
татов.


11.3.3. Хранимые процедуры

Хранимая проце-
дура – это, по сути, сценарий, который выполняется внутри базы данных.

Хранимые процедуры близко напоминают функции – они точно так же
могут принимать параметры и возвращать данные. Данные могут возвращаться в
виде возвращаемого значения или в параметрах. Параметры могут быть типа IN ,
OUT или INOUT – параметры типа IN являются входными параметрами, параметры
типа OUT служат для возврата данных, а параметры типа INOUT одновременно яв-
ляются входными и выходными значениями.

Поддержка хранимых процедур реализована в JPA в виде объекта javax.
persistence.StoredProcedureQuery . Этот класс наследует интерфейс javax.
persistence.Query
Создать экземпляр StoredProcedureQuery можно вызовом одного из
трех методов объекта EntityManager :

StoredProcedureQuery createStoredProcedureQuery(String procedureName);
StoredProcedureQuery createStoredProcedureQuery(
  String procedureName, Class... resultClasses);
StoredProcedureQuery createStoredProcedureQuery(
  String procedureName, String... resultSetMappings);

Эти методы принимают имя процедуры а также типы результатов или отоб-
ражения. Имя процедуры – это имя процедуры, как оно определено в базе
данных.

еречислены наиболее важные методы интерфейса
StoredProcedureQuery . Эти методы используются для настройки параметров,
передаваемых процедуре. Как упоминалось выше, параметры могут использовать-
ся для передачи значений ( IN ), получения данных ( OUT ) или одновременно для
передачи и получения данных ( INOUT ). Тип ParameterMode – это перечисление,
определяющее направление передачи параметра.


-- setParameter (Parameter<T> param, T value)
Устанавливает значение параметра


-- setParameter(
--   Parameter<Calendar> param,
--   Calendar value,
--   TemporalType temporalType)
Устанавливает значение параметра Calendar


-- setParameter(Parameter<Date> param,
-- Date value,
-- TemporalType temporalType)
Устанавливает значение параметра Date

-- setParameter(String name, Object value)
Устанавливает значение параметра по его имени в виде строки


-- setParameter(String name, Calendar value, TemporalType temporalType
Устанавливает значение параметра типа Calendar по его имени в
виде строки


-- setParameter(String name, Date value, TemporalType temporalType)
Устанавливает значение параметра типа Date по его имени в виде строки

...


Предлагаемая вашему вниманию хранимая процедура
написана на языке pgSQL. Язык pgSQL – это один из нескольких языков сце-
нариев, поддерживаемых базами данных PostgreSQL – он очень похож на язык
PL/SQL.


Хранимая процедура, возвращающая число ставок для заданного
пользователя (pgSQL)

-- Определение новой функции PostgreSQL, принимающей один параметр
CREATE FUNCTION getQtyOrders(userId int) RETURNS int AS $$
DECLARE
  qty int;
BEGIN
  SELECT COUNT(*) INTO qty FROM BID WHERE bazaaraccount_user_id = userId;
  -- Вернуть целочисленный результат
  RETURN qty;
END;
$$ LANGUAGE plpgsql;

То есть, процедура имеет один входной параметр и один
результат. Входной параметр – целое число. Результат – так же целое число.


*. Вызов хранимой процедуры с помощью JPA

// Создать новый экземпляр StoredProcedureQuery
StoredProcedureQuery spq = entityManager.createStoredProcedureQuery(“getQtyOrders”);
// Зарегистрировать параметр хранимой процедуры
spq.registerStoredProcedureParameter(“param1”, Integer.class, ParameterMode.IN);
// Установить значение параметра
spq.setParameter(“param1”,userID);
Object[] count = (Object[])spq.getSingleResult();

создает экземпляр StoredProcedureQuery и затем ре-
гистрирует целочисленный параметр. Параметр регистрируется под именем
param1 , которое затем используется для установки значения. После этого про-
изводится выполнение хранимой процедуры, как самого обычного запроса, и из-
влечение результатов. Как видите, вызов хранимой процедуры не особенно отли-
чается от выполнения обычного запроса.


11.4. В заключение

  ---

--//--

--//-------------------------------------------------------------------------

# Глава 12.
# Использование CDI в EJB 3


12.1. Введение в CDI

Прародителем CDI
был открытый проект Seam, разрабатываемый компанией JBoss. Целью проекта
Seam было упрощение разработки приложений на платформе Java EE за счет под-
держки прямого обращения к компонентам EJB из JSF, а так же предоставления
компонентов – в основном компонентов Java – которые определялись бы и внед-
рялись с помощью аннотаций.

Для интеграции базовых особенностей Seam требовалось явно определить по-
нятие компонента в контексте Java EE. До версии Java EE 6 такого определения
не существовало. На тот момент имелось две разновидности компонентов: JSF-
компоненты и компоненты Enterprise Java Beans. Чтобы выработать обобщенное
определение, было введено понятие управляемого компонента с соответствующей
спецификацией. Управляемый компонент – это обычный POJO, управляемый
контейнером, который предоставляет базовый набор услуг, включая внедрение
ресурсов, события жизненного цикла и интерцепторы. Согласно спецификации
управляемый компонент должен иметь конструктор без аргументов, не должен
поддерживать сериализацию и иметь уникальное имя. Управляемые компоненты
определяются посредством аннотации @ManagedBean и могут иметь методы обрат-
ного вызова для обработки событий жизненного цикла, отмеченные аннотациями
@PostConstruct и @Destroy . Некоторые требования, такие как наличие конструк-
тора без аргументов, могут ослабляться применением расширений. Компоненты
EJB, JSF и CDI – все это расширения управляемых компонентов.


12.1.1. Службы CDI

CDI предоставляет ряд базовых услуг, основанных на таких понятиях, как кон-
тексты и внедрение зависимостей. Контексты, подробное определение которых
будет дано ниже, можно интерпретировать как четко определенные области
действия, связанные с жизненным циклом. В предыдущих главах вы уже видели,
как действует внедрение зависимостей, но CDI поднимает DI на новый уровень.
Преж де мы использовали механизм внедрения зависимостей, встроенный в EJB 3,
для внедрения объектов подключения к базе данных, контекстов хранения JPA и
ссылок на другие компоненты EJB. Делали мы это с помощью специальных ан-
нотаций, таких как @Resource , @PersistenceContext и @EJB . В EJB 3 механизм
внедрения зависимостей ограничивается только компонентами EJB – вы не смо-
жете выполнить внедрение чего-либо в произвольный POJO или внедрить прос-
той объект в компонент EJB. В CDI подобные ограничения отсутствуют, в чем вы
вскоре убедитесь.

CDI – это контейнер объектов, который можно использовать отдельно или внут-
ри имеющегося контейнера Java EE. Прежде мы уже затрагивали две основные
особенности CDI, однако коме них, контейнер CDI поддерживает возможность
управления жизненным циклом объектов с сохранением состояния, связывания
объектов с четко определенными контекстами, осуществления типизированного
внедрения зависимостей, уведомления о событиях, а также надежные интерцепто-
ры.


*. Жизненный цикл объектов с сохранением состояния

Контейнер CDI поддерживает четко определенный жизненный цикл для под-
контрольных ему компонентов. CDI – это расширение спецификации управляе-
мых компонентов, которая предусматривает возможность определения обработ-
чиков для управления созданием новых объектов и уничтожением существующих.

CDI расширяет спецификацию управляемых компонентов, добавляя новые спо-
собы их создания. В частности, смягчено требование к наличию конструктора без ар-
гументов. Под управлением CDI компоненты могут создаваться с использованием
конструкторов, принимающих аргументы, при этом параметры будут «внедряться»
в вызовы конструкторов. Кроме того, предусматривается возможность определения
специальных методов для создания экземпляров компонентов. Это открывает воз-
можность использования шаблона проектирования «Фабричный метод» для орга-
низации создания компонентов и существенно увеличивает гибкость.


*. Контексты
Понятие контекста выглядит достаточно простым, если рассматривать его на
примере типичного веб-приложения электронной коммерции. Большинство веб-
приложений имеют, по крайней мере, два контекста, или области видимости: при-
ложение и сеанс. Данные, хранящиеся в области видимости приложения , являют-
ся общими для всех – они не связаны с каким-то определенным пользователем.

Область видимости сеанса , напротив, связана с опреде-
ленным пользователем – обычно с окном браузера. Типичным примером области
видимости сеанса может служить виртуальная корзина покупателя. Корзина со-
держит покупки для каждого отдельно взятого посетителя. Данные, связанные с
конкретным пользователем, передаются между браузером и сервером либо в виде
cookies, либо в виде параметров строки запроса в URL.

CDI. Эта технология поддерживает дополни-
тельные контексты и упрощает их создание. А так как CDI является еще и кон-
тейнером, появляется возможность управления объектами в контекстах, ассо-
циированных с ними. Объекты и их жизненные циклы оказываются неразрывно
связанными с контекстами. Это чрезвычайно мощная концепция; теперь большая
часть рутинных задач, которые раньше приходилось решать в приложениях, пере-
кладывается на плечи контейнера.

CDI поддерживает четыре встроенных контекста, или области видимости:
 - приложения ;
 - диалога ;
 - запроса ;
 - сеанса .

Помимо этих четырех контекстов существует еще два псевдоконтекста: область
видимости одиночного (singleton) объекта и область видимости зависимости
(dependent). Область видимости одиночного объекта – это контекст компонента-
одиночки. Область видимости зависимости – это область видимости, назначаемая
компоненту по умолчанию, если явно не была присвоена иная область видимости.
Объект, принадлежащий области видимости зависимости, создается в момент со-
здания объекта-владельца области видимости, и уничтожается вместе с уничтоже-
нием объекта-владельца.

CDI имеет расширяемую архитектуру и написав совсем немного кода, можно
реализовать поддержку собственных контекстов. Например, в CDI можно доба-
вить поддержку область видимости представления JSF.


*. Типизированное внедрение зависимостей

В отличие от других фреймворков DI, CDI не использует строковые идентифи-
каторы, чтобы выяснить, какой объект требуется внедрить. Для этого используется
информация о типах, которая поддерживается объектно-ориентированной моде-
лью языка Java. В ситуациях, когда выбор оказывается неоднозначным из-за нали-
чия нескольких объектов, соответствующих заданному типу, для уточнения выбо-
ра можно использовать квалифицирующие аннотации. Поскольку CDI использует
систему типов и аннотации, никогда не возникает сомнений в том, что будет внед-
рено в том или ином случае, и всегда гарантируется соответствие типов.


*. Уведомления о событиях

 ---

*. Интерцепторы

в CDI интерцепторы можно определять не
только для компонентов EJB, но и для любых других компонентов, управляемых
контейнером CDI. В CDI интерцепторы можно использовать с прикладными ме-
тодами компонентов, а также с методами обработки событий жизненного цикла и
таймеров.

В CDI появилась новая конструкция, тесно связанная с интерцепторами, которая
называется декораторы (decorators). Декоратор – это тот же интерцептор, но связан-
ный с определенным интерфейсом. Декоратор реализует интерфейс, методы кото-
рого будут перехватываться. То есть, декоратор – это интерцептор, обеспечивающий
перехват определенной прикладной логики. Декоратор, в отличие от интерцептора,
опирается на точное знание класса, для которого предусматривается перехват мето-
дов. Интерцептор – это универсальное решение, предназначенное для реализации
сквозной функциональности, независимой от классов, а декоратор – решение для
реализации сквозной функциональности в конкретной иерархии классов.


12.1.2. Отношения между CDI и EJB 3

Казалось бы, оба являются контейнерами объектов и, соответственно, в чем-то
дублируют функциональность друг друга. Однако это не совсем так. Компоненты
EJB по-прежнему находятся под управлением контейнера EJB. То есть, контей-
нер EJB решает все задачи, связанные с поддержкой транзакций, конкурентного
выполнения и всех остальных функциональных особенностей, о которых расска-
зывалось в предыдущих главах, а CDI управляет собственными компонентами и
предоставляет дополнительные услуги компонентам EJB. Эти две технологии не
конкурируют между собой, а дополняют друг друга. Компоненты CDI можно рас-
сматривать как контейнеры объектов, поддерживающие внедрение, события, ин-
терцепторы и контексты для объектов, которым не нужен полный комплекс услуг,
предоставляемых контейнером EJB. В этой книге мы уже очертили круг примене-
ния компонентов EJB – там, где требуется поддержка транзакций, безопасности,
и так далее. CDI – это контейнер для POJO.

Технологии CDI и EJB полностью интегрируются друг с другом. Это означает,
что компоненты EJB могут пользоваться всеми возможностями, обсуждавшими-
ся выше, включая внедрение зависимостей, уведомление о событиях, интерцепто-
рами и декораторами. Эти возможности доступны компонентам EJB всех типов:
одиночкам, с сохранением состояния, без сохранения состояния и MDB. Посколь-
ку функциональные возможности этих контейнеров все же в чем-то дублируют-
ся, возникает законный вопрос: когда следует пользоваться услугами контейнера
EJB (внедрение, интерцепторы, и так далее), а когда – аналогичными услугами
контейнера CDI. Ответ прост: всегда используйте возможности CDI, потому что
они более мощные, универсальные и не ограничиваются только поддержкой ком-
понентов EJB. Как будет показано далее, вы с легкостью сможете использовать
аннотацию @Inject вместо @EJB .

Использование компонентов EJB никогда не было таким
простым, как сейчас, – вы можете рассматривать компоненты EJB как самые обыч-
ные POJO. Кроме того, если в компоненте CDI потребуется воспользоваться до-
полнительными возможностями, можно просто добавить аннотацию @Stateless ,
@Singleton или @Stateful и превратить его в компонент EJB.
Технология CDI не является заменой EJB – это мощное расширение, причем, не
только для EJB но и для JSF.


12.1.3. Отношения между CDI и JSF 2

Благодаря CDI, практически любой объект Java можно превра-
тить в компонент, и использовать несколько разных способов для создания экзем-
пляров. Компоненты CDI можно без каких-либо затруднений использовать как
замену компонентам JSF.

--//--

12.2. Компоненты CDI

В отличие от EJB, CDI не имеет своей модели компонентов. Компонентом CDI
может быть управляемый компонент (JSF), компонент Enterprise Java Bean или
POJO. Все эти разновидности объектов могут пользоваться возможностями CDI.

Каждый компонент CDI связан с контекстом, имеет тип и может быть квалифи-
цирован. Контекст определяет жизненный цикл компонента, то есть, будет ли он
существовать только во время обработки одного запроса или станет частью более
продолжительного диалога или процесса. Одной из особенностей CDI является
использование системы типов для внедрения. Как результат, там, где другие кон-
тейнеры используют строковые имена, CDI использует типы Java. Так как ком-
понент может иметь только один тип, CDI включает механизм квалификации,
который позволяет безопасно различать экземпляры одного типа.


12.2.1. Как пользоваться компонентами CDI

Если ваш контейнер поддерживает CDI (а такая поддержка
имеется во всех современных контейнерах, совместимых с Java EE 6), вам доста-
точно будет просто добавить в приложение файл beans.xml . Этот файл служит
двум целям: он хранит настройки для CDI и служит маркером, что контейнер CDI
должен исследовать JAR-файлы на наличие компонентов. В листинге 12.1 пока-
зано содержимое пустого файла с настройками. Этот файл следует поместить в
каталог META-INF любого архива, содержащего компоненты.


*. Пустой файл с настройками beans.xml

<?xml version=”1.0” encoding=”UTF-8”?>
<beans xmlns=”http://java.sun.com/xml/ns/javaee”
  xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”
  xsi:schemaLocation=”http://java.sun.com/xml/ns/javaee
  http://java.sun.com/xml/ns/javaee/beans_1_0.xsd”>
</beans>

Компонентом CDI может быть любой POJO, присутствующий в JAR-архиве.
Обычно экземпляр компонента создается путем внедрения экземпляра или ссылки
на него из страницы JSF. Контейнер CDI сам позаботится о создании экземпляра
компонента. Создавая компоненты на
основе POJO, можно объявлять конструкторы с параметрами. Объявить можно
только один конструктор с аргументами, а его параметрами должны быть другие
компоненты CDI (POJO, управляемые компоненты JSF или компоненты EJB).


12.2.2. Именование компонентов и их разрешение в выражениях EL

В отличие от других фреймворков DI, контейнер CDI не использует строковые
идентификаторы. Вместо этого он опирается на систему типов Java, благодаря
чему внедрение зависимостей выполняется с учетом типов объектов.
Однако в выражениях на унифицированном языке EL отсутствует информация
о типах. Чтобы решить эту проблему, CDI предоставляет аннотацию @Named , кото-
рую следует помещать перед классами или фабричными методами (описываются
ниже). Данная аннотация определяет имя, которое затем можно использовать в
выражениях EL. Определение аннотации приводится ниже:

package javax.inject;
@Qualifier
@Documented
@Retention(RUNTIME)
public @interface Named {
  String value() default “”;
}

Эта аннотация имеет необязательный атрибут value , значение которого ис-
пользуется как имя компонента. Если значение атрибута value не указано, в ка-
честве имени будет использоваться имя класса. Аннотация @Named не превращает
класс в компонент CDI; она просто определяет имя для класса, которое можно
будет использоваться в выражениях EL


*. Класс Employee, отмеченный для использования в EL

@Named         // Присвоить имя в виде строки Employee
@RequestScoped // Ограничить область видимости класса запросом
public class Employee extends User implements Serializable {

  public String getTitle() {
    return title; 
  }

  public void setTitle(String title) {
    this.title = title;
  }
  ...
}

приводится определение класса Employee из приложения
ActionBazaar. Аннотация @Named применяется к классу n. Соответственно этот
класс будет доступен для использования в выражениях EL. Кроме того, область
видимости экземпляров класса Employee ограничена запросом – для обработки
каждого запроса будет создаваться новый экземпляр.

Ссылка на экземпляр Employee из файла editEmployee.xhtml

<!DOCTYPE html>
<HTML
  xmlns:f=”http://java.sun.com/jsf/core”
  xmlns:h=”http://java.sun.com/jsf/html”>
  <h:head>
    <title>Edit Employee</title>
  </h:head>
  <h:body>
    <h:form id=”accountForm”>
      <h:panelGrid columns=”2”>
      <h:outputLabel for=”title” value=”Title”/>
<!-- Обращение к свойству title экземпляра Employee в выражении EL -->
      <h:inputText id=”title” value=”#{employee.title}”/>
      <h:outputLabel for=”username” value=”User name”/>
<!-- Обращение к свойству username экземпляра Employee в выражении EL -->
      <h:inputText id=”username” value=”#{employee.username}”/>
    ...
      </h:panelGrid>
    ...
    </h:form>
  </h:body>
</HTML>


компонент Employee получил имя employee , в
соответствии с соглашениями, принятыми в Java, – первая буква имени в нижнем
регистре. Без аннотации @Named фреймворк JSF не смог бы найти компонент с
именем employee .


12.2.3. Области видимости компонентов

Выше мы уже обсудили понятия контекстов и областей видимости – эти два тер-
мина могут использоваться взаимозаменяемо. Контейнер CDI поддерживает че-
тыре контекста и два псевдоконтекста. Все компоненты связаны с определенными
контекстами, определяющими их жизненные циклы. Когда контекст уничтожа-
ется, уничтожаются и соответствующие компоненты. Область видимости (кон-
текст) компонента определяется с помощью аннотаций, которые могут помещать-
ся перед классами или фабричными методами (о которых рассказывается ниже).


-- @ApplicationScoped
Экземпляр создается только один раз с момента запуска приложе-
ния и уничтожается при его завершении.

-- @Dependent
Экземпляр создается всякий раз, когда выполняется внедрение.
Это – контекст по умолчанию и используется в подавляющем боль-
шинстве случаев.

-- @ConversationScoped
Новый тип контекстов, добавленный в CDI, но поддерживавшийся
в JBoss Seam. Это контекст, управляемый программно. Он распро-
страняется на несколько запросов, но короче контекста сеанса.
В веб-приложениях контекст диалога (conversation) используется
для выполнения операций, включающих несколько запросов. На-
пример, к таким ситуациям относится оформление пользователем
двух разных заказов в разных вкладках браузера.

-- @@RequestScoped
Этот контекст соответствует стандартному HTTP-запросу. Он со-
здается при получении запроса и уничтожается после отправки
ответа.

-- @SessionScoped
Этот контекст соответствует стандартному HTTP-сеансу. Ссылки,
созданные в этом контексте, остаются действительными до конца
сеанса.

В отсутствие аннотаций перед компонентом, он автоматически получает об-
ласть видимости зависимости (dependent). Это означает, что новый экземпляр
компонента будет создаваться всякий раз, когда выполняется внедрение этого
компонента.


*. Контекст диалога

Контекст диалога (conversation) заслуживает обсуждения в отдельном разделе.
В отличие от других областей видимости, контекст диалога – совершенно новый
зверь. Если вам приходилось пользоваться предшественником CDI, JBoss Seam
(версии 1 или 2), понятие диалога наверняка будет вам не в новинку. Диалог – это
область видимости, более короткая, чем сеанс, но более длинная, чем запрос.

Управление контекстом диалога осуществляется програм-
мно; программный код сам определяет, когда начинается диалог и когда он закан-
чивается.


Чтобы проще было понять, что такое диалог представьте, как пользователь взаи-
модействует с веб-приложением при помощи современного браузера. Покупатель
может подключиться к приложению ActionBazaar и открыть в разных вкладках
два объявления, заинтересовавшие его. Однако, даже при том, что покупатель про-
сматривает два объявления в разных вкладках, с точки зрения приложения поль-
зователь действует в рамках единственного сеанса. Как результат, информацию о
текущем просматриваемом объявлении нельзя хранить на уровне сеанса, потому
что сеанс делится между двумя вкладками. А теперь представьте, что произойдет,
если пользователь в одной вкладке будет просматривать объявление о продаже
лодки, а в другого – о продаже бриллианта в пять карат. Когда пользователь пере-
ключится во вкладку с объявлением о продаже лодки и щелкнет на кнопке Place
Bid (Сделать ставку), он будет удивлен, если на странице подтверждения ему бу-
дет предложено подтвердить ставку на покупку бриллианта. Эту проблему решает
контекст диалога.

Чтобы отметить компонент, как принадлежащий диалогу, нужно добавить ан-
нотацию @ConversationScoped к его определению. По умолчанию диалог ассоци-
ируется с текущим контекстом запроса и завершается вместе с контекстом запро-
са. Чтобы продлить срок существования контекста диалога, его нужно превратить
в контекст продолжительного диалога. Такое превращение осуществляется про-
граммно. Для этого следует получить текущий контекст диалога через внедрение
и вызвать метод begin . После этого контекст диалога может быть завершен про-
граммно или спустя установленный период времени. При этом он не может про-
должаться дольше сеанса.

--//--

12.3. Следующее поколение механизмов внедрения зависимостей

---

12.3.1. Внедрение с помощью @Inject

Аннотация @Inject составляет основу CDI. Эта аннотация отмечает точку, куда
должен быть внедрен экземпляр компонента. Она может помещаться или перед
переменной экземпляра, или перед конструктором. Когда контейнер CDI создает
экземпляр класса, содержащий поле с аннотацией @Inject , он сначала проверяет
наличие готового экземпляра, и только потом создает новый экземпляр и сохраня-
ет в поле. Важно также отметить, что если компонент не отмечен аннотацией облас-
ти видимости (например, @Conversation , @RequestScoped или @SessionScoped ),
ему по умолчанию присваивается область видимости зависимости, которую мож-
но присвоить явно, с помощью аннотации @Dependent . Контейнер CDI определяет
тип точки внедрения и с помощью возможных дополнительных квалифицирую-
щих аннотаций выясняет, какой объект требуется внедрить или сначала создать, а
затем внедрить. Все эти операции выполняются при создании первого экземпляра
компонента.


*. Компонент главной страницы

@Named             // Превращает LandingController в JSF-компонент
@ApplicationScoped // Будет создан единственный экземпляр LandingController
public class LandingController {

  // Внедрить itemManager
  @Inject
  private ItemManager itemManager;
 
  private List<Item> newestItems;
 
  // Вызывать после внедрения
  @PostConstruct
  public void init() {
    newestItems = itemManager.getNewestItems();
  }

  public List<Item> getNewestItems() {
    return newestItems;
  }

}


В центре внимания этого примера – аннотация @Inject перед полем
itemManager. Когда контейнер CDI приступит к созданию экземпляра
LandingController , он извлечет экземпляр сеансового компонента без сохране-
ния состояния ItemManager из контейнера EJB, а после внедрения вызовет метод
с аннотацией @PostConstruct. Обратите внимание, что в данном конкретном
случае с тем же успехом можно было бы использовать аннотацию @EJB . Но анно-
тация @Inject позволяет внедрять любые другие POJO, в чем вы убедитесь далее
в этой главе.


*. Внедрение параметров конструктора

@Named
@ApplicationScoped
public class LandingController {

  // Переменная экземпляра больше не отмечена аннотацией
  private ItemManager itemManager;
  
  private List<Item> newestItems;
  
  // Конструктор по умолчанию для контейнера
  // (для выполнения сериализации и т.д.)
  protected LandingController() {}

  // Конструктор с параметром отмечен аннотацией @Inject
  @Inject
  // Принимает параметр типа ItemManager
  public LandingController( ItemManager itemManager) {
    this.itemManager = itemManager;
  }
  ...

}

Использование внедрения с конструктором дает еще один способ управления
созданием компонентов. Аннотацией @Inject может быть отмечен только один
конструктор; если аннотировать несколько конструкторов, контейнер не сможет по-
нять, какой из них следует использовать. В этом определении LandingController
мы убрали аннотацию, находившуюся перед полем и добавили параметр в конс-
труктор. Конструктор по умолчанию остался; он часто требуется для нужд кон-
тейнеров, потому что контейнеры имеют обыкновение обертывать компоненты
прокси-объектами для поддержки интерцепторов.

В первом примере мы легко могли бы использовать аннотацию @EJB . Истин-
ная мощь аннотации @Inject стала очевидна только после аннотирования конс-
труктора. Это наиболее естественное решение – оно избавляет от необходимости
использовать аннотацию @PostConstruct для определения операций настройки,
выполняемых после создания компонента и внедрения зависимостей. Возмож-
ность применения механизма внедрения к конструкторам позволяет компонен-
там действовать подобно обычным POJO – конструктор получает параметры и
инициализирует объект, как это принято в объектно-ориентированном мире. Вам
не нужно выполнять внедрение и использовать метод-обработчик для инициали-
зации компонента.


12.3.2. Фабричные методы

В предыдущем разделе мы узнали, как организовать внедрение зависимостей в
параметры конструкторов, чтобы создание компонентов выглядело более естест-
венным и похожим на создание простых POJO. Но нередко возникают ситуации,
когда необходимо иметь полный контроль над созданием компонента. Например,
экземпляр компонента может создаваться на основе записи в базе данных, или мо-
жет потребоваться выполнить некоторые дополнительные операции по настройке
компонента, или необходимо предварительно выбрать тип создаваемого компо-
нента. Для удовлетворения этого требования в CDI поддерживается понятие ме-
тода-продюсера (producer method), или фабричного метода. Фабрика – это метод
или поле экземпляра, к которому обращается контейнер CDI для создания экзем-
пляра. Метод или поле экземпляра должен быть отмечен аннотацией @Producer .
Так как контейнер CDI выполняет типизированное внедрение, по типу поля или
возвращаемого значения он определяет тип создаваемого компонента.


*. Фабрика, возвращающая экземпляры “currentUser”

@Named
public class CurrentUserBean implements Serializable {

  @EJB
  private UserService userService;
  
  private User user;

  @Produces             // Отмечает метод как фабрику
  @SessionScoped        // Новые экземпляры получают область видимости сеанса
  @Named(“currentUser”) // Экземпляр будет доступен в JSF
  public User getCurrentUser() {
    if(user == null || user.isAnonymous()) {
      user = userService.getAuthenticatedUser();
    }
    return user;
  }


  public boolean isAuthenticated() {
    return userService.isAuthenticated();
   }
}


Здесь определен фабричный метод, который должен создать и вернуть
компонент User , представляющий текущего пользователя, посетившего веб-
сайт ActionBazaar. Этот метод отмечен аннотацией @Produces. Аннотация
@SessionScoped информирует контейнер CDI, что экземпляр должен сохра-
няться на протяжении всего сеанса. как результат, этот метод будет вызываться
только один раз для каждого сеанса; созданный экземпляр будет помещен в кэш
сеанса. Аннотация @Named делает экземпляр доступным для JSF – присвоение
строкового имени позволяет ссылаться на компонент из выражений EL. В лис-
тинге 12.7 показано, как могла бы выглядеть страница JSF, использующая этот
компонент User .


*. Вызов фабричного метода в index.xhtml

<HTML xmlns:f=”http://java.sun.com/jsf/core”
  xmlns:h=”http://java.sun.com/jsf/html”>
  <h:body>
    <h:form id=”itemForm”>

    <!-- Проверить, был ли аутентифицирован пользователь -->
    Hi! <h:outputText rendered=”#{currentUserBean.authenticated}”
      <!-- Персонализировать страницу именем пользователя -->
      value=”#{currentUser.username}”/>
    <h:link rendered=”#{!currentUserBean.authenticated}”
      value=”Sign in” outcome=”login”/>

    <!-- Вывести ссылку на форму входа,
         если пользоватедь пока не аутентифицирован -->
    <h:commandLink rendered=”#{currentUserBean.authenticated}”
      immediate=”true”
      action=”#{logoutController.logout()}”>Log-out</h:commandLink>
    </h:form>
  </h:body>
</HTML>


Фабричный метод, представленный в этом листинге, вызывается косвенно. Так
как возвращаемый экземпляр будет кэшироваться в сеансе, фабричный метод дол-
жен вызываться только после аутентификации пользователя и имеется объект,
представляющий пользователя с ролью продавца или покупателя. Поэтому сна-
чала проверяется, был ли аутентифицирован пользователь. Если пользователь
аутентифицирован, вычисляется выражение, возвращающее имя пользователя,
которое либо извлекает экземпляр компонента текущего пользователя из объекта
сеанса, либо вызывает фабричный метод, возвращаемое значение которого будет
кэшировано в сеансе. Если посетитель еще не аутентифицирован, отображается
ссылка на форму аутентификации.

Обратите внимание, что в этом примере контейнер CDI просканирует все клас-
сы в JAR-файле, если он содержит файл beans.xml. Он запомнит все фабричные
методы, найденные при анализе классов. Когда приложение запросит экземпляр
компонента – в данном случае экземпляр User – контейнер CDI вызовет фабрич-
ный метод, если экземпляр компонента еще не был создан в текущей области ви-
димости.

В любом компоненте внутри приложения вы теперь сможете использовать сле-
дующий код для получения ссылки на текущего пользователя:

@Inject
private User currentUser;

Просматривая такой код, не забывайте обращать внимание на тип. Для контей-
нера CDI имя поля не имеет никакого значения – он выполняет внедрение, опира-
ясь на тип.


12.3.3. Квалификаторы

Представьте, что
в примере с текущим пользователем из предыдущего раздела потребовалось внед-
рить другой экземпляр, представляющий пользователя, обслуживаемого в настоя-
щий момент сотрудником отдела поддержки. Контейнер CDI имеет решение этой
проблемы, которое называется квалификатором . Квалификатор дает возможность
квалифицировать определенные точки внедрения, как использующие разные эк-
земпляры компонента. Таким способом можно пометить объект User , как текущий
пользователь или как пользователь, обслуживаемый сотрудником отдела подде-
ржки. Квалификатор задается с использованием собственной аннотации.

Чтобы определить квалификатор, нужно определить новую аннотацию и снаб-
дить это определение аннотацией @Qualifier . Причиной, почему вместо стро-
ковых имен для квалификации предлагается определять и использовать новые
аннотации, является стремление сохранить строгую типизацию. Это одна из отли-
чительных особенностей CDI, которая уменьшает вероятность появления ошибок
во время выполнения. После определения, новые аннотации следует помещать пе-
ред точками внедрения и перед фабричными методами.


@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface AuthenticatedUser {}

@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface Seller {}


После определения квалификатора его можно добавить к фабричному методу:

@Produces @SessionScoped @AuthenticatedUser @Named(“currentUser”)
public User getCurrentUser() {
  ...
}


После этого можно сообщить контейнеру CDI, какой экземпляр следует внед-
рить

*. Управление выбором экземпляра для внедрения с помощью квалификатора

@Named
@RequestScoped
public class BidController implements Serializable {

  @Inject @Seller      // Внедрить продавца, к объявлению
  private User seller; // которого делается ставка

  @Inject @AuthenticatedUser // Внедрить аутентифицированного
  private User user;         // пользователя делающего ставку

  public String placeOrder() {
    ...
  }
}


В этом листинге можно видеть применение квалификатора. Здесь осуществля-
ется внедрение двух экземпляров User . Первый экземпляр представляет про-
давца, к объявлению которого вы делаете ставку. Второй экземпляр – аутентифи-
цированный пользователь, делающий ставку. В обоих случаях предоставляется
дополнительная информация, чтобы контейнер CDI смог определить, какой имен-
но экземпляр следует внедрять.
В примере демонстрируется применение единственного квалификатора, но это
не означает, что нельзя применить сразу несколько квалификаторов. Дополни-
тельные квалификаторы позволяют уточнить выбор при необходимости.


12.3.4. Методы уничтожения

Метод уничтожения (disposer method) выполняет операции, связанные с удалени-
ем компонента. Хотя концептуально эти методы напоминают деструкторы в C++
или методы-финализаторы в Java, все же они имеют свои уникальные черты. Во-
первых, метод уничтожения находится в том же классе, что и фабричный метод, а
не в классе, экземпляры которого он должен уничтожать. Во-вторых, он вызывает-
ся, когда прекращается действие контекста и контейнер освобождает компонент.
Например, если компонент принадлежит контексту сеанса, метод уничтожения не
будет вызван, пока не истечет время действия сеанса.

Метод уничтожения отличается от обычного метода наличием аннотации
@Disposes перед параметром. При этом могут использоваться дополнительные
квалификаторы. Методу могут передаваться также другие параметры; контейнер
CDI будет пытаться интерпретировать их как компоненты, используя квалифика-
торы, если они указаны. Метод уничтожения может закрыть соединение с базой
данных и выполнить другие заключительные операции.

*. Метод уничтожения освобождает экземпляр объекта, представляющего
аутентифицированного пользователя

@Named
@SessionScoped
public class CurrentUserBean implements Serializable {
  ...
  // Фабричный метод должен находиться
  // в одном классе с методом уничтожения
  @Produces @SessionScoped @AuthenticatedUser @Named(“currentUser”)
  public User getCurrentUser() {
    ...
  }

  public void logout(
    // Метод уничтожения должен находиться
    // в одном классе с фабричным методом
    @Disposes
    @AuthenticatedUser
    User user) {
      // Заключительные операции и выход
    }
}


Этот листинг демонстрирует пример объявления метода уничтожения. Как уже
говорилось, метод уничтожения должен объявляться в одном классе с фабричным
методом, но, в отличие от последнего, он не должен принимать дополнительные
параметры. Метод уничтожения осуществляет уничтожение объекта User , ког-
да истечет предельное время нахождения сеанса в неактивном состоянии. Внутри
этого метода можно выполнять любые заключительные операции.


12.3.5. Определение альтернатив

До сих пор, рассматривая внедрение зависимостей, мы подразумевали, что вы-
бор внедряемого компонента производится на этапе разработки. Но, при наличии
разных сценариев развертывания, необходим некоторый механизм настройки аль-
тернатив для точек внедрения. Очевидно, что этот механизм должен использовать
конфигурационные файлы и не требовать изменений в программном коде.
Для решения этой проблемы в CDI существует понятие альтернатив. Альтерна-
тива – это дополнительная реализация компонента, в той же иерархии наследова-
ния, которая может использоваться взамен основной. Чтобы пометить компонент
как альтернативу, нужно добавить аннотацию @Alternative к объявлению клас-
са. Чтобы задействовать альтернативу, нужно добавить ее в файл beans.xml. В за-
висимости от целевого окружения, можно использовать разные файлы beans.xml
или динамически генерировать файл с нужным содержимым.

Иерархия классов, реализующих начальные операции, выполняемые на запус-
ке. Здесь SystemStartup – это базовый класс, используемый
для инициализации приложения в эксплуатационном окружении. Два других
подкласса, оба снабженные аннотацией @Alternative , используются в окруже-
нии для разработки и тестирования, соответственно.


*. Класс инициализации приложения

// Инициализацию выполняет компонент-одиночка, создаваемый
// во время запуска приложения
@Singleton
@Startup
public class Bootstrap {

  // Внедрить экземпляр SystemStartup
  @Inject
  private SystemStartup systemStartup;

  @PostConstruct
  public void postConstruct() {
    // Экземпляр SystemStartup вызывается в postConstruct
    systemStartup.init();
  }

}


*. Альтернативный класс SystemStartup, имеющий иную реализацию

// Класс отмечен как альтернативная реализация
@Alternative
// Наследует базовый класс SystemStartup
public class DevelopmentStartup extends SystemStartup {

  @Inject
  private UserService userService;

  @Inject
  private ItemManager itemManager;

  @Override
  public void init() {
    // подготовка тестовых данных и учетных записей
  }

}


Здесь класс отмечен аннотацией @Alternative и наследует базовый класс
SystemStartup . Класс DevelopmentStartup используется, только если это разре-
шено. Чтобы разрешить использование альтернативы, класс должен быть указан в
файле beans.xml. Как уже упоминалось, нужно либо включать в пакет разные фай-
лы beans.xml, либо динамически генерировать нужное содержимое для файла во
время сборки. Чтобы задействовать класс DevelopmentStartup , нужно добавить
следующий элемент в файл beans.xml:

<alternatives>
  <class>com.actionbazaar.setup.DevelopmentStartup</class>
</alternatives>

--//--


12.4. Интерцепторы и декораторы

Ранее в этой книге мы уже исследовали поддержку интерцепторов в EJB 3, однако
она ограничивается только компонентами EJB. Поддержку интерцепторов в CDI
можно применять к любым компонентам, включая и компоненты EJB. Для управ-
ления реализацией интерцепторов CDI используются аннотации, как и в EJB 3.
Несмотря на то, что поддержка в CDI не имеет таких же широких возможностей,
как AspectJ, она все же намного проще в использовании.


12.4.1. Привязка интерцепторов

Создание интерцептора в CDI сопряжено с решением четырех разных задач про-
граммирования. И хотя их решения не выглядят так же элегантно, как определе-
ния точек сопряжения в AspectJ, они все же обладают высокой степенью предска-
зуемости во время выполнения. Вот эти задачи:

1. Создать аннотацию интерцептора.
2. Создать реализацию интерцептора, отмеченную аннотацией интерцептора.
3. Отметить целевые экземпляры аннотацией интерцептора.
4. Включить интерцептор в файл beans.xml.

Существует три вида интерцепторов, применяемых к разным типам методов

-- Для прикладных методов
-- @AroundInvoke
-- Перехватывают вызовы прикладных методов.

-- Для обработчиков событий жизненного цикла
-- @PostConstruct /@PreDestroy
-- Перехватывают вызовы обработчиков событий жизненного цикла.

-- Для методов, вызываемых таймерами EJB
-- @AroundTimeout
-- Перехватывают вызовы методов, осуществляемые таймерами EJB.

Чтобы определить интерцептор, необходимо сначала определить аннотацию
интерцептора. Аннотация интерцептора служит для того, чтобы связать пере-
хватываемый класс или метод с реализацией интерцептора. Поэтому, аннотация
помещается и перед реализацией интерцептора, и перед классом или методом,
обращение к которому должно перехватываться. По умолчанию интерцептор не-
активен; его необходимо включить в файле beans.xml.

Интерцептор произво-
дительности будет измерять время выполнения и сохранять его в файл на жестком
диске сервера. Здесь мы сосредоточимся на применении интерцептора к классу
LandingController . Класс LandingController реализует главную страницу
приложения ActionBazaar. Если эта страница будет работать слишком медленно,
пользователи могут отказаться от посещения других разделов сайта.

@InterceptorBinding
@Retention(RUNTIME)
@Target({TYPE})
public @interface PerformanceMonitor {}

Эта аннотация сама отмечена аннотацией @InterceptorBinding . Когда кон-
тейнер CDI встретит эту аннотацию, он поймет, что вы просите его обернуть метод
или методы интерцептором и создаст экземпляр интерцептора. После определе-
ния аннотации интерцептора необходимо определить его реализацию


*. Реализация интерцептора измерения производительности

// Связать @PerformanceMonitor с PerformanceInterceptor
@PerformanceMonitor
@Interceptor // Отметить класс как интерцептор
public class PerformanceInterceptor {

  // Отметить метод, который будет перехватывать вызовы других методов
  @AroundInvoke
  // InvocationContext хранит контекстную информацию
  public Object monitor(InvocationContext ctx) throws Exception {
    long start = new Date().getTime();
    try {
      // Вызвать метод proceed для вызова фактического метода
      return ctx.proceed();
    } finally {
      long elapsed = new Date().getTime() - start;
      Logger.getLogger(“PerformanceInterceptor”).log(Level.INFO,
        “Elapsed time: {0}”, elapsed);
    }
  }
}


В этом листинге определена реализация интерцептора. Интерцептор необходи-
мо снабдить аннотацией, чтобы связать их друг с другом. Реализация должна
быть также отмечена аннотацией @Interceptor , чтобы отметить этот класс как
интерцептор. Аннотация @AroundInvoke отмечает метод, который фактически
осуществляет перехват. Посредством InvocationContext внутри этого метода
можно получить информацию о перехваченном методе, а также его параметрах.
С помощью метода proceed осуществляется вызов перехваченного метода, впро-
чем, при желании перехваченный метод можно и не вызывать.
InvocationContext . Этот
класс позволяет получить полезные сведения о перехваченном методе, о его пара-
метрах и другую контекстную информацию.


*. Методы InvocationContext

-- Object getTarget();
Возвращает экземпляр объекта, для которого осуществляется перехват.

-- Object getTimer();
Возвращает объект таймера, который вызывает перехватываемый метод.

-- Method getMethod();
Возвращает перехватываемый метод.

-- Object[] getParameters();
Возвращает параметры перехватываемого метода.

-- void setParameters (Object[] os);
Изменяет параметры перехватываемого метода.

-- Map<String, Object> getContextData();
Возвращает контекстные данные, связанные с этим вызовом – информация из аннотации.

-- Object proceed() throws Exception;
Вызывает перехваченный метод.


После определения интерцептора его можно использовать. Аннотацией интер-
цептора можно отмечать целые классы или отдельные методы. Ниже показано,
как применить интерцептор к классу LandingController :

@Named
@ApplicationScoped
@PerformanceMonitor
public class LandingController {
  ...
}


Простое добавление аннотации к классу LandingController не включает пере-
хват по умолчанию. Интерцептор нужно включить в файле beans.xml. Следующий
фрагмент включает интерцептор:

<interceptors>
  <class>com.actionbazaar.util.PerformanceInterceptor</class>
</interceptors>


После включения интерцептора, он будет отслеживать все вызовы всех мето-
дов класса LandingController . При необходимости можно отметить аннотацией
интерцептора и другие классы. При одновременном использовании нескольких
интерцепторов, они будут выполняться в том же порядке, в каком определяются в
файле beans.xml. Дополнительные интерцепторы включаются добавлением новых
элементов <class></class> .


12.4.2. Декораторы

Декораторы очень похожи на интерцепторы. Декораторы точно так же осущест-
вляют перехват вызовов методов компонентов. Но, в отличие от интерцепторов,
декораторы переопределяют перехватываемые методы. Декоратор наследует или
реализует интерфейс компонента. Как результат, декоратор оказывается тесно
связанным с компонентом и может реализовать прикладную логику. Поскольку
фактически выполняется переопределение методов, вы получаете простой доступ
к их параметрам.

Чтобы лучше понять назначение декораторов, рассмотрим процедуру торга в
приложении ActionBazaar. Одна из больших проблем подобных сайтов – мошен-
ничество. Перебивая цену, предложенную другим пользователем, любой потен-
циальный покупатель хотел бы быть уверенным, что он не состязается с продав-
цом, создавшим поддельную учетную запись специально, чтобы устроить гонку
предложений на свой товар. Для защиты от такого рода мошенничества необхо-
дим хотя бы самый простенький механизм определения состояния гонки. Однако,
хотя определение состояния гонки и является частью процесса торгов, оно не яв-
ляется частью логики обработки ставок. Это – сквозная функция, подобная фун-
кции журналирования, только более узкоспециализированная. Следовательно, ее
можно реализовать с помощью декоратора


*. Декоратор, реализующий BidManager и перехватывающий вызовы методов

@Decorator // Отметить класс как декоратор
// Декоратор – абстрактный
public abstract class BidManagerFraudDetector implements BidManager {

  @Inject               // Внедрить обертываемый экземпляр bidManager
  @Delegate             // Отметить экземпляр как делегат
  @BidManagerQualifier  // Квалификатор экземпляров bidManager
  private BidManager bidManager;
  @Override
  // Реализация перехватываемого метода
  public void placeBid(Bid bid) {
    ...
  }

}


В этом листинге определяется декоратор. Чтобы создать декоратор, нужно от-
метить класс аннотацией @Decorator и реализовать или унаследовать декори-
руемый класс. Затем следует внедрить экземпляр декорируемого класса и
отметить его, как экземпляр делегата. Чтобы гарантировать выбор нужного эк-
земпляра здесь используется квалификатор. Наконец, переопределяется пере-
хватываемый метод. Поскольку в данном примере нас интересует только метод
placeBid , мы пометили класс как абстрактный.

Декораторы, как и интерцепторы, по умолчанию выключены. Чтобы активи-
зировать предыдущий декоратор, нужно добавить следующий фрагмент в файл
beans.xml:

<decorators>
  <class>com.actionbazaar.buslogic.BidManagerFraudDetector</class>
</decorators>

--//--


12.5. Стереотипы

По мере знакомства с новыми особенностями CDI мы накопили большое число
аннотаций. В некоторых случаях последовательность аннотаций перед методами
оказывается длиннее сигнатуры метода. Если взглянуть внимательнее на все эти
методы, можно заметить, что часто к ним применяются одни и те же аннотации.
Такой избыточный код усложняет его сопровождение. К счастью, разработчики
CDI предвидели эту проблему и добавили конструкцию, получившую название
стереотип (stereotype).

Вас не должно удивлять, что стереотип – это еще одна аннотация. Но в отличие
от аннотаций, встречавшихся нам до сих пор, стереотип является объединени-
ем нескольких аннотаций. Стереотип создается объявлением новой аннотации
и добавлением в нее других аннотаций.

Пример. Сигнатура метода выглядит короче, чем список аннотаций,
применяемых к нему:

@Named @SessionScoped
public class CurrentUserBean implements Serializable {
  @Produces @SessionScoped @AuthenticatedUser @Named
  public User getCurrentUser() {
    ...
  }
}

C помощью стереотипа, определение которого приводится ниже, можно сущес-
твенно уменьшить число аннотаций, применяемых к методу:

@SessionScoped
@AuthenticatedUser
@Named
@Stereotype
@Target( { TYPE, METHOD, FIELD })
@Retention(RUNTIME)
public @interface CurrentUser {}

В новой аннотации @CurrentUser мы объединили аннотации @SessionScoped ,
@AuthenticatedUser и @Named . В следующем фрагменте показано, насколько эта
аннотация упрощает определение класса CurrentUserBean :

@Named @SessionScoped
public class CurrentUserBean implements Serializable {
  @Produces @CurrentUser
  public User getCurrentUser() {
  ...
  }
}


Существует несколько основных правил определения стереотипов. Стереоти-
пы могут состоять из аннотаций CDI, определяющих:
 - область видимости (контекст);
 - привязки интерцепторов;
 - имена для интеграции с JSF;
 - альтернативы.
В стереотипы нельзя включать аннотации JPA или EJB. Также нельзя включать
аннотацию @Produces и другие аннотации, определяющие обработчики событий
жизненного циклаВ CDI имеется встроенный стереотип @Model для создания компонентов, игра-
ющих роль модели в шаблоне «модель-представление-контроллер» (model-view-
controller). Определение аннотации @Model приводится ниже:

В CDI имеется встроенный стереотип @Model для создания компонентов, игра-
ющих роль модели в шаблоне «модель-представление-контроллер» (model-view-
controller). Определение аннотации @Model приводится ниже:

@Named
@RequestScoped
@Documented
@Stereotype
@Target(value = {ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Model {}

С ее помощью можно заменить аннотации @Named и @RequestScoped , как пока-
зано в следующем фрагменте:

@Model
public class ItemController implements Serializable {
  ...
}

--//--

12.6. Внедрение событий

Внедрение зависимостей – чрезвычайно удобный способ получения ссылок на дру-
гие компоненты. Однако механизм внедрения зависимостей в CDI поддерживает
также внедрение событий. Это позволяет организовать доставку событий другим
компонентам без образования зависимостей на этапе компиляции. Гениальность
такого подхода заключается в простом использовании аннотаций для определе-
ния методов, которые будут принимать события. Чтобы обеспечить доставку со-
бытия компоненту, вам не придется прибегать к дополнительным ухищрениям.
Вам не нужно реализовать интерфейс или регистрировать класс как приемник со-
бытий – всю «грязную» работу за вас выполнит контейнер. Возбудить событие так
же просто; объект, отвечающий за отправку событий, просто внедряется в класс,
нуждающийся в этой функции.

Аннотация @Observes помещается перед одним или несколькими параметра-
ми метода, принимающего событие. Тип параметра определяется типом события.
Например, если параметр имеет тип ActionEvent , тогда метод будет получать все
события ActionEvent . С помощью дополнительных квалификаторов перед точ-
кой внедрения можно обеспечить более точную классификацию событий. Допол-
нительные параметры метода интерпретируются контейнером как компоненты,
которые нужно найти или создать.

Отправка события компонентом осуществляется с использованием объекта
Event , параметризованного типом объекта, который нужно отправить. Он внед-
ряется с помощью аннотации @Inject и может иметь дополнительные аннотации-
квалификаторы, сужающие круг потенциальных целей события. Фактическая от-
правка осуществляется вызовом метода fire объекта Event .

когда добавляется новое
объявление, необходимо известить множество компонентов. Состав компонентов,
реагирующих на это событие, может изменяться с течением времени, к тому же
в приложение могут добавляться новые модули с новыми компонентами, и едва
ли кто-то будет гореть желанием постоянно изменять ItemController . Поэто-
му ItemController возбуждает событие, которое получают другие компоненты,
включая LandingController и TwitterNotifier . Применение разновидности
шаблона проектирования «Наблюдатель» (Observer), реализованной в CDI, поз-
воляет писать слабо связанный код – ItemController не имеет ссылок на другие
компоненты, а другим компонентам, ожидающим указанное событие, не требуется
получать ссылку на ItemController .


*. ItemController и возбуждение событий

@Model
public class ItemController implements Serializable {

  @Inject  // Внедрить объект события для отправки
  @NewItem // Дополнительный квалификатор объекта события
  // Внедряемый объект события параметризованный типом объявления
  private Event<Item> itemNotifier;

  public String add() {
    // Сначала сохранить объявление, потом отправить с событием
    itemNotifier.fire(item); // Отправить событие всем приемникам
    ...
    return NavigationRules.HOME.getRule();
  }
}


В этом листинге компонент ItemController отправляет события, извещающие
о добавлении нового объявления. Сначала в компонент внедряется объект собы-
тия, который дополнительно квалифицируется аннотацией @NewItem, чтобы
ограничить круг целевых компонентов, заинтересованных именно в событии до-
бавления нового объявления. Сам объект события использует механизм обобщен-
ных типов Java Generics, чтобы гарантировать передачу в вызов fire объекта нуж-
ного типа. Возбуждение события осуществляется достаточно просто – простым
вызовом метода fire объекта события и передачей ему нового объявления item.


@Named
@ApplicationScoped
@PerformanceMonitor
public class LandingController {

  public void onNewItem(@Observes             // Пометить
                        @NewItem Item item) { // метод как приемник события
                                              // Обрабатывает только
                                              // объявления
    newestItems.add(0,item);
  }
}

Как показано в этом листинге, контейнер CDI выполняет регистрацию со-
бытия автоматически. Вам не нужно предусматривать реализацию интерфейса
или получать ссылку на ItemController , чтобы зарегистрировать компонент
LandingController как приемник события. Метод onNewItem интерпретиру-
ется как приемник события, потому что его параметр item отмечен аннотацией
@Observes. Кроме того, благодаря квалификатору @NewItem, метод будет вы-
зываться только по событиям добавления нового объявления.


12.7. Диалоги

Компонент, ограниченный контекстом диалога,
существует только в течение диалога, протяженность которого короче протяжен-
ности сеанса, но длиннее протяженности обработки одного запроса. То есть, кон-
текст диалога распространяется на несколько запросов и представляет некоторую
единицу работы.

Чтобы указать, что компонент имеет область видимости диалога, его нужно
отметить аннотацией @ConversationScoped . Но по умолчанию контекст диалога
распространяется только на один запрос, если явно не продлить его. Диалог, ко-
торый не был продлен, называют переходным диалогом (transient conversation).
Явное продление диалога необходимо, чтобы контейнер знал, когда начинается
продолжительный диалог, а когда обрабатывается короткая реплика. Контейнеру
нужно так же знать, когда заканчивается диалог. Явный запуск и явное заверше-
ние диалога используются для управления ресурсами. Чтобы запустить или ос-
тановить диалог, необходимо обратиться к объекту javax.enterprise.context.
Conversation . Получить ссылку на него можно путем внедрения.

*. Методы объекта Conversation

-- void begin()
Преобразует текущий переходный диалог в продолжительный диалог.

-- void begin(String id)
Преобразует текущий переходный диалог в продолжи-
тельный диалог с указанным идентификатором id.

-- void end()
Завершает диалог и преобразует его в переходный диа-
лог.

-- String getId()
Возвращает идентификатор текущего диалога.

-- long getTimeout()
Возвращает таймаут текущего диалога в миллисекундах.

-- boolean isTransient()
Возвращает true, если если текущий диалог является
переходным и будет завершен после обработки запро-
са.

-- void setTimeout (long timeout)
Устанавливает указанный таймаут для текущего диалога;
эта операция выполняется, только если диалог не явля-
ется переходным.


*. показано, как запускается продолжительный диалог.

@Model
// Компонент ItemController имеет область видимости запроса
public class ItemController implements Serializable {

  @Inject
  private Conversation conversation; // Внедрить объект Conversation

  private BigDecimal bidAmount;

  private Item item;  // Выбранное объяаление кэшируется
                      // для фабричного метода

  // startConversation вызывается щелчком на ссылке
  public String startConversation(Item item) {
    conversation.begin(); // Запуск диалога
    this.item = item;     // Кэширование выбранного объявления
    return NavigationRules.ITEM.getRule();
  }

  // Фабричный метод, возвращающий выбранное объявление
  @Produces @SelectedItem @Named(“selectedItem”) @ConversationScoped
  public Item getCurrentItem() {
    if(item == null) {
      item = new Item();
    }
    return item;
  }
}


Аннотация @Model указывает, что данный компонент доступен из страниц JSF
и имеет область видимости запроса. Аннотация @Model – это стереотип, объединяю-
щий аннотации @RequestScoped и @Named . Это весьма распространенная комби-
нация. Прежде чем метод startConversation будет вызван из страницы JSF, кон-
тейнер CDI внедрит объект диалога. Чтобы запустить диалог, необходимо явно
сообщить контейнеру об этом, что делается вызовом метода startConversation.
Одновременно в свойстве item сохраняется объявление, выбранное пользо-
вателем. Теперь диалог запущен и выбранное объявление сохранено в кэше.
Последнее, что делает метод startConversation , – переход к странице с объ-
явлением. Ответ формируется в контексте текущего запроса, поэтому кэширован-
ное объявление все еще доступно.
При отображении этой страницы, объект
selectedItem будет извлечен методом getCurrentItem. Это – фабричный ме-
тод, возвращающий выбранное объявление, кэшированное в контексте диалога и,
соответственно, продолжающее существовать до завершения этого диалога. Диа-
лог может быть завершен программно или спустя установленный период отсутст-
вия активности.


*. Страница с объявлением – для просмотра и предложения цены

<!DOCTYPE html>
<HTML
  xmlns:f=”http://java.sun.com/jsf/core”
  xmlns:h=”http://java.sun.com/jsf/html”>
  <h:body>
    <h:form>
      <!-- Вывод названия товара из выбранного объявления -->
      Item Name: #{selectedItem.itemName}<br/>
      <!-- Сумма ставки -->
      Bid: <h:inputText value=”#{currentBid.bidPrice}” size=”5”/><br/>
      <h:commandButton value=”Place Bid”
        <!-- Команда размещения ставки -->
        action=”#{bidController.placeOrder()}”/>
    </h:form>
  </h:body>
</HTML>

Эта страница отображает название товара из выбранного объявления. Для
этого производится вызов фабричного метода компонента ItemController
Предлагаемая цена вводится в поле ввода. Щелчок
на кнопке Place Bid (Сделать ставку) приводит к вызову метода placeOrder и
переходу к странице placeBid.xhtml с информацией о ставке и кнопкой подтверж-
дения.


*. placeBid.xhtml – страница подтверждения ставки

<HTML
  xmlns:f=”http://java.sun.com/jsf/core”
  xmlns:h=”http://java.sun.com/jsf/html”>
  <h:body>
    <h:form>
      <!-- Вывести объект объявления с областью видимости диалога -->
      Confirm Item: #{selectedItem.itemName}<br/>
      Amount: #{currentBid.bidPrice}<br/>
      <h:commandButton value=”Confirm Bid”
        <!-- Подтверждает ставку -->
        action=”#{bidController.confirmBid()}”/>
    </h:form>
  </h:body>
</HTML>

Здесь снова
отображается выбранное объявление, хранящееся в контексте диалога. Щелчок
на кнопке Confirm Bid (Подтвердить ставку) сохраняет ставку, вызывая метод
confirmBid компонента BidController


*. BidController – сохранение ставки

@Model
public class BidController implements Serializable {

  @Inject @SelectedItem // Внедрить выбранное объявление из диалога
  private Item item;

  @Inject
  private Conversation conversation; // Внедрить контекст диалога

  public String confirmBid() {
    logger.log(Level.INFO, “Conversation ID: {0}”,
    conversation.getId()); // Записать ID текущего контекста диалога
    bidManager.placeBid(currentBid);
    conversation.end();    // Завершить диалог
    return NavigationRules.HOME.getRule();
  }

  public String placeOrder() {
    // выполнить некоторые операции
    return NavigationRules.PLACE_BID.getRule()
  }
}


Выбранное объявление внедряется в этот компонент. Также внедряется кон-
текст диалога. Метод confirmBid выводит идентификатор диалога для целей
отладки и после успешной регистрации ставки завершает диалог. После этого
все объекты, хранящиеся в контексте диалога, будут уничтожены.
В этом примере из приложения ActionBazaar выбранное объявление сохраняет-
ся в контексте диалога фабричным методом. После этого оно используется в двух
страницах: в странице с подробной информацией об объявлении, позволяющей
пользователю прочитать описание и сделать ставку, и в странице подтверждения,
где пользователь подтверждает свой выбор. Это лишь один пример использова-
ния контекста диалога – такой подход намного проще, чем пытаться разработать
собственное решение.


12.8. Эффективное использование CDI в EJB 3

EJB и CDI – это взаимодополняющие технологии,
усиливающие друг друга и упрощающие создание приложений Java EE. Техно-
логия CDI значительно упрощает использование компонентов EJB – она избав-
ляет от необходимости непосредственно обращаться к каталогу JNDI или писать
собственный слой абстракции доступа к JNDI. CDI добавляет в POJO поддержку
внедрения зависимостей и контекстов, а также некоторые расширения. Компонен-
ты CDI не могут служить заменой компонентам EJB – компоненты EJB незаме-
нимы там, где требуется поддержка безопасности, транзакций, удаленных взаимо-
действий, планирования, асинхронных операций и блокировок. Но не забывайте,
что компоненты EJB выполняются в контейнере CDI, поэтому вы можете решать
любые возникающие проблемы, как если бы они были компонентами CDI, и при
необходимости использовать службы, предоставляемые контейнером EJB.

Так как компоненты EJB одновременно являются компонентами CDI, старай-
тесь всегда использовать аннотацию @Inject вместо @EJB . Возможность конфи-
гурирования, поддерживаемая контейнером CDI, значительно упрощает тести-
рование приложений. С помощью конфигурационного файла beans.xml можно
подменять внедряемые экземпляры для нужд модульного и интеграционного
тестирования.

CDI предоставляет мощную поддержку событий, помогающую уменьшить свя-
занность кода. Она значительно уменьшает запутанность кода. Однако события 
CDI не могут распространяться за пределы JVM.

Существует одна область, где компоненты CDI вытесняют компоненты EJB –
сеан совые компоненты с сохранением состояния. Компоненты с областью види-
мости диалога намного удобнее и прекрасно подходят для большинства прило-
жений. В прошлом сеансовые компоненты с сохранением состояния чаще всего
использовались для реализации продолжительных прикладных процедур, кото-
рые мы называем диалогами. Диалоги – это только начало; CDI поддерживает воз-
можность создания собственных областей видимости, что дает дополнительную
гибкость и позволяет находить элегантные решения, более простые в сопровож-
дении.

--//--

--//-------------------------------------------------------------------------

# Глава 13.
# Упаковка приложений EJB 3


13.1. Упаковка приложений

Как уже говорилось в главе 1, контейнер EJB является частью сервера EE и
отвечает за управление компонентами EJB и MDB. Чтобы развернуть эти ком-
поненты на сервере EE, их следует упаковать в модуль EJB-JAR . А чтобы понять,
как выполняется упаковка модулей EJB-JAR, необходимо посмотреть, какое место
они занимают в общей картине пакетов Java EE и из каких элементов состоит за-
конченное корпоративное приложение на Java.

Чтобы развернуть приложение и ввести его в действие, необходимо упаковать
модули EJB-JAR и WAR в общий модуль EAR и развернуть его на сервере приложе-
ний. Спецификация Java EE определяет стандартный способ упаковки этих моду-
лей в файл формата JAR. Одно из преимуществ этого формата, также определяемого
спецификаций, состоит в том, что он совместим с разными серверами приложений.

В табл. 13.1 перечислены модули, поддерживаемые сервером EE. Каждый мо-
дуль обычно объединяет в себе схожие элементы приложения. Например, у вас
может быть несколько модулей EJB-JAR, каждый из которых включает разные
части прикладной логики. Аналогично у вас может быть несколько модулей WAR,
реализующих уникальные пользовательские интерфейсы. Модуль EAR служит
супермодулем, содержащим все остальные модули, поэтому в конечном итоге вам
придется развертывать только один файл. Сервер приложений исследует содер-
жимое модуля EAR и развернет его.


-- EJB Java Archive (EJB-JAR)
-- [ META-INF/ejb-jar.xml ] или [ WEB-INF/ejb-jar.xml ]
Сеансовые компоненты и компоненты MDB. Может также включать
сущности JPA и компоненты CDI.

-- Web Application Archive (WAR )
-- [ WEB-INF/web.xml ]
Артефакты веб-приложения, такие как сервлеты, страницы JSP
и JSF, изображения и так далее. Может также включать компо-
ненты EJB и CDI, сущности JPA.

-- Enterprise Application Archive (EAR )
-- [ META-INF/application.xml ]
Другие модули Java EE, такие как EJB-JAR и WAR.

-- Resource Adapter Archive (RAR )
-- [ META-INF/ra.xml ]
Адаптеры ресурсов.

-- Client Application Archives (CAR )
-- [ META-INF/application-client.xml ]
Автономные Java-клиенты для компонентов EJB.

-- Java Persistence Archive (JPA)
-- [ META-INF/persistence.xml ] или [ WEB-INF/persistence.xml ] 
Объектно-реляционные отображения между приложениями и
базами данных в стандарте Java EE. Может включаться в состав
архивов EJB-JAR, WAR, EAR и CAR.

-- Context Dependency and Injection Bean Archive (CDI)
-- [ META-INF/beans.xml ] или [ WEB-INF/beans.xml ]
Компоненты CDI в стандарте Java EE. Может включаться в со-
став архивов EJB-JAR, WAR, EAR и CAR.

Корпоративные приложения на Java должны быть сначала собраны в модули
определенного типа, а затем из них собирается главный модуль EAR, который за-
тем может быть развернут на сервере. Типы модулей определяются спецификаци-
ей Java EE.

Все эти модули сохраняются в виде файлов в формате JDK-JAR. Вы можете
собрать их вручную, с помощью утилиты jar , входящей в состав JDK. Одна-
ко в действительности все рутинные операции, связанные со сборкой модулей,
выполняются либо интегрированной средой разработки, либо специализиро-
ванными инструментами (такими как Maven и ANT ). Но в любом случае для
каждого модуля вам придется написать программный код и дескриптор раз-
вертывания (deployment descriptor) с настройками. После сборки всех модулей
выполняется последний шаг – сборка главного модуля (то есть, EAR) для раз-
вертывания.

В большинстве случаев дескрипторы развертывания не требуются в модулях EE. При-
нцип преимущества соглашений перед настройками, а также аннотации в программном
коде часто избавляют от необходимости определять настройки в виде дескрипторов
развертывания. Но иногда дескрипторы не только полезны, но и необходимы. Напри-
мер, когда используются возможности CDI, архив должен содержать файл META-INF/
beans.xml или WEB-INF/beans.xml, даже если он пустой, так как он служит индикатором
использования CDI. Это именно тот случай, когда дескриптор развертывания должен
присутствовать обязательно. Другой пример: связывание удаленных компонентов EJB
в разных окружениях и разных серверах. Можно конечно жестко «зашить» информацию
об удаленном сервере в аннотации, но гораздо удобнее создать еще один дескриптор
развертывания для архивов, предназначенных для разных окружений.



13.1.1. Строение системы модулей Java EE

Система модулей Java EE основана на файле EAR, представляющем модуль
верх него уровня, который содержит все остальные модули Java EE, подлежащие
развертыванию. Поэтому, чтобы понять, как действует механизм развертыва-
ния, познакомимся поближе с файлом EAR и начнем с примера из приложения
ActionBazaar.
Приложение ActionBazaar содержит модуль EJB-JAR, веб-модуль, файл JAR со
вспомогательными классами и модуль клиентского приложения. Ниже показана
структура модуля EAR для приложения ActionBazaar:

META-INF/application.xml
actionBazaar-ejb.jar
actionBazaar.war
actionBazaar-client.jar
lib/actionBazaar-commons.jar

Файл application.xml – это дескриптор развертывания, описывающий стандарт-
ные модули, упакованные в файл EAR. 

*. Дескриптор развертывания приложения ActionBazaar в модуле EAR

<application>
  <module>
    <!-- Модуль EJB -->
    <ejb>actionBazaar-ejb.jar</ejb>
  </module>
  <module>
    <!-- Веб-модуль -->
    <web>
      <web-uri>actionBazaar.war</web-uri>
      <context-root>ab</context-root>
    </web>
  </module>
  <module>
    <!-- Модуль клиентского приложения -->
    <java>actionBazaar-client.jar</java>
  </module>
</application>

дескриптор развертывания в модуле EAR явно
идентифицирует каждый артефакт, как модуль определенного типа. Модуль EJB
содержит компоненты EJB с прикладной логикой. Веб-модуль – веб-версию
приложения. Модуль клиентского приложения – еще одну версию приложения,
тонкого клиента с графическим интерфейсом. При развертывании этого модуля
EAR на сервере приложений, сервер будет использовать информацию и дескрип-
тора для развертывания модулей каждого типа.


13.1.2. Загрузка модулей Java EE

В процессе развертывания сервер приложений определяет типы модулей, про-
веряет их и выполняет соответствующие операции, чтобы сделать приложение
доступным для пользователей. Несмотря на то, что конечная цель одна и та же,
разные производители серверов приложений могут по-разному реализовать раз-
вертывание. Однако все они стремятся обеспечить максимальную скорость этой
процедуры.

Модуль EAR с множеством модулей EJB-JAR, WAR, RAR и других, легко может
содержать тысячи отдельных классов. Все эти классы должны быть проанализи-
рованы, загружены и переданы под управление серверу EE, что не так-то просто,
когда разные модули WAR могут содержать разные версии одних и тех же классов.
Далее мы обсудим, как сервер EE решает проблему этого «ада JAR».

--//--

13.2. Загрузка классов

Прежде чем приступить к исследованию порядка загрузки классов сервером EE,
мы сначала узнаем, как действуют загрузчики классов Java, затем рассмотрим ти-
пичные стратегии загрузки классов, используемые серверами EE и, в заключение,
узнаем, как разрешаются зависимости между модулями EE.


13.2.1. Основы загрузки классов

Загрузчики классов в Java следуют модели «сначала родитель». Это означает, что
независимо от того, какой загрузчик выполняется, он сначала предложит загрузить
класс своему родителю. Родитель предложит загрузить класс своему родителю, и
так до тех пор, пока не будет достигнут базовый загрузчик классов (bootstrap class
loader). Если базовый загрузчик не сможет загрузить класс, он вернет управление
вниз по цепочке, и тогда каждый загрузчик получит шанс попытаться загрузить
требуемый класс и, либо завершить процесс загрузки в случае успеха, либо пере-
дать управление на уровень ниже. Если самый первый (нижний) загрузчик потер-
пит неудачу, он возбудит исключение java.lang.ClassNotFoundException . Как
только класс будет найден и загружен, загрузчик сохранит его в локальном кэше
для быстрого доступа. Теперь, когда мы освежили в памяти основы загрузки клас-
сов, рассмотрим более сложную схему загрузки классов в приложениях Java EE.


13.2.2. Загрузка классов в приложениях Java EE

Модули EAR обычно содержат множество модулей EJB-JAR, WAR и RAR, а так-
же сторонние библиотеки поддержки, включающие тысячи классов, и именно
на сервер Java EE возлагается обязанность реализовать такую стратегию загруз-
ки классов, гарантировала бы всем приложениям доступность необходимых им
классов.

---

13.2.3. Зависимости между модулями Java EE

Спецификация Java EE определяет стандартные требования к видимости классов
для всех модулей EE. Например, спецификация требует, чтобы классы были ви-
димы модулю WAR, но не определяет, как загрузчики классов сервера EE должны
обеспечивать эту видимость.

Допустим, что листинг описывает содержимое модуля EAR, который раз-
вертывается на сервере EE. На примере этого листинга мы исследуем наиболее об-
щие требования к видимости классов для модулей EJB-JAR и WAR.

EE Server:
  resource-adapter1.rar:
    // Содержимое и Class-Path адаптеров внешних ресурсов
    /com/**/*.class
    /META-INF/MANIFEST.MF Class-Path:

  resource-adapter2.rar:
    /com/**/*.class
    /META-INF/MANIFEST.MF Class-Path:
   
  action-bazaar.ear:
    /lib/*.jar
      // Содержимое и Class-Path библиотек в каталоге /lib
      /com/**/*.class
      /META-INF/MANIFEST.MF Class-Path:

      ejb-jar1.jar
      // Содержимое и Class-Path модуля EJB-JAR
      /com/**/*.class
      /META-INF/MANIFEST.MF Class-Path:

    ejb-jar2.jar
      // Содержимое и Class-Path модулей EJB-JAR,
      // развертываемых с модулем EAR
      /com/**/*.class
      /META-INF/MANIFEST.MF Class-Path:

    web-app1.war
      /WEB-INF/lib/*.jar
      // Содержимое и Class-Path библиотек в каталоге /WEB-INF/lib
      /com/**/*.class
        /META-INF/MANIFEST.MF Class-Path:
      // Содержимое и каталогf /WEB-INF/classes
      /WEB-INF/classes/**/*.class
      // Class-Path модуля WAR
      /META-INF/MANIFEST.MF Class-Path:

  resource-adaptor-3.rar
    // Содержимое и Class-Path адаптеров ресурсов,
    // развертываемых с модулем EAR
    /com/**/*.class
    /META-INF/MANIFEST.MF Class-Path:


--//--

13.3. Упаковка сеансовых компонентов и компонентов,
управляемых сообщениями


13.3.1. Упаковка EJB-JAR

Модуль EJB-JAR в действительности является самым обычным Java-архивом в
формате JAR. Учитывая, что Java EE следует принципу преимущества соглашений
перед настройками и позволяет использовать аннотации, модуль EJB-JAR может
вообще не включать дескриптор развертывания META-INF/ejb-jar.xml. Когда сер-
вер EE развертывает модуль EAR, он автоматически исследует содержимое архи-
вов JAR и ищет в них аннотации EJB 3 или файл META-INF/ejb.jar.xml, по наличию
которых он определяет, что архив JAR является модулем EJB-JAR
Итак, чтобы создать модуль EJB-JAR, нуж-
но создать обычный архив JAR со следующей структурой:

ActionBazaar.jar:
  com/actionbazaar/ejb/BidServiceEjb.class  <- Сеансовый компонент
  com/actionbazaar/mdb/BidServiceMdb.class  <- Компонент MDB
  META-INF/ejb.jar.xml                      <- Дескриптор развертывания
 

13.3.2. Упаковка компонентов EJB в модуль WAR

Спецификация Java EE 6 позволяет включать сеансовые компоненты и компонен-
ты, управляемые сообщениями, в модуль WAR, вместо того, чтобы развертывать
их из отдельного модуля EJB-JAR. Однако, компоненты, включенные в модуль
WAR, будут выполняться под управлением контейнера EJB Lite. Это означает,
что они будут лишены некоторых функциональных возможностей полноценного
контейнера EJB

Структура типичного
модуля WAR имеет следующий вид:

ActionBazaar.war:
  classes/
    com/actionbazaar/web/ejb/BidServiceEjb.class <- Сеансовый компонент в WAR
    com/actionbazaar/web/mdb/BidServiceMdb.class <- Компонент MDB в WAR
  WEB-INF/web.xml <- Дескриптор развертывания модуля WAR (необязательный)


*. Использование удаленных компонентов EJB в модулях WAR

Поддержка прямого включения компонентов EJB в модули WAR, появившаяся в Java
EE 6, – не единственный способ, хотя и очень удобный. Приложения (особенно широко
используемые и высоконадежные) обычно нуждаются в более значительных вычисли-
тельных мощностях для выполнения прикладной логики, чем необходимо для отобра-
жения веб-интерфейса. Поэтому архитектурно такие приложения нередко делятся на
два кластера: небольшой кластер веб-серверов, где выполняются модули WAR, и более
мощный кластер вычислительных серверов, где выполняются модули EJB. При такой ор-
ганизации модули WAR взаимодействуют с модулями EJB удаленно, посредством ком-
понентов, снабженных аннотацией @Remote.
Если ваше приложение организовано подобным способом, в конфигурацию Maven для
расширения maven-ejb-plugin можно включить параметр <generateClient>true</
generateClient>. Обнаружив этот параметр, Maven упакует все интерфейсы для ком-
понентов EJB в отдельный файл JAR. Модули WAR смогут затем использовать эту зависи-
мость, включающую только интерфейсы, вместо полноценных компонентов EJB.


13.3.3. XML против аннотаций

---

13.3.4. Переопределение настроек, указанных в аннотациях

--- 

13.3.5. Определение интерцепторов по умолчанию

--- 

--//--

13.4. Упаковка сущностей JPA


13.4.1. Модуль доступа к хранимым данным

.
.
.

---

13.7. В заключение

---

--//-------------------------------------------------------------------------

# ГЛАВА 14.
# Использование веб-сокетов с EJB 3


14.1. Ограничения схемы взаимодействий «запрос/ответ»













--//--








стр 505

---

--//-------------------------------------------------------------------------

# Глава 4.
# Обмен сообщениями
# и разработка компонентов MDB










































---
 


[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 