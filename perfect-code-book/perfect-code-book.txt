---
Ресурсы:

// оф сайт
- [ https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D0%BA%D0%BE%D0%BD%D0%BD%D0%B5%D0%BB%D0%BB,_%D0%A1%D1%82%D0%B8%D0%B2 ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ Совершенный код ] это одна из лучших книг по программированию.



1) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 1 ] Добро пожаловать в мир конструирования ПО! 
  - вводная информация
  - Этапы создания ПО:
    1 Выработка требований
    2 Проектирование архитектуры
    3 Конструирование


2) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 2 ] Метафоры, позволяющие лучше понять разработку ПО 
  - Инкрементальный подход к разработке это лучшее, что есть на сегодня
  - Подходящая аналогия к разработке ПО это строительство (дома, небоскреба, будки для собаки)
  - необходимо понимать что мы строим, для этого используется планирование
  - при разработке ПО не нужно писать велосипеды, если есть написанные штуки, надо использовать


3) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 3 ] Семь раз отмерь, один раз отрежь: предварительные условия
  - перед началом создания проекта, надо провести подготовку
    и проверить все ли готово для реализации намеченного плана.
  - мы должны потратить много времени на планирование!
  - необходимо выработать как можно более широкий набор требований к продукту.
  - Первое что мы должны понять, это проблема которую мы хотим решить.
  - Определение проблемы - это формирование сути проблемы без намеков на решение.
  - Определение проблемы - это фундамент всего процесса программирования
  -       ::
         :  :         - Будущие решения
        :    :        - Тестирование системы 
       :      :       - Конструирование
      :        :      - Проектирование архитектуры
     :          :     - Выработка требований
    :            :    - Определение проблемы
   :::::::::::::::: 
  - Проблема должна быть описана на языке пользователя, 
    обычно описание не содержит технических терминов.
  - (*) к проектированию архитектуры переходим после проработки требований !
  - Архитектура — это высокоуровневая часть проекта приложения, 
    каркас, состоящий из деталей проекта.
  - Архитектура должна четко определять ответственность каждого компонента.
  - Компонент должен иметь одну область ответственности и как можно меньше знать 
    об областях ответственности других компонентов.
  - Архитектура должна быть модульной, чтобы можно было заменять модули.
  - Архитектура должна учитывать ресурсы памяти, ЦПУ, коннектов к базе и тд.
  - Архитектура должна определять подход к безопасности как на уровне проекта
    приложения, так и на уровне кода.
  - Производительность: в требованиях следует определить показатели производительности,
    а в архитектуре описать обьяснение, что такая архитектура сможет реализовать требования
  - Масштабируемость: Архитектура должна описывать, как система будет реагировать на рост
    числа пользователей, серверов, сетевых узлов, записей в БД, транзакций и т.д
  - Интернационализация/локализация: в архитектуре должно быть описано как реализуется это.
  - Обработка ошибок: стратегия обработки ошибок должна быть выражена в архитектуре
  - Отказоустойчивость: необходимо описать сценарии ошибок и отказов, которые не должны 
    приводить к потере работоспособности.
  - Возможность реализации архитектуры: нужно быть увереными, что архитектура реализуема.
    Невозможность реализации какого-то компонента может сделать проект неработоспособным.
    (*) как решение это написание прототипов таких можулей или дополнительное исследование.
  - Стратегия изменений: Архитектура должна показывать, что возможные улучшения
    рассматривались и что реализация наиболее вероятных улучшений окажется наиболее простой. 


4) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 4 ] Основные решения, которые приходится принимать при конструировании
  - Необходимо ввести стиль использования выбранного языка программирования.
  - Большинство важных принципов программирования не от конкретных языков, 
    а от способа их использовать.


5) [ Часть 2 ] Высококачественный код
5) [ Часть 2 / Глава 5 ] Высококачественный код
  - Проектирование ПО - под этим обычно понимают разработку или изобретение схемы
    преобразования спецификации приложения в готовое приложение.
  - Проектирование - "грязная" проблема. Прикол в том что такую проблему можно
    определить только через полное или частичное решение.
    (*) получается надо один раз решить проблему, чтобы получить ее ясное представление,
    а потом решить еще раз для создания работоспособного решения.
  - Проектирование это постоянный анализ конкурирующих характеристик проекта и достижение
    баланса между ними.
  - Проектирование подразумевает ограничение возможностей.
  - Проектирование не имеет единствено верного решения, 
    при решении разными разработчиками, получим несколько разных, но решающих проблему програм
  - Проектирование - процесс из проб и ошибок, постепенный процесс
  |
  № 5.2 Основные концепции проектирования:
    - Управление сложностью - самый важный технический аспект разработки ПО.
      Необходимо организовать код так, чтобы можно было безопасно работать с частями.
      Несколько не сложных фрагментов понять проще, чем один сложный.
      (*) Необходимо свести к минимому обьем существенной сложности, 
      с которым придется работать в каждый конкретный момент времени.
      (**) Необходимо сдерживать необязательный рост несущественной сложности.
      (!) все принцыпы програмирования ведут к уменьшению частичной сложности кода.
    - Желательные характеристики проекта
      - @ Минимальная сложность
        Надо создавать простые и понятные проекты
      - @ Простота сопровождения
        При проектировании нельзя забывать о людях из сопровождения
      - @ Слабоя сопряжение
        Сведение к минимому числа соединений между разными частями программы
      - @ Расширяемось
        Внесение наиболее вероятных изменений должно требовать наименьших усилий.
      - @ Возможность повторного использования
        Признах хорошего проектирования программы это когда код легко переиспользовать.
      - @ Высокий коэффициент обьединения по входу
        Хорошо когда созданный нами клас много где используется
      - @ Низкий или средний коэффициент разветвления по выходу
        Плохо когда один класс для своей работы требует ссылки на множество классов
      - @ Портируемость
        Проектировать надо так, чтобы систему можно было легко аадптировать к другой среде.
      - @ Минимальная, но полная функциональность
        Меньше кода - меньше проблем
      - @ Стратификация
        Необходимо разрабатывать систему, чтобы можно разделить по уровням декомпозиции
        Если есть старый или плохой код лучше сделать клас мост, чтобы изолировать его
      - @ Соответствие стандартным методикам
        Необходимо применять стандартные и популяные подходы
  - Уровни проектирования
    - "Уровень 1" Программная система
      Этому уровню соответствует вся система.
    - "Уровень 2" Разделение системы на подсистемы или пакеты
      Результат проектирования на этом уровне - определение основных подсистем
      Особенно важно определить правила взаимодействия и ограничивать эти связи
      Архитектура системы должна быть такой, чтобы замена подсистемы была максимально простой
      часто используемые варианты подсистем:
      - @ Подсистема пользовательского интерфейса
        изоляция GUI органична и удобна
      - @ Подсистема доступа к БД
        изоряция общения с БД отличная идея
      - @ Подсистема изоляции зависимостей от ОС
        Так как потом велик шанс задачи адоптации под другую ОС
    - "Уровень 3" разделение подсистем на классы
      Это уже уровень, где мы определяем необходимый набор классов   
      На этом уровне должно быть понятно как реализовать систему на уровне классов
    - "Уровень 4" разделение классов на методы
      Надо определить методы классов, можно этот уровень комбинировать с предыдущем
    - "Уровень 5" проектирование методов
      На этом уровне детально проектируется функциональность методов
      Например пишется псевдогод
  |  
  № 5.3 Компоненты проектирования: эвристические принципы
    Проектирование не является детерминированным
    - @ "1" Определите обьекты реального мира
      при проектировании определяем:
        - объекты и их атрибуты (методы и данные)
          (*) однозначное соответствие обьектов реального мира и программы
          подходит для начала, но обычно это не лучшая идея
        - действия, которые могут быть выполнены над каждым объектом
          (*) например обьект сотрудник может поддерживать операцию смены имени
        - действия, которые каждый объект может выполнять над другими объектами
          (*) какой обьект может включать другой обьект,
          какой обьект может выполнять действия над другим обьектом
        - части каждого объекта, видимые другим объектам
        - открытый интерфейс каждого объекта
          (*) для каждого обьекта надо определить формальный синтаксический интерфейс
    - @ "2" Определите согласованные абстракции
      Создание абстракций позволяет работать с обьектами не вдаваясь в подробности
    - @ "3" Инкапсулируйте детали реализации
      Инкопсуляция помогает управлять сложностью блокируя доступ к ней
    - @ "4" Используйте наследование, если оно упрощает проектирование
      При правильном использовании принесет большую пользу
   - @ "5" Скрывайте секреты (к вопросу о сокрытии информации)
     Это мощный принцып, который подчеркивает необходимость сокрытия сложности
     Секретом может быть источник вероятных изменений, формат файла, алгоритм и т.д
     Класс может использовать несколько типов данных не раскрывая сведений о них
     Интерфейс класса должен сообзать как можно меньше о внутренней работе класса
     Класс должен быть похож на айсберг
   - @ "6" Определите области вероятных изменений
     Находим элементы, изменение которых кажется вероятным
     Отделяем эти элименты, чтобы при изменении как можно меньше менять
     Спроектировать интервейс который будет не зависеть от изменений
     - Чаще всего меняется:
       - Бизнес правила
       - Зависимости от оборудования
       - Ввод-вывод
       - Нестандартные возможности языка
       - Сложные аспекты проектирования и конструирования
       - Переменные статуса
       - Размеры структур данных
   - @ "7" Поддерживайте сопряжение слабым
     Сопряжение характерезует силу связи класса или метода с другими классами или методами
     Стараться создавать модули, слабо зависящие от других
     Критерии оценки сопряжения:
     - Обьем
       Обьем связи характерезует число связей, чем меньше тем лучше
       Метод, принимающий один параметр, слабее сопряжен чем метод с двумя параметрами
       Класс предоставляющий два публичных метода меньше сопряжен чем класс с 5 методами
     - Видимость
       Видимостью называют заметность связи между двумя модулями
       Необходимо делать связи как можно более очевидными и заметными
     - Гибкость
       Гибкость характерезуется легкостью изменения связи между модулями
       Идеальная связь должна быть как можно гибче
       Чем проще вызвать модуль из других модулей, тем лучше
     Выводы сопряжения:
     - Простое сопряжение посредством данных-параметров
       Означает, что между модулями передаются только элементарные типы данных
       (*) ВЫВОД: нормален и приемлен
     - Простое сопряжение посредством обьекта
       Означает, что модуль создает экземпляр данного обьекта
       (*) ВЫВОД: нормален и приемлен
     - Сопряжение посредством обьекта-параметра
       Два модуля сопряжены между собой обьектом-параметром
       Обьект-1 требует чтобы Обьект-2 передал ему Обьект-3
       (*) ВЫВОД: Это сопряжение уже жесче и менее желательно
     - Семантическое сопряжение
       Это самы коварный тип сопряжения
       Один модуль использует некоторые семантические знания о внутренней работе этого модуля
       (*) ВЫВОД: Опасно именть такие связи, надо избегать
     Надо стримиться к малой связанности, чтобы независимо работать над разными кусочками
   - @ "8" Старайтесь использовать популярные шаблоны проектирования
     Есть проблемы, требующие новых решений, но большинство уже решалось
     Шаблоны снижают сложность, предоставляя готовые абстракции
     Шаблоны снижают число ошибок, стандартезируя детали популярных решений
     Использование шаблонов, похоже на использование стандартной библиотеки
     Шаблоны имеют эврестическую ценность, указывая на возможные варианты проектирования
     Код разработтаный на популярном шаблоне, будет понятнее, чем код, разработтаный без
     Шаблоны упрощают взаимодействие между разработчиками
   - @ "9" Другие эвристические принципы
     1 Стремитесь к максимальной связности, тоесть насколько сфокусирован клас или модуль
       Связанность характерезует насколько методы и части класса соответствуют цели класса
     2 Формируйте иерархии
       Иерархия это многоуровневая структура представления информации
       Иерархия уже тысячи лет основной механизм управления сложностью
       Иерархия не устраняет деталея - она просто выталкивает их на другой уровень
     3 Формализуйте контракты классов
       Интерфейс каждого класса это его контракт взаимодействия с другими классами
     4 Грамотно назначайте сферы ответственности
     5 Проектируйте систему для тестирования
       Проектирование длятестирования часто приводит к разработке 
       более формализованных интерфейсов классов, что обычно выгодно
     6 Избегайте неудач
       Необходимо обдумывать сложные куйсы, которые могут привести к аварии
     7 Тщательно выбирайте время связывания
       Временем связывания называют, когда переменной присваивается конкретное значение
       Раннее связывание упрощает код, но снижает его Гибкость
     8 Создайте центральные точки управления
       Звучит как конфиг (application.yaml)
     9 Подумайте об использовании грубой силы
       Работающее решение с грубой силой лучше не работающего
     10 Рисуйте диаграммы
       Это мощный эвристический инструмент, лучше один раз увидеть, чем 100 раз услышать
     11 Поддерживайте модульность проекта системы
       Каждый метод или класс должен быть похож на "черный ящик"
  |
  № 5.4 Методики проектирования
  - Используйте итерацию
    Выполнив проектирование несколько раз вы повысите качество
    Если первая попытка окажется удачной не стоит останавливаться, вторая будет лучше
  - Разделяй и властвуй
    Надо разделить программу на разные области и спроектированть их по отдельности
    Инкрементальное улучшение - мощное средство управления сложностью
  - Нисходящий и восходящий подходы к проектированию
    От общего виденья к деталям или от корневых можелей к общему виду       
    Оба подхода приемлемы
  - Эксперементальное протипирование
    Мы не можем определить проблему проектирования, пока не решите ее хоть частичное
    Прототип надо выкидывать, но почти всегда его продолжают
  - Совместное проектирование
    Две головы лучше, чем одна
    Собрание с обсуждением идей или ревью и инспекция это отлично
  - Какую степень проектирования считать достаточной
    Есть множество факторов влияющих на необходимый уровень детализации
    Факторы: уровень разработчиков, сроки, размер проекта, критичность ошибки в проекте 
    Редко встречаются проекты страдающие от чрезмерного проектирования
  - Регистрация процесса проектирования
    Сохраняйте схемы текст картинки в wiki
  |
  № 5.5 Комментарии по поводу популярных методологий
  - Проектировать все или проектировать ничего, вывод проектировать в достаточной степени


6) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 6 ] классы
  № 6.1 Основы классов: абстрактные типы данных
  АТД - абстрактный тип данных (похоже реч тут идет о структурах)
  Частая ошибка это смотреть на АТД, как на контейнер хранения разношерстных методов
  - Преимущества использования АТД
    1 Возможность сокрытия деталей реализации
    2 Ограничение области видимости
    3 Более высокая информативность интерфейса
    4 Легкость оптимизации кода
    5 Легкость проверки кода
    6 Удобочитаемость и понятность кода
    7 Ограничение области использования данных
    8 Возможность работы с сущностями реального мира, 
      а не с низкоуровневыми деталями реализации  
  |    
  № 6.2 Качественные интерфейсы классов
  Первый и самый важный шаг при создании класса, создание интерфейса класса
  - Принцыпы:
   1 Выражайте в интерфейсе класса согласованный уровень абстракции
     В идеале каждый класс должен быть реализацией только одного АТД
   2 Убедитесь, что вы понимаете, реализацией какой абстракции является класс
   3 Представляйте методы вместе с противоположным им методом
   4 Убирайте посторонюю информацию в дркгие классы
     Иногда можно заметить что в классе ряд методов работает с одной половинной
     данных, а другой набор с другой половиной, значит надо разделить класс на два
   5 По мере возможности делайте интерфейсы программными, а не семантическими
     Семантический интерфейс может включать такие соображения, 
     как «Метод А должен быть вызван перед Методом B» или «Метод А вызовет ошибку
     Семантический интерфейс надо документировать, а лучше не использовать
   6 Опасайтесь нарушения целостности интерфейса при изменении класса
     Класс мог быть хорошей абстакцией с понятным интерфейсом, но после правок 
     привратиться в монстра, поэтому изменение интерфейса очень ответственный шаг
   7 Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса
   8 Рассматривайте абстракцию и связность вместе
  Хорошая инкапсуляция
  - Принцыпы:
    1 Минимизируйте доступность классов и их членов
    2 Не делайте данные-члены открытыми
    3 Не включайте в интерфейс класса закрытые детали реализации
      Надо разделять интерфейс и реализацию
    4 Не делайте предположения о клиентах класса
    5 Избегайте использования дружественных классов
    6 Не делайте метод открытым лишь потому, что он использует только открытые методы
    7 Цените легкость чтения кода выше, чем удобство его написания
    8 Очень, очень настороженно относитесь к семантическим нарушениям инкапсуляции
      Мы можем написать свой код, зная об особенностях реализации другого кода, 
      что не допустимо, так как руководствоваться должны только публичным АПИ
      Если по апи класса не понятно, как работать с классом это плохое апи, переделываем
    9 Остерегайтесь слишком жесткого сопряжения  
      - минимизируйте доступность классов и их членов
      - избегайте дружественных классов, потому что они связаны жестко
      - делайте данные базового класса закрытыми, а не защищенными: это ослабляет 
        сопряжение производных классов с базовым
      - не включайте данные члены в открытый интерфейс класса
      - остерегайтесь семантических нарушений инкапсуляции
  |    
  № 6.3 Вопросы проектирования и реализации
  В этом разделе обсудим как реализовать внутреннее устройство классов
  - Включение (отношение "содержит")
    Один класс содержит примитивный элемент данных или другой класс
    Включение - один из главных инструментов ООП
    - Реализуйте с помощью включеия отношение "содержит"
      Например обьект "Сотрудник" может содержать "Фамилия"
    - В крайнем случае реализуйте отношение "Содержит" через закрытое наследование
      Если вам приходится это делать, обычно указывает на ошибки проектирования  
    - Насторожено относитесь к классам, содержащим более семи элементов данных-членов
      Человек может удерживать в памяти 7 +/- 2 дискретных элементов
  - Наследование (отношение "является")
    Наследование подразумевает, что один класс является более специализированным вариантом
    - Реализуйте при помощи открытого наследования отношение "является"
      Базовый класс формирует ожидания и ограничения, которым будет соответствовать
      производный класс
      (!) Если производный класс не собирается полностью придерживаться контракта,
      определенного интерфейса базового класса, наследование выполнять не стоит
    - Проектируйте и документируйте классы с учетом возможности наследования или запретить
    - Соблюдайте принцип подстановки Лисков
      1 Наследование стоит использовать, только если производный класс действительно
        "является" более специализированной версией базового класса
      2 Клиенты должны иметь возможность использования подклассов через интерфейс
        базового класса, не замечая никаких различий
      3 При соблюдении принципа подстановки Лисков наследование - сильно снижает сложность
    - Убедитесь, что вы наследуете только то, что хотите наследовать
      (*) Ели вам нужна реализация класса, но не его интерфейс, используйте Включение
    - Не "переопределяйте" непереопределяемые методы-члены
      Не используйте имена непереопределяемых методов базового класса в производных
    - Перемещайте общие интерфейсы, данные и формы поведения на как можно более
      высокий уровень иерархии наследования
    - С подозрением относитесь к классам, обьекты которых создаются в единственном
      экземпляре (singleton - исключение)
    - С подозрением относитесь к базовым классам, имеющим толко один производный класс
      Похоже кто-то проектировал наперед, это плохая практика - больше кода больше проблем
    - С подозрением относитесь к классам, которые переопределяют метод, оставляя пустым
      Это почти точно ошибка проектирования
      Это звоночек нарушении контракта базового класса
    - Избегайте многоуровневых иерархий наследования
      Большенству людей трудно удержать в голове больше 3 уровней
      Надо помнить, что наследовоние должно уменьшать дублирование и сложность  
    - Предпочитайте полиморфизм, а не крупномасштабную проверку типов
      Наличие блоков "case" почти всегда говорит об ошибке проектирования
    - Делайте все данные закрытыми, а не защищенными
    - Множественное наследование
      Наследование - мощный и довольно опасный инструмент
      Лучше не прибегать к множественному наследованию  
  - Методы-члены и данные-члены 
    - Включайте в класс как можно меньше методов
    - Блокируйте неявно сгенерированные методы и операторы, которые вам не нужны
    - Минимизируйте число разных методов, вызываемых классов
    - Избегайте опосредованных вызовов методов других классов
      «Правило Деметры (Law of Demeter)», которое гласит, что Объект A может вызывать 
      любые из собственных методов. Если он создает Объект B, он может вызывать любые 
      методы Объекта
    - Вообще минимизируйте сотрудничество класса с другими классами
      Минимизируйте число видов создаваемых обьектов
      Минимизируйте число непосредственно вызываемых методов созданных обьектов
      Минимизируйте число вызовов методов, принадлежащих обьектам, возвр другими обьектами
  - Конструкторы
    - Инициализируйте по мере возможности все данные-члены во всех конструкторах
    - Создавайте классы одиночки с помощью закрытого конструктора
    - Если сомневаетесь, выполняйте полное копирование, а не ограниченное
      Ограниченное копирование - обычно получение ссылки на обьект
  |    
  № 6.4 Разумные причины создания классов
  Причины
    - Моделирование обьектов реального мира
      Это не главная но основная причина
    - Моделирование абстрактных обьектов
      Пример такого класса "Фигура"
    - Изоляция сложности
    - Сокрытие деталей реализации
    - Ограничение влияния изменений
    - Сокрытие глобальных данных
    - Упрощение передачи параметров в методы
    - Создание центральных точек управления
    - Облегчение повторного использования кода
    - Планирование создания семейства программ   
      Рассуждения о том как может выглядеть семейство таких программ как наша, полезно   
    - Упаковка родственных операций
      Плошая практика, но лучше чем не делать этого над блуждающими методами 
    - Выполнение специфического вида рефакторинга
  Классы, которых следует избегать  
    - Избегайте создания "божественных" классов
      Универсальный всемогущий класс это беда для проекта, разбить на классы по одной цели
    - Устраняйте неревантные классы
    - Избегайте классов, имена которых напоминают глаголы
      Похоже это должен быть не класс а метод класса
  |    
  № 6.5 Аспекты, специфические для языков
  - не важно
  |    
  № 6.6 Следующий уровень: пакеты классов
  Использование классов - лучший способ достижения модульности
  Если язык не поддерживает пакеты, поддерживайте их сами


7) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 7 ] Высококачественные методы
  |    
  № 7.1 Разумные причины создания методов
  - Снижение сложности
  - Формирование понятной промежуточной абстракции
  - Предотвращение дублирования кода
  - Поддержка наследования
  - Сокрытие очередности действий
  - Сокрытие операций над указателями
  - Улучшение портируемости
  - Упрощение сложных булевых проверок
  - Повышение быстродействия
  - Для уменьшения обьема других методов
  |    
  № 7.2 Проектирование на уровне методов
  Метод должен эфективно делать одну четкую задачу
  Есть разные виды связанности
  - Функциональная связанность 
    Это самый сильный и лучший вид
    Это когда метод имеет обну функцию и выполняет ее
    Примеры  GetCustomerName(), EraseFile(), AgeFromBirthdate()
  - Последовательная связанность
    Вид связи не желателен, но приемлем
    Это плохой вид связанности, суть в том что действия в методе связаны порядком вызова
    Надо сделать из такого метода несколько отдельных методов
  - Коммуникационная связанность
    Вид связи не желателен, но приемлем
    Это когда мы используем одни и те же данные и операции не связаны другим способом
    Две операции в методе обьеденяет только то, что они обращаются к одним данным
    Такой метод надо разделять на отдельные
  - Временная связанность
    Вид связи не желателен, но приемлем
    Обьединение на основании, что все они выполняются в один интервал времени
    Пример: Startup(), Shutdown()
    Решение это не делать в методе вызов действий напрямую, а пусть читается конфиг
    и уже исходя из конфига делается набор действий
  |    
  № 7.3 Удачные имена методов
  - Описывайте все, что метод выполняет   
  - Избегайте невыразительных и неоднозначных глаголов
    Невыразительное имя означает не ясную цель метода, а это плохой метод
  - Не используйте для дифференциации имен методов исключительно номера
    Дич, нечего обсуждать
  - Не ограничивайте длину имен методов искусственными правилами
  - Для именования функции используйте описание возвращаемого значения
    Пример: customerId.Next(), printer.IsReady() и pen.CurrentColor()
  - Для именования процедуры используйте выразительный глагол, дополняя его объектом
    Формату «глагол + объект»
    Пример: document.Print(), orderInfo.Check() и monthlyRevenues.Calc().
  - Дисциплинированно используйте антонимы
    Пример популярных антонимов:
     - add/remove      increment/decrement   open/close
     - begin/end       insert/delete         show/hide
     - create/destroy  lock/unlock           source/target
     - first/last      min/max               start/stop
     - get/put         next/previous         up/down
     - get/set         old/new
  - Определяйте конвенции именования часто используемых операций
    В Java конвенция есть по дефолту
  |    
  № 7.4 Насколько обьемным может быть метод?
  Отсекаем все лишнее, что осталось то и оставляем
  Большие методв больше 200 строк почти точно надо разбивать
  |    
  № 7.5 Советы по использованию параметров методов
  Интерфейсы между методами — один из основных источников ошибок
  Советы:
  - Передавайте параметры в порядке 
    «входные значения - изменяемые значения — выходные значения»
    (*) Это больше актуально для C++, но в java тоже можем так писать
  - Если несколько методов используют похожие параметры, передавайте
    их в согласованном порядке  
  - Используйте все параметры
    Наличие неиспользуемого параметра это звоночек, надо его удалить
  - Передавайте переменные статуса или кода ошибки последними
  - Не используйте параметры метода в качестве рабочих переменных
    другими словами НЕ модифицируй входные параметры без супер необходимости
    копируем значение во внутренние переменные и работаем
  - Документируйте выраженные в интерфейсе предположения о параметрах
    Что документировать:
    - вид параметров: являются ли они исключительно входными, изменяемыми или 
      исключительно выходными
    - единицы измерения (дюймы, футы, метры и т. д.)
    - смысл кодов статуса и ошибок, если для их представления не используются перечисления
      диапазоны допустимых значений
    - специфические значения, которые никогда не должны передаваться в метод
  - Ограничивайте число параметров метода примерно семью
    Если вам постоянно приходится передавать в методы слишком большое число
    аргументов, ваши методы имеют слишком сильное сопряжение. 
    Проектируйте методы или группы методов так, чтобы сопряжение было слабым
    (*) Если вы передаете одни и те же данные во многие разные методы, 
        сгруппируйте эти методы и данные в класс.
  - Подумайте об определении конвенции именования входных, изменяемых и выходных параметров
    Для Java не очень актуально (обычно не модефицируем обьект переданный в аргументах)
  - Передавайте в метод те переменные или объекты, которые нужны ему
    для поддержания абстракции интерфейса
    (*) тут есть два подхода
    У нас есть метод которому нужно скажем три поля из обьекта и вопрос передавать
    весь обьект как аргумент или только эти поля?
    - Первый (только поля)
      - это поддерживает минимальное сопряжение
      - способствует более быстрому пониманию методов
      - облегчает повторное использование
      - (*) передача всего обьекта нарушает принцып инкапсуляции
        так как мы получим обьект и получим доступ к полям, которые нам не нужны
    - Второй (весь класс)
      - удобно
      - ничего не нарушает
    - ВЫВОД
      - обы подхода не верные 
      - какую абстракцию формирует интерфейс метода?
      - Обычно наличие кода, «подготавливающего» данные перед вызовом метода 
        или «разбирающего» объект после вызова, — признак неудачного 
        проектирования метода.
  - Используйте именованные параметры
  - Убедитесь, что фактические параметры соответствуют формальным
    - это переменные, объявленные в определении метода
    - Для Java не актуально
  |    
  № 7.6 Отдельные соображения по использованию функций
  Тут вводим термины шаткие
    - Функция - это метод, возвращающий значение
    - Процедура - это метод, не возвращающий значение
  Когда использовать функцию, а когда процедуру?
    - Если основная цель вернуть значение используем функцию
  Возврат значения из функции
    - Проверяйте все возможные пути возврата
      - проверяем все сценарии выполнения ф-ии
    - Не возвращайте ссылки или указатели на локальные данные
      - (*) не актуально для Java
  |    
  № 7.7 Методы-макросы и встраиваемые методы
  - Разрабатывая макрос, заключайте в скобки все, что можно
    - " #define Cube( a ) a*a*a " отработет не верно, если заюзать Cube( 4+1 )
      так как это просто текстовая замена порядок действий удивит
  Все что дальше описано не актуально для Java
  

8) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 8 ] Защитное программирование
  |    
  № 8.1 Защита программы от неправильных входных данных
  Идея защитного программирования в том, что если методу передаются
  некорректные данные, то его работа не нарушится, даже если эти данные 
  испорчены по вине другой программы.
  Основные способы обработки входных данных:
  - Проверяйте все данные из внешних источников
    Проверяем все значения, что они попадают в допустимый интервал
    Проверяем что строки не больше определенной длины
    Проверить например SQL иньекци и т.д
  - Проверяйте значения всех входных параметров метода
    Дальше в 8.5 узнаем в каких методах важно проверять аргументы
    Это то же самое, что и прошлый пункт для данных, только тут для аргументов
  - Решите, как обрабатывать неправильные входные данные
    Что делать, если пришел неверный праметр, ответов миллион
  |    
  № 8.2 Утверждения
  Утверждения - это код, используемый во время разработки, для проверки выполнения
  Утверждения полезны, когда есть высокие требования к надежности
  Пример на Java:
    - assert denominator != 0 : ”denominator is unexpectedly equal to 0.”;
  Утверждения не предназначены для показа сообщений в промышленной версии
  При компиляции промышленной версии, обычно, утверждения удаляют
  Общие принципы использования утверждений
  - Используйте процедуры обработки ошибок для ожидаемых событий и утверждения 
    для событий, которые происходить не должны
    (*) Утверждения проверяют условия событий, которые никогда не должны происходить
  - Старайтесь не помещать выполняемый код в утверждения
    Есть вероятность что компилятор удалит этот код при отключении утверждений
  - Используйте утверждения для документирования и проверки предусловий и постусловий
    1 Предусловия — это обязательства клиентского кода перед кодом, который он вызывает
    2 Постусловия — это обязательства метода или класса перед кодом, который их использует
    3 Утверждения — удобный инструмент для документирования пред- и постусловий
  - Для большей устойчивости кода проверяйте утверждения, а затем все равно 
    обработайте возможные ошибки
  |    
  № 8.3 Способы обработки ошибок
  Способы:
    - Вернуть нейтральное значение
      Нам пришли не верные данные, а мы возвращаем приемлемое-нетральное значение
      Надо подумать о последствиях и возможно лучше остановить программу
    - Заменить следующим корректным блоком данных
      Если мы получаем непрерывно данные мы можем игнорировать ломанные данные
    - Вернуть тот же результат, что и в предыдущий раз
      Получаем значения раз в сек, есл пришла ерунда, оставляем старое значение
    - Подставить ближайшее допустимое значение
    - Записать предупреждающее сообщение в файл (в лог)
      Этот подход можно сочетать с другими  
    - Вернуть код ошибки
      Тут важно определить какая часть системы будет обрабатывать ошибки
    - Вызвать процедуру или обьект - обработчик ошибки
      Создаем мега класс и обрабатываем ошибочки, подход сомнительный
    - Показать сообщение об ошибке, где бы она ни случилась
      Тоже сомнительный подход
    - Обработать ошибку в месте возникновения наиболее подходящим способом
    - Прекратить выполнение
      Оправдано в очень критичном к безопасности ПО
  Устойчивость против корректности
    Выбор подходящего метода обработки ошибки зависит от приложения
    Корректность предпологает, что нельзя возвращать не точный результат
    Устойчивость говорит о том, что программа пытается продолжить работу не смотря
  Влияние выбора метода обработки ошибок на проектирование высокого уровня
    Способ обработки ошибок влияет на требования корректности и устойчивости 
    Выбор общего подхода к работе с некорректными данными - это вопрос архитектуры 
  |    
  № 8.4 Исключения
  Исключение - это способ метода сказать "Я не знаю, что с этим делать"
  Исключения с наследование мощные инструменты, мугут сильно влиять на общую сложность
  Советы:
    - Используйте исключения для оповещения других частей программы об ошибках, 
      которые нельзя игнорировать  
    - Генерируйте исключения только для действительно исключительных ситуаций
      Если мы никак не можем другими средствами решить проблему, кидаем исключение
    - Не используйте исключения по мелочам
      Если ошибку можем исправить на месте, то ислючение не нужно
    - Избегайте генерировать исключения в конструкторах и деструкторах,
      если только вы не перехватываете их позднее
    - Генерируйте исключения на правильном уровне абстракции
      Интерфейс метода и класса должен представлять собой целостную абстракцию. 
      Исключения — такая же часть интерфейса, как и специальные типы данных
      Плохой пример:
        - public TaxId GetTaxId() throws EOFException
          (*) вместо "EOFException" метод должен кидать искл своего уровня абстракции,
          например "TaxIdNotFoundException"
    - Вносите в описание исключения всю информацию о его причинах
      В идеале из исключения должно быть понятно как его исправить
    - Избегайте пустых блоков "catch"  
      Хотя бы оставьте комментарий, почему это не может быть исправлено
    - Выясните, какие исключения генерирует используемая библиотека
    - Рассмотрите вопрос о централизованном выводе информации об исключениях        
    - Стандартизуйте использование исключений в вашем проекте
      Способы:
      1 Создание базового класса для всех исключений
      2 Определите конкретные случаи, когда код может использовать try-catch локально
      3 Определите случаи когда нужно кудать исключение наружу
      4 решите будет ли использоваться централизованный генератор сообщений
    - Рассмотрите альтернативы исключениям
  |    
  № 8.5 Изоляция повреждений, вызванных ошибками
  Иззоляция повреждений, или баррикада, - это стратегия, сходная с тем как
    изолируют отсеки в трюме корабля
  Один из способов изоляции в целях защитного программирования состоит в разработке
    набора интерфейсов в качестве оболочки для безопасных частей кода
  Пример:
    ----------------  /                           \   --------------
    | Графический  |  \     ---------------       /   | Внутренний |
    | интерфейс    |  /     | Проверочный |       \   | Класс 1    |
    | пользователя |  \     | класс 1     |       /   --------------
    ----------------  /     ---------------       \         .
           .          \           .               /         .
           .          /           .               \         .
           .          \           .               /         . 
    ----------------  /     ---------------       \   --------------
    | Внешние      |  \     | Проверочный |       /   | Внутренний |
    | Файлы        |  /     | класс N     |       \   | Класс N    |
    ----------------  \     ---------------       /   -------------- 
    Выделение части кода для работы с непроверенными данными, так другая
    часть программы будет свободна от проверок
  (*) Такойже пожход можно применить на уровне класса, когда публичные методы 
      имеют проверки, а внутреннии уже нет       
  Удачная аналогия это аперационная, данные перед попаданием туда стериализуются и
    все, что находится в операционной считается безопасным, так как прошло проверку 
  - Преобразовывайте входные данные к нужному типу в момент ввода
    Сохранение данных в неопределенной форме сильно усложняет программу
  - Связь между барикадами и утверждениями
    Применение баррикад делает отчетливым различие между утверждениями 
      и обработкой ошибок
    Методы внцтри баррикад, должны использовать утверждения, так как поидее
    там будут проверенные данные и утверждения никогда не должны сработать,
    а снаружи исключения и их надо обрабатывать 
  - использование баррикард - это архитектурное решение
  |    
  № 8.6 Отладочные средства
  - Не применяйте ограничения промышленной версии к отладочной версии автоматически
    Промышленая версия должна работать быстро, а отладочная может позволить
      работать медленно.
    Промышленная версия должна быть экономна к ресурсам, отладочная нет
    Отладочная версия может предоставлять дополнительные возможности
  - Внедрите поддержку отладки как можно раньше
  - Используйте наступательное программирование
    Суть: Исключительные случаи должны обрабатываться так, чтобы во время 
      разработки они были очевидны, а в промышленном коде — позволяли продолжить работу
    Допустим есть "case" с 5 вариантами а по дефолту пишем в лог "Что-то не так!"    
    Вот приемы наступательного программирования:
      - Сделайте проблему достаточно мучительной, чтобы ее исправили. 
      - Заполняйте любую выделенную память, чтобы можно было обнаружить ошибки
          выделения памяти.
      - Заполняйте все файлы и потоки, чтобы выявить ошибки файловых форматов.
      - Настройте программу на отправку вам журналов ошибок по электронной почте
  - Запланируйте удаление отладочных средств
    - Для контроля версий и сборки программы используйте инструменты ant и make
      Система контроля версии - git
      Ant средство сборки, сейчас актуален maven, gradle
    - Используйте встроенный препроцессор
      Для Java не актуально
  |    
  № 8.7 Доля защитного программирования в промышленной версии
  - Оставьте код, которые проверяет существенные ошибки
  - Удалите код, проверяющий незначительные ошибки
  - Удалите код, приводящий к прекращению работы программы
    Почти всегда надо дать пользователю сохранить свои изменения перед падением
  - Оставьте код, который позволяет аккуратно завершить работу программы
  - Регистрируйте ошибки для отдела технической поддержки
  - Убедитесь, что оставленные сообщения об ошибках дружелюбны
  |    
  № 8.8 Защита от защитного программирования
  Избыток защитного программирования сам по себе создает проблемы
  Подумайте, где надо защищаться, и соответственно расставьте приоритеты 
    защитного программирования


9) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 9 ] Процесс программирования с псевдокодом
  |    
  № 9.1 Этапы создания классов и методов
  К конструированию классов можно подходить по#разному, но обычно это 
    итеративный процесс создания общей структуры класса, создание списка
    его методов, их конструирование и проверка класса как единого целого.

                              Начало
                                |
                               (.)
                       -------------------
                       | Создание        |
              |------->| Общей структуры |-------|
              |        | класса          |       |  
              |        -------------------       |   
              |                     ^            | 
              |                     |           (.) 
       -------------------          |   -------------------
       | Конструирование |          |---| Конструирование |
       | процедур        |<-------------| процедур        |
       | класса          |------------->| класса          |
       -------------------              -------------------
                |
                |
                |
                 ----> Завершение
  Этапы создания классов
    - Создание общей структуры класса 
      Определить ф-ии класса
      Определить будет ли он наследоваться
      Определить точный уровень абстракции
    - Конструирование всех методов класса
      Определив основные ф-ии надо переходить к конструированию методов
    - Оценка и тестирование всего класса
      В момент, когда класс становиться работоспособным, его надо протестировать
  Этапы построения метода
          
               Начало
                 |
                (.)
         -------------------              -------------------
         | Проектирование  |<-------------| Проверка        |
         | метода          |              | структуры       |
         |                 |------------->|                 |  
         -------------------              -------------------
             (.)                                 |
              |        При необходимости         |
              |            повторить             |
              |                                 (.) 
         -------------------              -------------------
         | Пересмотр       |<-------------| Кодирование     |
         | и тестирование  |              | метода          |
         | кода            |------------->|                 |
         -------------------              -------------------
                |
                |
                |
                 ----> Завершение
    Есть много подходов, но любимый подход автора, это начинать с псевдокода
  |    
  № 9.2 Псевдокод для профи
    - Применяйте формулировки, в точности описывающие отдельные действия
    - Избегайте синтаксических элементов языков программирования
    - Пишите псевдокод на уровне намерений
    - Пишите псевдокод на очень низком уровне с деталями
  (*) Пример хорошего псевдокода:
  Отслеживать текущее число используемых ресурсов
  Если другой ресурс доступен
    Выделить структуру для диалогового окна
    Если структура для диалогового окна может быть выделена
      Учесть, что используется еще один ресурс
      Инициализировать ресурс
      Хранить номер ресурса в вызывающей программе
    Конец «если»
  Конец «если»
  Вернуть true, если новый ресурс был создан; иначе вернуть false    
  (!) Выгоды от написания псевдокода в таком стиле:
    - Псевдокод упрощает пересмотр конструкции
    - Псевдокод поддерживает идею итеративного усовершенствования.
    - Псевдокод упрощает внесение изменений
      Одна из основ успеха отловить ошибку как можно раньше
  |    
  № 9.3 Конструирование методов с использованием ППП
  Пункты:
    1 проектирование метода
    2 кодирование метода
    3 проверка кода
    4 наведение глянца
    5 повторение предыдущих шагов при необходимости
  Проектирование метода
    Определив состав методов, начинаем их проектировать
    Как пример возьмем метод "ReportErrorMessage()" принимающий код ошибки и
      выводящий сообщение, соответствующие ошибки или в консоль или в файл
    - Проверка предварительных условий
      Убедитесь, что функции метода четко определены и соответствуют общим 
      проектным решениям.
    - Определите задачу, решаемую методом
      - задачу, решаемою методом, чтобы перейти к решению
      - информацию, скрываеммую методом
      - входные и выходные данные
      - предусловия,которые гарантированно должны соблюдаться
          до вызова метода
      - Постусловия, которые гарантированно должны соблюдаться, прежде чем
          метод вернет управление
      (*) для нашиго метода-примера получаем:
        1 метод скрывает текст сообщения и текущий метод обработки 
          (интерактивный или командной строки)
        2 выполнение каких либо предусловий не требуется
        3 входными данными является код ошибки
        4 выходные данные двух видов: сообщение об ошибке и статус, возвращаемый
          "ReportErrorMessage()" вызывающей программе
        5 возвращаемый статус должен принимать одно из двух значений: 
          Success или Failure
    - Название метода
      Хорошее наввание - признак высокого стиля программирования
      Если трудно подобрать имя это сигнал, что мы не понимаем что метод делает
      (*) для нашиго метода-примера получаем: 
        "ReportErrorMessage()" - хорошее имя
    - Решите, как тестировать метод
      В процессе написания думайте как будете тестировать
    - Исследуйте функциональность, предоставляемую стандартными библиотеками
      Основное правило улучшить качество кода это использовать библиотеки
    - Продумайте обработку ошибок
      Подумайте обо всем плохом, что может случиться с вашим методом
      Есть много подходов обработки ошибок, надо определиться и использовать
    - Думайте об эффективности 
      Когда-то эффективность это скорость, а когда то память, а иногда что-то третье 
      (*) надо убедиться что интерфейс получается максимально абстрактным,
          чтобы потом можно было бы улучшить реализачию
      Не трать время на методы, пока можно менять верхнеуровневый дизайн     
    - Исследуйте алгоритмы и типы данных
      Ищем в стандартной библиотеке языка, есл нет, то реализуем
    - Пишите псевдокод
      (*) для нашиго метода-примера получаем: 
    [  
      Установить статус по умолчанию в “сбой”.
      Найти сообщение, соответствующее коду ошибки.
        Если код ошибки корректен
          Если работа в интерактивном режиме, вывести сообщение
          и указать успешный статус.
       
          Если работа в режиме командной строки, запротоколировать
          сообщение об ошибке и указать успешный статус.
      Если код ошибки некорректен, информировать пользователя
      об обнаружении внутренней ошибки.
      
      Вернуть статус
    ]
    - Продумайте применение данных
      Надо продумать основные фрагменты данных до построения логики метода
    - Проверьте псевдокод
      Попробуйте обьяснить логику метода, убедитесь, что все сходится
    - Опишите несколько идей псевдокодом и выберите лучшую (пройдите по циклу)
      Пройдитесь по псевдокоду несколько раз, пока реализация не покажется понятной
  Кодирование метода
    
                   Начните с псевдокода
                           |
                          (.)
             ------------------------------
             | Напишите обьявление метода |
       |---->|                            |
       |     |                            |  
       |     ------------------------------ 
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Напишите первый и последний операторы, |
       |     | а псевдокод превратите в комментарии   |
       |---->| верхнего уровня                        | 
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Добавьте код после каждого комментария |
       |     |                                        |
       |---->|                                        |
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Проверьте код                          |
       |     |                                        |
       |---->|                                        |
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |     | Исправьте неточности                   |
       |     |                                        |
       |     |                                        |
       |     ------------------------------------------
       |           |      |
       |           |      |
       |------------      |
                          ---> Завершение
    - Обьявление метода
    - Напишите код под каждым комментарием
    - Проверьте, не нужна ли дальнейшая декомпозиция кода
      Если кода получается много, то вынести логику в еще один метод
  Проверка кода
    Третий шаг после проектирования и реализации - его проверка
    Сейчас надо проверить метод на ошибки, прежде чем идти дальше
    Умозрительно проверьте ошибки в методе
      Мысленно выполните все ветви метода 
    Компиляция метода
      1 Установите наивысший уровень предупреждений компилятора.
      2 Применяйте проверяющие средства (линтеры, анализаторы)
      3 Выясните причину всех сообщений об ошибках и предупреждений.
    Пройдите по коду отладчиком
    Протестируйте код
    Удалити ошибки из метода
  Наведение глянца
    1 Проверьте интерфейс метода
      Убедитесь, что применяются все входные и выходные данные
    2 Проверьте общее качество конструкции
      Убедитесь, что метод выполняет единственную задачу и делает это хорошо
      Имеем слабое сопряжение с другими методами
      Имет учитывает методику защитного программирования (барьеры/проверки)
    3 Проверьте переменные метода
      Корректность наименования, неиспользуемые обьекты, необьявленные переменные
    4 Проверьте логику метода
    5 Проверьте форматирование метода
    6 Проверьте документирование метода
    7 Удалите лишнии комментарии    
  Повторите нужное число раз
    ПО — итеративный процесс, повторите весь процесс, пока не выйдет что-то орошее
  |    
  № 9.4 Альтернативы ППП
  Для меня ППП — идеальная методика создания классов и методов. 
  Другие подходы:
    - Разработка с изначальными тестами
    - Рефакторинг
    - Проектирование по контракту
    - Бессистемное программирование
      Лепим как получиться, если вы так делаете, то используйте ППП


10)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 10 ] Общие принципы использования переменных
  |    
  № 10.1 Что вы знаете о данных?
    тут штуки
  |    
  № 10.2 Грамотное обьявление переменных
  Неявные обьявления
    Неявное объявление переменных — одна из самых опасных возможностей языка 
    Советы: 
    - Отключите неявные объявления
    - Объявляйте все переменные
    - Используйте конвенции именования
    - Проверяйте имена переменных
  |    
  № 10.3 Принципы инициализации переменных
  - Инициализируйте каждую переменную при ее объявлении
    Простая и эффективная методика безопасного программирования
  - Инициализируйте каждую переменную там, где она используется в первый раз  
  - В идеальном случае сразу объявляйте и определяйте каждую переменную
     непосредственно перед первым обращением к ней
  - Объявляйте переменные по мере возможности как final или const   
  - Уделяйте особое внимание счетчикам и аккумуляторам
    Это про цыклы где мы юзаем i,j,n которые часто забывают обнулять
  - Инициализируйте данные члены класса в его конструкторе
  - Настройте компилятор так, чтобы он автоматически инициализировал все переменные 
  - Внимательно изучайте предупреждения компилятора
  - Проверяйте корректность входных параметров
    Прежде чем в переменную положить значение, надо убедиться, что это возможно
  - Инициализируйте рабочую память при запуске программы
    Можно использовать специальную утилиту, чтобы заполнить всю память
      определенным значением перед запуском программы. Это может помочь
      найти ошибки
  |    
  № 10.4 Область видимости
  Локализуйте обращения к переменным
    Код, расположенный между обращениями к переменной, является «окном уязвимости»  
    Чем кучнее получается использовать переменные, тем легче читать код
  Делайте время жизни переменных как можно короче
    Это уменьшает окно уязвимости, снижая вероятность неверного или неумышленного 
      изменения переменной между действительно нужными обращениями к ней.   
    Чем меньше время жизни, тем обычно лучше контроль сложности программы
  Общие советы по минимизации области видимости
    Инициализируйте переменные, используемые в цикле, непосредственно перед циклом, 
      а не в начале метода, содержащего цикл    
    Не присваивайте переменной значение вплоть до его использования
    Группируйте связанные команды
    Разбивайте группы связанных команд на отдельные методы
    Начинайте с самой ограниченной области видимости и расширяйте ее только 
      при необходимости
  Комментарии по поводу минимизации области видимости
    Ограничивайте область видимости каждой переменной минимальным фрагментом кода.
  |    
  № 10.5 Персистентность
  «Персистентность» — характеризует длительность существования данных
  Для Java не актуально, так как мы защищены от обращения по произвольным указателям
  |    
  № 10.6 Время связывания
  «время связывания» — момент, когда переменная и ее значение связываются вместе
  Обычно чем позднее можно сделать связывание, тем гибче получается код, но сложнее
  |    
  № 10.7 Связь между типами данных и управляющими структурами
  Между типами данных и управляющими структурами существуют однозначные отношения
  1 Последовательные данные соответствуют последовательности команд
    это набор блоков данных, используемых в определенном порядке
  2 Селективные данные соответствуют операторам if и case
     Представляют собой набор, допускающий использование одного и только одного 
       элемента данных в каждый конкретный момент времени 
  3 Итеративные данные соответствуют циклам
    данные одного типа, повторяющиеся более одного раза 
  |    
  № 10.8 Единственность цели каждой переменной
  - Используйте каждую переменную только с одной целью
  - Избегайте переменных, имеющих скрытый смысл
    Например "pageCount" можем использовать значение -1 как ошибку, 
      это однозначно плохой путь, так как переменная обьединяет две цели в себе
  - Убеждайтесь в том, что используются все объявленные переменные 


11)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 11 ] Сила имени переменных
  |    
  № 11.1 Общие принципы выбора имен переменных
  Самый важный принцип именования переменных
    Имя должно полно и точно описывать сущность
    Переменную, представляющую число членов олимпийской команды США, 
      можно было бы назвать numberOfPeopleOnTheUsOlympicTeam
  Ориентация на проблему
    Хорошее имя в большей степени выражает что, а не как
  Оптимальная длина имени переменной
    Примерно 10–16 символов
  Имена переменных и область видимости
    Более длинные имена лучше присваивать редко используемым или глобальным 
      переменным, а более короткие — локальным переменным или переменным в циклах
    Дополняйте имена, относящиеся к глобальному пространству имен, спецификаторами
      В C++ и C# для разделения используется "namespace"
      В Java можем использовать "packeg"  
  Спецификаторы вычисляемых значений
    Переменные, содержащие вычисляемые значения: суммы, средние величины и т. д
      Дополните Total, Sum, Average, Max, Min или Pointer, укажите его в конце имени
  Антонимы, часто встречающиеся в именах переменных
    - begin/end          first/last
    - locked/unlocked    min/max
    - next/previous      old/new
    - opened/closed      visible/invisible
    - source/target      source/destination
    - up/down
  |    
  № 11.2 Именование конкретных типов данных
  Именование индексов циклов
    В качестве индексов циклов используют переменные i, j и k
    Если же переменную предполагается использовать вне цикла, ей следует 
      присвоить более выразительное имя  
  Именование переменных статуса
    Старайтесь не присваивать переменной статуса имя flag
    Обычно в качестве флага удобно использовать "enum"  
  Именование временных переменных
    Относитесь к «временным» переменным с подозрением
    Использование tmp или x для временного хранения, надо подумать над именем!
  Именование булевых переменных
    Помните типичные имена булевых переменных
      - [done] используйте как признак завершения цикла или другой операции
      - [error] как признак ошибки
      - [found] обнаружено ли некоторое значение    
      - [success] как признак успешного завершения операции 
    Присваивайте булевым переменным имена, подразумевающие значение true или false
      Поэтому имя status лучше заменить на имя вроде error или statusOK, 
        а имя sourceFile — на sourceFileAvailable, sourceFileFound или подобное имя, 
        соответствующее сути переменной    
    Используйте утвердительные имена булевых переменных
      Не использовать -> такие как notFound, notdone и notSuccessful
  Именование перечислений
    Принадлежность переменных к тому или иному перечислению можно пояснить, 
      дополнив их имена префиксами, такими как Color_, Planet_ или Month_
  Именование констант
    Имя FIVE — плохое имя константы, надо имя дать не зависящее от значения
      CYCLES_NEEDED — хорошее имя.  
  |    
  № 11.3 Сила конвенций именования
  Зачем нужны конвенции?
    1 Они позволяют больше принимать как данное и фокусироваться на других вещах
    2 Сходство имен облегчает понимание незнакомых переменных
    3 Они ускоряют изучение кода нового проекта
    4 Они подавляют «размножение» имен, уменьшает варианты наименования переменных
    5 Можете именами реализовать отсутствующие возможности языка
    (*) наличие хоть какой#то конвенции обычно предпочтительнее, чем ее отсутствие
  Когда следует использовать конвенцию именования?
    Рекомендации:
      - над проектом работают несколько программистов
      - программу будут изменять и сопровождать другие программисты 
      - обзор программы выполняют другие программисты из вашей компании
      - программа так велика, что вы не можете полностью охватить ее умом
      - программа будет использоваться длительное время
      - прикладная область имеет необычную терминологию и вы хотите 
          стандартизовать применение терминов или аббревиатур в коде  
    Степень формальности конвенций
      Формальная конвенция — важнейшее средство улучшения удобочитаемости программы  
  |    
  № 11.4 Неформальные конвенции именования
  Конвенция, не зависящая от языка
    - Проведите различие между именами переменных и именами методов
    - Проведите различие между классами и объектами
    - Идентифицируйте глобальные переменные
      (*) сделать префикс "g_", для Java не актуально
    - Идентифицируйте переменные'члены
      (*) сделать префикс "m_", для Java не актуально
    - Идентифицируйте определения типов
      (*) сделать префикс "t_Color, t_Menu", для Java не актуально  
    - Идентифицируйте именованные константы
      (*) сделать префикс "c_", для Java не актуально  
    - Идентифицируйте элементы перечислений
      (*) сделать префикс "e_", для Java не актуально  
    - Форматируйте имена так, чтобы их было легко читать
  Конвенции, специфические для конкретных языков
    для Java нету, пропускаем этот пункт
  Программирование с использованием нескольких языков
    похожк тут вредный совет следовать одной конвенции, но кажется лучше так не делать    
  |    
  № 11.5 Стандартные префиксы
  Венгерская нотация — представляет собой набор детальных принципов 
    именования переменных и методов
  Cуть — создание стандартизованного набора лаконичных точных аббревиатур
  Стандартизованный префикс состоит из: аббревиатуры типа и семантического префикса
  Аббревиатура типа, определенного пользователем
    Аббревиатура UDT обозначает тип объекта или переменной
    Мы берем слова, которые будем использовать и договариваемся о короткой форме
    Пример:
      - doc   Документ
      - pa    Абзац (paragraph)
      - scr   Область экрана
      - sel   Выбранный текст
      - wn    Окно
  Семантические префиксы
    Дополняют аббревиатуры UDT, характеризуя использование переменной или объекта.
    Пример:
      - c    Количество (записей, символов и т. д.).
      - g    Глобальная переменная. 
      - i    Индекс массива.
  Достоинства стандартизованных префиксов
    - Однообразные имена легче читать
    - Делают имена более компактными  
  |    
  № 11.6 Грамотное сокращение имен переменных
  Общие советы по сокращению имен
    - используйте стандартные аббревиатуры 
    - удаляйте все гласные, не являющиеся первыми буквами имен 
        (computer — cmptr, screen — scrn, apple — appl, integer — intgr)
    - удаляйте артикли и союзы, такие как and, or, the и т.д
    - сохраняйте одну или несколько первых букв каждого слова
    - «обрезайте» слова согласованно: после первой, второй или третьей буквы
    - сохраняйте первую и последнюю буквы каждого слова
    - сохраняйте до трех выразительных слов
    - удаляйте бесполезные суффиксы: ing, ed и т.д. 
    - сохраняйте наиболее выразительный звук каждого слога
    - проверяйте, чтобы смысл имени переменной в ходе сокращения не искажался 
  Фонетические аббревиатуры
    не используйте такой способ (сокращение на основе того как слышится)
  Комментарии по поводу сокращения имен
  - Не сокращайте слова только на один символ
  - Сокращайте имена согласованно
    Всегда используйте один и тот же вариант сокращения
  - Сокращайте имена так, чтобы их можно было произнести
  - Избегайте комбинаций, допускающих неверное прочтение или произношение имени
  - Обращайтесь к словарю для разрешения конфликтов имен
  - Документируйте очень короткие имена прямо в коде при помощи таблиц    
  - Указывайте все сокращения в проектном документе "Стандартные аббревиатуры"  
    Cоздать документ «Стандартные аббревиатуры», описывающий все аббревиатуры 
      конкретного проекта 
    Этот совет иллюстрирует различие между удобством написания кода и удобством 
      его чтения
  - Помните, что имена создаются в первую очередь для программистов, читающих код
  |    
  № 11.7 Имена, которых следует избегать
  - Избегайте обманчивых имен или аббревиатур
  - Избегайте имен, имеющих похожие значения
  - Избегайте переменных, имеющих разную суть, но похожие имена 
  - Избегайте имен, имеющих похожее звучание, таких как wrap и rap
  - Избегайте имен, включающих цифры
  - Избегайте орфографических ошибок
  - Избегайте слов, при написании которых люди часто допускают ошибки 
  - Проводите различие между именами не только по регистру букв
  - Избегайте смешения естественных языков
  - Избегайте имен стандартных типов, переменных и методов
  - Избегайте имен, содержащих символы, которые можно спутать с другими символами


12)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 12 ] Основные типы данных
  |    
  № 12.1 Числа в общем
  - Избегайте «магических чисел»
  - Ошибки деления на ноль
    Если такая возможность существует, напишите код, предупреждающий 
      появление ошибки
  - Выполняйте преобразования типов понятно
  - Избегайте сравнений разных типов
  - Обращайте внимание на предупреждения вашего компилятора   
     Легче предоставить работу компилятору, чем выполнять ее самому
  |    
  № 12.2 Целые числа
  - Проверяйте целочисленность операций деления
    выражение 7/10 не равно 0,7
  - Проверяйте переполнение целых чисел
    Надо учитывать это, будет ли тут число хранится больше чем может вместить
  - Проверяйте на переполнение промежуточные результаты
  |    
  № 12.3 Числа с плавающей запятой
  - Избегайте сложения и вычитания слишком разных по размеру чисел
    Это позволит минимизировать проблему округления
  - Избегайте сравнений на равенство
    Запрет на сравнение по равенству, только больше или меньше
  - Предупреждайте ошибки округления
    1 Измените тип переменной на тип с большей точностью
    2 Используйте двоично десятичные переменные
    3 Измените тип с плавающей запятой на целые значения
  - Проверяйте поддержку специальных типов данных в языке 
      и дополнительных библиотеках
  |    
  № 12.4 Символы и строки
  - Избегайте магических символов и строк
    Используйте именованные константы
    причины избегать:
    1 менять можно будет в одном месте
    2 потом можно это сгрупировать в класс
    3 дублирование может привести к лишним затратам памяти
  - Следите за ошибками завышения/занижения на единицу
    не актуально для Java
  - Узнайте, как ваш язык и система поддерживают Unicode   
    в Java, все строки хранятся в формате Unicode
  - Разработайте стратегию интернационализации/локализации в ранний 
      период жизни программы
    Надо решить какие строки будут находиться во внешних ресурсах, для
      локализации
  - Если вам известно, что нужно поддерживать только один алфавит, 
      рассмотрите вариант использования набора символов ISO 8859
  - Если вам необходимо поддерживать несколько языков, используйте Unicod
  - Выберите целостную стратегию преобразования строковых типов
  |    
  № 12.5 Логические переменные
  - Используйте логические переменные для документирования программы
    Можно использовать переменную с говорящим именем, а не просто условие
  - Используйте логические переменные для упрощения сложных условий
    разбиваем сложное на сумму простого
  |    
  № 12.6 Перечислимые типы
  - Используйте перечислимые типы для читабельности
    видите числовую константу, подумайте: не заменить ли ее перечислимым типом
  - Используйте перечислимые типы для надежности
  - Используйте перечислимые типы для модифицируемости
  - Используйте перечислимые типы как альтернативу логическим переменным
    для методов которые возвращают true/false
  - Проверяйте некорректные значения
    в switch-case или if-else используйте ветку когда пришло что-то неожиданное
  - Настройте первый и последний элемент перечислимого типа для использования 
      в качестве границ циклов
  - Зарезервируйте первый элемент перечислимого типа как недопустимый
    не актуально для Java
  - Точно укажите в стандартах кодирования для проекта, как должны использоваться 
      первый и последний элементы, и неукоснительно придерживайтесь этого
    не актуально для Java  
  |    
  № 12.7 Именованные константы
  - Используйте именованные константы в объявлениях данных
  - Избегайте литеральных значений, даже «безопасных»
    (For i = 1 To 12) что такое 12, выносим в именнованную константу
  - Имитируйте именованные константы с помощью переменных или классов правильной 
      области видимости
    не актуально для Java 
  - Последовательно используйте именованные константы
  |    
  № 12.8 Массивы
 - Убедитесь, что все значения индексов массива не выходят за его границы
 - Обдумайте применение контейнеров вместо массивов или рассматривайте массивы 
     как последовательные структуры
   Если мы будем использовать массивы без произвольного доступа к элементам,
     то код обычно получается более производительным
 - Проверяйте конечные точки массивов
   не актуально для Java 
  |    
  № 12.9 Создание собственных типов данных (псевдонимы)
  (*) typedef в (c/C++), в Java такой возможности нет


13)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 13 ] Нестандартные типы данных
  |    
  № 13.1 Структуры
  Иногда классы называют структурами, если они состоят только из данных
  - Используйте структуры для прояснения взаимоотношений между данными
    Обьединяем связанные данные и используем вместе
    Четкая структурированность данных улучшает код
  - Используйте структуры для упрощения операций с блоками данных
    Упрощает операции над цельным кусочком связанных данных
  - Используйте структуры для упрощения списка параметров
  - Используйте структуры для упрощения сопровождения
  |    
  № 13.2 Указатели
  Парадигма для понимания указателей
    каждый указатель состоит из двух частей: области памяти и знания
      1 Область памяти
        Область памяти — это адрес, представленный в виде числа
        Чтобы обратиться к данным, надо пойти по этому адресу и 
          как-то интерпритировать данные в этой области
      2 Знание, как интерпретировать содержимое 
        Информация о том как интерпритировать данные определяется типом указателя
  Основные советы по использованию указателей
  - Изолируйте операции с указателями в методах или классах
  - Выполняйте объявление и определение указателей одновременно
  - Удаляйте указатели в той же области действия, где они были созданы
  - Проверяйте указатели перед их применением
  - Проверяйте переменную, на которую ссылается указатель, перед ее использованием  
  - Используйте закрепленные признаки для проверки повреждения памяти
    можно кусочек памяти выделять и класть туда хитрое число, которое
      потом можно прочитать и проверить, что мы в нужном кусочке памяти
  - Добавьте явную избыточность
    добавить несколько полей тегов 
  - Используйте для ясности дополнительные переменные указателей
    куда указывает pointer->next->last->next ? не делайте такие цепочки вызовов 
  - Нарисуйте картинку
    так станет понятно кто на что указывает
  - Удаляйте указатели в связных списках в правильном порядке
    иногда удалив память элемента можем потерять ссылку на следующий элемент
  - Выделите «запасной парашют» памяти
    Заранее выделяем парашут памяти, чтобы когда память кончится созранить все
      данные и безопасно завершиться
  - Уничтожайте мусор
    Записывайте мусор в освобожденные блоки памяти, чтобы быстрее отловить
      ошибки работы с указателями
  - Устанавливайте указатели null при их удалении или освобождении
    висячий указатель - обращение к нему после вызова функций delete или free
    чтобы обезопасить себя после освобождения памяти присваиваем null 
  - Проверяйте корректность указателя перед его удалением
    если присваивали Null то проверяем на null
  - Отслеживайте распределение памяти для указателей
    Ведите список указателей, для которых была выделена память
  - Напишите методы оболочки, чтобы централизовать стратегию борьбы с ошибками 
      в указателях
    1 SAFE_NEW
      Вызывает new для выделения памяти, добавляет указатель в список 
      задействованных указателей и возвращает вновь созданный указатель 
      вызывающей стороне. Он может также проверить, что оператор new не 
      вернул null (ошибка нехватки памяти).
    2 SAFE_DELETE
      Проверяет, находится ли переданный ему указатель в списке
      действительных указателей. Если он там есть, метод записывает мусор 
      в адресуемую им память, удаляет указатель из списка, 
      вызывает C++ оператор delete для освобождения памяти и устанавливает 
      указатель в null.
  - Используйте технологию, не основанную на указателях
    если можете не использовать указатели, то не используйте
  |    
  № 13.3 Глобальные данные
  Распространенные проблемы с глобальными данными
    - Непреднамеренные изменения глобальных данных
    - Причудливые проблемы при использовании псевдонимов для глобальных данных
    - Проблемы реентерабельности глобальных данных
      Многопоточное программирование создает вероятность обращения к общим данным
      Затруднение повторного использования кода, вызванное глобальными
        данными
      Глобальные данные как вирус они лияют на исходный код, но и распространяются
        по новым программам, использующим какие либо классы из старой.
    - Проблемы с неопределенным порядком инициализации глобальных данных
    - Нарушение модульности и интеллектуальной управляемости, привносимое 
        глобальными данными
  Причины для использования глобальных данных
    - Хранение глобальных значений
      Если данные относятся ко всей программе, то логично их вынести
    - Эмуляция именованных констант
    - Эмуляция перечислимых типов
    - Оптимизация обращений к часто используемым данным
    - Исключение бродячих данных
  Используйте глобальные данные только как последнее средство
    - Начните с объявления всех переменных локальными и делайте их глобальными 
        только по необходимости
    - Различайте глобальные переменные и переменные'члены класса
    - Используйте методы доступа
  Используйте методы доступа вместо глобальных данных
    - Преимущества методов доступа
      1 Вы получаете централизованный контроль над данными
      2 Все ссылки на переменную будут изолированы
      3 Получаете главные преимущества сокрытия информации
      4 Методы доступа легко преобразуются в абстрактные типы данных
        вместо "if lineCount > MAX_LINES" -> "if PageFull()"
    - Как использовать методы доступа
      1 Требуйте, чтобы весь код обращался к данным через методы доступа
      2 Не валите все глобальные данные в одну кучу
      3 Управляйте доступом к глобальным переменным с помощьюблокировок
      4 Встройте уровень абстракции в методы доступа
      5 Выполняйте доступ к данным на одном и том же уровне абстракции
  Как уменьшить риск использования глобальных данных
    Обычно наличие глобальных данных говорит о неверном проектировании  
    Есть только микро набор кейсов, когда использование глоб данных оправдано
    - Разработайте именование, которое сделает глобальные переменные очевидными        
    - Создайте хорошо аннотированный список всех глобальных переменных
      Иметь список глобальных переменных — очень полезно
    - Не храните промежуточных результатов в глобальных переменных
    - Не считайте, что вы не используете глобальные переменные, поместив
        все данные в чудовищный объект и передавая его всюду   


14)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 14 ] Организация последовательно кода
  |    
  № 14.1 Организация последовательно кода
  - Организуйте код так, чтобы зависимости были очевидными
    из кода должен быть очевиден порядок действий и зависимости
      одного вызова от другого
  - Называйте методы так, чтобы зависимости были очевидными
  - Используйте параметры методов, чтобы сделать зависимости очевидными  
    в этом приере есть намек что порядок методов важен:
    " InitializeExpenseData( expenseData )
      ComputeMarketingExpense( expenseData )
      ComputeSalesExpense( expenseData ) "
  - Документируйте неявные зависимости с помощью комментариев    
    при таком вызове методов, без коментария не понятно важен ли порядок
    " InitializeExpenseData
      ComputeMarketingExpense
      ComputeSalesExpense "
  - Проверяйте зависимости с помощью утверждений или кода обработки ошибок
  |    
  № 14.2 Операторы, следующие в произвольном порядке
  - Размещение кода для чтения сверху вниз
    обеспечить чтение программы сверху вниз, а не перескакивая с места на место
  - Группировка взаимосвязанных выражений
    Размещайте взаимосвязанные выражения вместе. 
 


15)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 15 ] Условные операторы
  |    
  № 15.1 Операторы if
  - Простые операторы if-then
    1 Сначала напишите код номинального хода алгоритма, затем опишите 
      исключительные случаи
    2 Убедитесь, что при сравнении на равенство ветвление корректно
    3 Размещайте нормальный вариант после if, а не после else 
    4 Размещайте осмысленные выражения после оператора if
    5 Рассмотрите вопрос использования блока else
    6 Проверяйте корректность выражения else
    7 Проверяйте возможную перестановку блоков if и else
  - Последовательности операторов if-then-else
    1 Упрощайте сложные проверки с помощью вызовов логических функций
    2 Размещайте наиболее вероятные варианты раньше остальных
    3 Убедитесь, что учтены все варианты
    4 Замените последовательности if-then-else другими конструкциями, 
      которые поддерживает ваш язык программирования 
  |    
  № 15.2 Операторы case
  - Выбор наиболее эффективного порядка вариантов
    1 Упорядочивайте варианты по алфавиту или численно
    2 Поместите правильный вариант первым
    3 Отсортируйте варианты по частоте
  - Советы по использованию операторов case
    1 Сделайте обработку каждого варианта простой
    2 Не конструируйте искусственные переменные с целью получить 
      возможность использовать оператор case
    3 Используйте вариант по умолчанию только для обработки настоящих
      значений по умолчанию
    4 Используйте вариант по умолчанию для выявления ошибок
      " default:
          DisplayInternalError( “Internal Error 905” ); "
    5 В C++ и Java старайтесь не писать код, проваливающийся сквозь блоки 
        оператора case
      лучше всегда использовать "break;"
    

16)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 16 ] Циклы
  |    
  № 16.1 Выбор типа цикла
  Обычно есть несколько типов циклов:
    - Цикл с подсчетом выполняется определенное количество раз
    - Постоянно вычисляемый цикл, который не знает когда остановится
    - Бесконечный цикл выполняется все время с момента старта
    - Цикл с итератором выполняет некоторые действия однократно 
      для каждого элемента контейнерного класса
  Когда использовать цикл while
    Если вы заранее не знаете, сколько итераций нужно
  Когда использовать цикл for
    Если вам нужен цикл, выполняющийся определенное количество раз
  Когда использовать цикл foreach
    Когда нам что то надо сделать над всеми элементамми массива или контейнера
  |    
  № 16.2 Управление циклом
  Вход в цикл
    - Размещайте вход в цикл только в одном месте
    - Размещайте инициализационный код непосредственно перед циклом
    - Используйте while (true) для бесконечных циклов
    - Предпочитайте циклы for, если они применимы
    - Не используйте цикл for, если цикл while подходит больше
  Обработка середины цикла
    - Используйте { и } для обрамления выражений в цикле
    - Избегайте пустых циклов
    - Располагайте служебные операции либо в начале, либо в конце цикла
      Служебные операции цикла — это выражения вроде i = i + 1 или j++
    - Заставьте каждый цикл выполнять только одну функцию
      Циклы должны быть подобны методам в том плане, что каждый должен 
        делать только одно дело и делать его хорошо
  Завершение цикла
    - Убедитесь, что выполнение цикла закончилось
    - Сделайте условие завершения цикла очевидным
    - Не играйте с индексом цикла for для завершения цикла
      писать в теле цикла i = 99999, говорит о плохом дизайне
    - Избегайте писать код, зависящий от последнего значения индекса цикла
      Использование значения индекса цикла после его завершения — дурной тон
      Заведите отдельную переменную, которую потом используйте
    - Рассмотрите использование счетчиков безопасности
      Для очень критичных к сбоям участах кода можно использовать это:
      Счетчик безопасности — это переменная, увеличивающаяся при каждом проходе 
      цикла, чтобы определить, не слишком ли много раз выполняется цикл.
    - Досрочное завершение цикла
      Операторы continue и break, если можно без них, то кайф, но
        лучше использовать их чем флаги для условия цикла
    - Рассмотрите использование операторов break вместо логических флагов 
        в цикле while
    - Остерегайтесь цикла с множеством операторов break, разбросанных по
        всему коду
    - Используйте continue для проверок в начале цикла
      Например если при чтении файла мы должны игнорировать некоторые символы 
    - Используйте структуру break с метками, если ваш язык ее поддерживает
      Это удобно когда надо выйти во внешний цикл
    - Используйте операторы break и continue очень осторожно
      Круто если цикл можно понять не смотрев в его серединку, использование
      "break" заставляет смотреть тело цикла
  Проверка граничных точек
    При разработке цикла обычно особо интересны три точки:
      1 начало цикла, 2 серединка, 3 его конец
  Использование переменных цикла
    - Используйте порядковые или перечислимые типы для границ массивов и циклов  
    - Используйте смысловые имена переменных, чтобы сделать вложенные 
      циклы читабельными
      пример:
      "
      for ( int payCodeIdx = 0; payCodeIdx < numPayCodes; payCodeIdx++ ) {
       for (int month = 0; month < 12; month++ ) {
        for ( int divisionIdx = 0; divisionIdx < numDivisions; divisionIdx++ ) {
         sum = sum + transaction[ month ][ payCodeIdx ][ divisionIdx ];
        }
       }
      }
      "
    - Используйте смысловые имена во избежание пересечения индексов
    - Ограничивайте видимость переменных'индексов цикла самим циклом
  Насколько длинным может быть цикл?
    - Делайте циклы достаточно короткими, чтобы их можно было увидеть 
      сразу целиком
        (*) круто если не длиннее 20 строк
    - Ограничивайте вложенность тремя уровнями
    - Выделяйте внутреннюю часть длинных циклов в отдельные методы
    - Делайте длинные циклы особенно ясными
  |    
  № 16.3 Простое создание цикла — изнутри наружу
  Шаг 1: В комментариях напишите шаги, которые должно выполнять тело цикла
    "
      — Получить ставку из таблицы.
      — Добавить ставку к общей сумме.
    "
  Шаг 2: Замените комментарии в теле цикла на код, насколько это возможно
    "
      rate = table[ ]
      totalRate = totalRate + rate
    "
  Шаг 3: Далее добавьте индексы
    "
      rate = table[ census.Age ][ census.Gender ]
      totalRate = totalRate + rate
    "
  Шаг 4: построение цикла вокруг существующих выражений
    "
      For person = firstPerson to lastPerson
        rate = table[ census.Age, census.Gender ]
        totalRate = totalRate + rate
      End For
    "
  Шаг 5: поместить цикл for вокруг существующего кода
    "
      For person = firstPerson to lastPerson
        rate = table[ census[ person ].Age, census[ person ].Gender ]
        totalRate = totalRate + rate
      End For
    "
  Последний шаг:  напишите необходимую инициализацию
    "
      totalRate = 0
      For person = firstPerson to lastPerson
        rate = table[ census[ person ].Age, census[ person ].Gender ]
        totalRate = totalRate + rate
      End For
    "
  |    
  № 16.4 Соответствие между циклами и массивами
  Циклы и массивы часто связаны друг с другом


17)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 17 ] Нестандартные управляющие структуры
  |    
  № 17.1 Множественные возвраты из метода
  Операторы return и exit — управляющие структуры, которые позволяют 
    программе при желании завершить работу метода
  - Используйте return, если это повышает читабельность
  - Упрощайте сложную обработку ошибок с помощью сторожевых 
    операторов (досрочных return или exit)
    (*) например, чтобы избежать большой вложенности
  - Минимизируйте число возвратов из каждого метода
  |    
  № 17.2 Рекурсия
  Обычно рекурсию применяют, когда небольшую часть задачи легко решить, 
    а саму задачу просто разложить на составные части
  Советы по использованию рекурсии
    - Убедитесь, что рекурсия остановится
    - Предотвращайте бесконечную рекурсию с помощью счетчиков безопасности 
    - Ограничьте рекурсию одним методом
    - Следите за стеком
    - Не используйте рекурсию для факториалов и чисел Фибоначчи
      обычно рекурсия не оптимальна с точки зрения ресурсов
  |    
  № 17.3 Оператор goto
  Аргументы против goto
    1 код без goto — более качественный
    2 корректность кода, не содержащего goto, доказать легче
    3 код с операторами goto трудно форматировать
    4 применение goto препятствует оптимизации, выполняемой компилятором
    5 goto - зло 
  Аргументы в защиту goto
    1 Оператор goto может пригодиться в методе, который сначала распределяет 
      ресурсы, выполняет с ними какие#то операции, а потом освобождает 
      эти ресурсы
    2 Порой goto позволяет создать более быстрый и короткий код
  Воображаемая дискуссия по поводу goto
    Обычно сторонники модут придумать кейс удобного использования goto,
    а противники также пример плохого использования
  Обработка ошибок и операторы goto
    - Переписать с помощью вложенных операторов if
      Это стандартный, приводимый в учебниках подход к удалению операторов goto
      Может получиться большая вложенность
    - Переписать код с использованием статусной переменной
      (*) также называемой переменной состояния
      создайте переменную, которая будет показывать, не находится ли
        метод в состоянии ошибки.
      такой подход не даст расти вложенности
    - Переписать с помощью try-finally
  Операторы goto и совместное использование кода в блоке else    
    В общем случае написание нового метода — лучший подход   
  Краткий итог основных принципов использования goto
    Использование goto — это вопрос религии
    Моя догма: в современных языках вы легко можете обойтись без goto
  |    
  № 17.4 Перспективы нестандартных управляющих структур
  не актуально


18)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 18 ] Табличные методы
  |    
  № 18.1 Основные вопросы использования табличных методов
  Табличный метод — это схема, позволяющая искать информацию в таблице, а не
    использовать для этого логические выражения, такие как if и case.
  Пример:
    мы можем городить логику из условий или сделать массив или таблицу
      возможных ответов, а мы только вычисляем нужный индекс и выдаем ответ
  Два вопроса применения табличных методов
    1 как будет выполняться поиск записей в таблице
      - прямой доступ
      - индексированный доступ
      - ступенчатый доступ
    2 что хранить в таблице
      - данные
      - ссылку на метод
  |    
  № 18.2 Таблицы с прямым доступом




























 perfect-code-book add new part of summery

  стр 427 в chrome











[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
