---
Ресурсы:

// оф сайт
- [ https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D0%BA%D0%BE%D0%BD%D0%BD%D0%B5%D0%BB%D0%BB,_%D0%A1%D1%82%D0%B8%D0%B2 ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ Совершенный код ] это одна из лучших книг по программированию.




1) [ Часть 1 / Глава 1 ] Добро пожаловать в мир конструирования ПО! 
  - вводная информация
  - Этапы создания ПО:
    1 Выработка требований
    2 Проектирование архитектуры
    3 Конструирование


2) [ Часть 1 / Глава 2 ] Метафоры, позволяющие лучше понять разработку ПО 
  - Инкрементальный подход к разработке это лучшее, что есть на сегодня
  - Подходящая аналогия к разработке ПО это строительство (дома, небоскреба, будки для собаки)
  - необходимо понимать что мы строим, для этого используется планирование
  - при разработке ПО не нужно писать велосипеды, если есть написанные штуки, надо использовать


3) [ Часть 1 / Глава 3 ] Семь раз отмерь, один раз отрежь: предварительные условия
  - перед началом создания проекта, надо провести подготовку
    и проверить все ли готово для реализации намеченного плана.
  - мы должны потратить много времени на планирование!
  - необходимо выработать как можно более широкий набор требований к продукту.
  - Первое что мы должны понять, это проблема которую мы хотим решить.
  - Определение проблемы - это формирование сути проблемы без намеков на решение.
  - Определение проблемы - это фундамент всего процесса программирования
  -       ::
         :  :         - Будущие решения
        :    :        - Тестирование системы 
       :      :       - Конструирование
      :        :      - Проектирование архитектуры
     :          :     - Выработка требований
    :            :    - Определение проблемы
   :::::::::::::::: 
  - Проблема должна быть описана на языке пользователя, 
    обычно описание не содержит технических терминов.
  - (*) к проектированию архитектуры переходим после проработки требований !
  - Архитектура — это высокоуровневая часть проекта приложения, 
    каркас, состоящий из деталей проекта.
  - Архитектура должна четко определять ответственность каждого компонента.
  - Компонент должен иметь одну область ответственности и как можно меньше знать 
    об областях ответственности других компонентов.
  - Архитектура должна быть модульной, чтобы можно было заменять модули.
  - Архитектура должна учитывать ресурсы памяти, ЦПУ, коннектов к базе и тд.
  - Архитектура должна определять подход к безопасности как на уровне проекта
    приложения, так и на уровне кода.
  - Производительность: в требованиях следует определить показатели производительности,
    а в архитектуре описать обьяснение, что такая архитектура сможет реализовать требования
  - Масштабируемость: Архитектура должна описывать, как система будет реагировать на рост
    числа пользователей, серверов, сетевых узлов, записей в БД, транзакций и т.д
  - Интернационализация/локализация: в архитектуре должно быть описано как реализуется это.
  - Обработка ошибок: стратегия обработки ошибок должна быть выражена в архитектуре
  - Отказоустойчивость: необходимо описать сценарии ошибок и отказов, которые не должны 
    приводить к потере работоспособности.
  - Возможность реализации архитектуры: нужно быть увереными, что архитектура реализуема.
    Невозможность реализации какого-то компонента может сделать проект неработоспособным.
    (*) как решение это написание прототипов таких можулей или дополнительное исследование.
  - Стратегия изменений: Архитектура должна показывать, что возможные улучшения
    рассматривались и что реализация наиболее вероятных улучшений окажется наиболее простой. 


4) [ Часть 1 / Глава 4 ] Основные решения, которые приходится принимать при конструировании
  - Необходимо ввести стиль использования выбранного языка программирования.
  - Большинство важных принципов программирования не от конкретных языков, 
    а от способа их использовать.


5) [ Часть 2 / Глава 5 ] Высококачественный код
  - Проектирование ПО - под этим обычно понимают разработку или изобретение схемы
    преобразования спецификации приложения в готовое приложение.
  - Проектирование - "грязная" проблема. Прикол в том что такую проблему можно
    определить только через полное или частичное решение.
    (*) получается надо один раз решить проблему, чтобы получить ее ясное представление,
    а потом решить еще раз для создания работоспособного решения.
  - Проектирование это постоянный анализ конкурирующих характеристик проекта и достижение
    баланса между ними.
  - Проектирование подразумевает ограничение возможностей.
  - Проектирование не имеет единствено верного решения, 
    при решении разными разработчиками, получим несколько разных, но решающих проблему програм
  - Проектирование - процесс из проб и ошибок, постепенный процесс
  |
  № 5.2 Основные концепции проектирования:
    - Управление сложностью - самый важный технический аспект разработки ПО.
      Необходимо организовать код так, чтобы можно было безопасно работать с частями.
      Несколько не сложных фрагментов понять проще, чем один сложный.
      (*) Необходимо свести к минимому обьем существенной сложности, 
      с которым придется работать в каждый конкретный момент времени.
      (**) Необходимо сдерживать необязательный рост несущественной сложности.
      (!) все принцыпы програмирования ведут к уменьшению частичной сложности кода.
    - Желательные характеристики проекта
      - @ Минимальная сложность
        Надо создавать простые и понятные проекты
      - @ Простота сопровождения
        При проектировании нельзя забывать о людях из сопровождения
      - @ Слабоя сопряжение
        Сведение к минимому числа соединений между разными частями программы
      - @ Расширяемось
        Внесение наиболее вероятных изменений должно требовать наименьших усилий.
      - @ Возможность повторного использования
        Признах хорошего проектирования программы это когда код легко переиспользовать.
      - @ Высокий коэффициент обьединения по входу
        Хорошо когда созданный нами клас много где используется
      - @ Низкий или средний коэффициент разветвления по выходу
        Плохо когда один класс для своей работы требует ссылки на множество классов
      - @ Портируемость
        Проектировать надо так, чтобы систему можно было легко аадптировать к другой среде.
      - @ Минимальная, но полная функциональность
        Меньше кода - меньше проблем
      - @ Стратификация
        Необходимо разрабатывать систему, чтобы можно разделить по уровням декомпозиции
        Если есть старый или плохой код лучше сделать клас мост, чтобы изолировать его
      - @ Соответствие стандартным методикам
        Необходимо применять стандартные и популяные подходы
  - Уровни проектирования
    - "Уровень 1" Программная система
      Этому уровню соответствует вся система.
    - "Уровень 2" Разделение системы на подсистемы или пакеты
      Результат проектирования на этом уровне - определение основных подсистем
      Особенно важно определить правила взаимодействия и ограничивать эти связи
      Архитектура системы должна быть такой, чтобы замена подсистемы была максимально простой
      часто используемые варианты подсистем:
      - @ Подсистема пользовательского интерфейса
        изоляция GUI органична и удобна
      - @ Подсистема доступа к БД
        изоряция общения с БД отличная идея
      - @ Подсистема изоляции зависимостей от ОС
        Так как потом велик шанс задачи адоптации под другую ОС
    - "Уровень 3" разделение подсистем на классы
      Это уже уровень, где мы определяем необходимый набор классов   
      На этом уровне должно быть понятно как реализовать систему на уровне классов
    - "Уровень 4" разделение классов на методы
      Надо определить методы классов, можно этот уровень комбинировать с предыдущем
    - "Уровень 5" проектирование методов
      На этом уровне детально проектируется функциональность методов
      Например пишется псевдогод
  |  
  № 5.3 Компоненты проектирования: эвристические принципы
    Проектирование не является детерминированным
    - @ "1" Определите обьекты реального мира
      при проектировании определяем:
        - объекты и их атрибуты (методы и данные)
          (*) однозначное соответствие обьектов реального мира и программы
          подходит для начала, но обычно это не лучшая идея
        - действия, которые могут быть выполнены над каждым объектом
          (*) например обьект сотрудник может поддерживать операцию смены имени
        - действия, которые каждый объект может выполнять над другими объектами
          (*) какой обьект может включать другой обьект,
          какой обьект может выполнять действия над другим обьектом
        - части каждого объекта, видимые другим объектам
        - открытый интерфейс каждого объекта
          (*) для каждого обьекта надо определить формальный синтаксический интерфейс
    - @ "2" Определите согласованные абстракции
      Создание абстракций позволяет работать с обьектами не вдаваясь в подробности
    - @ "3" Инкапсулируйте детали реализации
      Инкопсуляция помогает управлять сложностью блокируя доступ к ней
    - @ "4" Используйте наследование, если оно упрощает проектирование
      При правильном использовании принесет большую пользу
   - @ "5" Скрывайте секреты (к вопросу о сокрытии информации)
     Это мощный принцып, который подчеркивает необходимость сокрытия сложности
     Секретом может быть источник вероятных изменений, формат файла, алгоритм и т.д
     Класс может использовать несколько типов данных не раскрывая сведений о них
     Интерфейс класса должен сообзать как можно меньше о внутренней работе класса
     Класс должен быть похож на айсберг
   - @ "6" Определите области вероятных изменений
     Находим элементы, изменение которых кажется вероятным
     Отделяем эти элименты, чтобы при изменении как можно меньше менять
     Спроектировать интервейс который будет не зависеть от изменений
     - Чаще всего меняется:
       - Бизнес правила
       - Зависимости от оборудования
       - Ввод-вывод
       - Нестандартные возможности языка
       - Сложные аспекты проектирования и конструирования
       - Переменные статуса
       - Размеры структур данных
   - @ "7" Поддерживайте сопряжение слабым
     Сопряжение характерезует силу связи класса или метода с другими классами или методами
     Стараться создавать модули, слабо зависящие от других
     Критерии оценки сопряжения:
     - Обьем
       Обьем связи характерезует число связей, чем меньше тем лучше
       Метод, принимающий один параметр, слабее сопряжен чем метод с двумя параметрами
       Класс предоставляющий два публичных метода меньше сопряжен чем класс с 5 методами
     - Видимость
       Видимостью называют заметность связи между двумя модулями
       Необходимо делать связи как можно более очевидными и заметными
     - Гибкость
       Гибкость характерезуется легкостью изменения связи между модулями
       Идеальная связь должна быть как можно гибче
       Чем проще вызвать модуль из других модулей, тем лучше
     Выводы сопряжения:
     - Простое сопряжение посредством данных-параметров
       Означает, что между модулями передаются только элементарные типы данных
       (*) ВЫВОД: нормален и приемлен
     - Простое сопряжение посредством обьекта
       Означает, что модуль создает экземпляр данного обьекта
       (*) ВЫВОД: нормален и приемлен
     - Сопряжение посредством обьекта-параметра
       Два модуля сопряжены между собой обьектом-параметром
       Обьект-1 требует чтобы Обьект-2 передал ему Обьект-3
       (*) ВЫВОД: Это сопряжение уже жесче и менее желательно
     - Семантическое сопряжение
       Это самы коварный тип сопряжения
       Один модуль использует некоторые семантические знания о внутренней работе этого модуля
       (*) ВЫВОД: Опасно именть такие связи, надо избегать
     Надо стримиться к малой связанности, чтобы независимо работать над разными кусочками
   - @ "8" Старайтесь использовать популярные шаблоны проектирования
     Есть проблемы, требующие новых решений, но большинство уже решалось
     Шаблоны снижают сложность, предоставляя готовые абстракции
     Шаблоны снижают число ошибок, стандартезируя детали популярных решений
     Использование шаблонов, похоже на использование стандартной библиотеки
     Шаблоны имеют эврестическую ценность, указывая на возможные варианты проектирования
     Код разработтаный на популярном шаблоне, будет понятнее, чем код, разработтаный без
     Шаблоны упрощают взаимодействие между разработчиками
   - @ "9" Другие эвристические принципы
     1 Стремитесь к максимальной связности, тоесть насколько сфокусирован клас или модуль
       Связанность характерезует насколько методы и части класса соответствуют цели класса
     2 Формируйте иерархии
       Иерархия это многоуровневая структура представления информации
       Иерархия уже тысячи лет основной механизм управления сложностью
       Иерархия не устраняет деталея - она просто выталкивает их на другой уровень
     3 Формализуйте контракты классов
       Интерфейс каждого класса это его контракт взаимодействия с другими классами
     4 Грамотно назначайте сферы ответственности
     5 Проектируйте систему для тестирования
       Проектирование длятестирования часто приводит к разработке 
       более формализованных интерфейсов классов, что обычно выгодно
     6 Избегайте неудач
       Необходимо обдумывать сложные куйсы, которые могут привести к аварии
     7 Тщательно выбирайте время связывания
       Временем связывания называют, когда переменной присваивается конкретное значение
       Раннее связывание упрощает код, но снижает его Гибкость
     8 Создайте центральные точки управления
       Звучит как конфиг (application.yaml)
     9 Подумайте об использовании грубой силы
       Работающее решение с грубой силой лучше не работающего
     10 Рисуйте диаграммы
       Это мощный эвристический инструмент, лучше один раз увидеть, чем 100 раз услышать
     11 Поддерживайте модульность проекта системы
       Каждый метод или класс должен быть похож на "черный ящик"
  |
  № 5.4 Методики проектирования
  - Используйте итерацию
    Выполнив проектирование несколько раз вы повысите качество
    Если первая попытка окажется удачной не стоит останавливаться, вторая будет лучше
  - Разделяй и властвуй
    Надо разделить программу на разные области и спроектированть их по отдельности
    Инкрементальное улучшение - мощное средство управления сложностью
  - Нисходящий и восходящий подходы к проектированию
    От общего виденья к деталям или от корневых можелей к общему виду       
    Оба подхода приемлемы
  - Эксперементальное протипирование
    Мы не можем определить проблему проектирования, пока не решите ее хоть частичное
    Прототип надо выкидывать, но почти всегда его продолжают
  - Совместное проектирование
    Две головы лучше, чем одна
    Собрание с обсуждением идей или ревью и инспекция это отлично
  - Какую степень проектирования считать достаточной
    Есть множество факторов влияющих на необходимый уровень детализации
    Факторы: уровень разработчиков, сроки, размер проекта, критичность ошибки в проекте 
    Редко встречаются проекты страдающие от чрезмерного проектирования
  - Регистрация процесса проектирования
    Сохраняйте схемы текст картинки в wiki
  |
  № 5.5 Комментарии по поводу популярных методологий
  - Проектировать все или проектировать ничего, вывод проектировать в достаточной степени


6) [ Часть 2 / Глава 6 ] классы
  № 6.1 Основы классов: абстрактные типы данных
  АТД - абстрактный тип данных (похоже реч тут идет о структурах)
  Частая ошибка это смотреть на АТД, как на контейнер хранения разношерстных методов
  - Преимущества использования АТД
    1 Возможность сокрытия деталей реализации
    2 Ограничение области видимости
    3 Более высокая информативность интерфейса
    4 Легкость оптимизации кода
    5 Легкость проверки кода
    6 Удобочитаемость и понятность кода
    7 Ограничение области использования данных
    8 Возможность работы с сущностями реального мира, 
      а не с низкоуровневыми деталями реализации  
  |    
  № 6.2 Качественные интерфейсы классов
  Первый и самый важный шаг при создании класса, создание интерфейса класса
  - Принцыпы:
   1 Выражайте в интерфейсе класса согласованный уровень абстракции
     В идеале каждый класс должен быть реализацией только одного АТД
   2 Убедитесь, что вы понимаете, реализацией какой абстракции является класс
   3 Представляйте методы вместе с противоположным им методом
   4 Убирайте посторонюю информацию в дркгие классы
     Иногда можно заметить что в классе ряд методов работает с одной половинной
     данных, а другой набор с другой половиной, значит надо разделить класс на два
   5 По мере возможности делайте интерфейсы программными, а не семантическими
     Семантический интерфейс может включать такие соображения, 
     как «Метод А должен быть вызван перед Методом B» или «Метод А вызовет ошибку
     Семантический интерфейс надо документировать, а лучше не использовать
   6 Опасайтесь нарушения целостности интерфейса при изменении класса
     Класс мог быть хорошей абстакцией с понятным интерфейсом, но после правок 
     привратиться в монстра, поэтому изменение интерфейса очень ответственный шаг
   7 Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса
   8 Рассматривайте абстракцию и связность вместе
  Хорошая инкапсуляция
  - Принцыпы:
    1 Минимизируйте доступность классов и их членов
    2 Не делайте данные-члены открытыми
    3 Не включайте в интерфейс класса закрытые детали реализации
      Надо разделять интерфейс и реализацию
    4 Не делайте предположения о клиентах класса
    5 Избегайте использования дружественных классов
    6 Не делайте метод открытым лишь потому, что он использует только открытые методы
    7 Цените легкость чтения кода выше, чем удобство его написания
    8 Очень, очень настороженно относитесь к семантическим нарушениям инкапсуляции
      Мы можем написать свой код, зная об особенностях реализации другого кода, 
      что не допустимо, так как руководствоваться должны только публичным АПИ
      Если по апи класса не понятно, как работать с классом это плохое апи, переделываем
    9 Остерегайтесь слишком жесткого сопряжения  
      - минимизируйте доступность классов и их членов
      - избегайте дружественных классов, потому что они связаны жестко
      - делайте данные базового класса закрытыми, а не защищенными: это ослабляет 
        сопряжение производных классов с базовым
      - не включайте данные члены в открытый интерфейс класса
      - остерегайтесь семантических нарушений инкапсуляции
  |    
  № 6.3 Вопросы проектирования и реализации
  В этом разделе обсудим как реализовать внутреннее устройство классов
  - Включение (отношение "содержит")
    Один класс содержит примитивный элемент данных или другой класс
    Включение - один из главных инструментов ООП
    - Реализуйте с помощью включеия отношение "содержит"
      Например обьект "Сотрудник" может содержать "Фамилия"
    - В крайнем случае реализуйте отношение "Содержит" через закрытое наследование
      Если вам приходится это делать, обычно указывает на ошибки проектирования  
    - Насторожено относитесь к классам, содержащим более семи элементов данных-членов
      Человек может удерживать в памяти 7 +/- 2 дискретных элементов
  - Наследование (отношение "является")
    Наследование подразумевает, что один класс является более специализированным вариантом
    - Реализуйте при помощи открытого наследования отношение "является"
      Базовый класс формирует ожидания и ограничения, которым будет соответствовать
      производный класс
      (!) Если производный класс не собирается полностью придерживаться контракта,
      определенного интерфейса базового класса, наследование выполнять не стоит
    - Проектируйте и документируйте классы с учетом возможности наследования или запретить
    - Соблюдайте принцип подстановки Лисков
      1 Наследование стоит использовать, только если производный класс действительно
        "является" более специализированной версией базового класса
      2 Клиенты должны иметь возможность использования подклассов через интерфейс
        базового класса, не замечая никаких различий
      3 При соблюдении принципа подстановки Лисков наследование - сильно снижает сложность
    - Убедитесь, что вы наследуете только то, что хотите наследовать
      (*) Ели вам нужна реализация класса, но не его интерфейс, используйте Включение
    - Не "переопределяйте" непереопределяемые методы-члены
      Не используйте имена непереопределяемых методов базового класса в производных
    - Перемещайте общие интерфейсы, данные и формы поведения на как можно более
      высокий уровень иерархии наследования
    - С подозрением относитесь к классам, обьекты которых создаются в единственном
      экземпляре (singleton - исключение)
    - С подозрением относитесь к базовым классам, имеющим толко один производный класс
      Похоже кто-то проектировал наперед, это плохая практика - больше кода больше проблем
    - С подозрением относитесь к классам, которые переопределяют метод, оставляя пустым
      Это почти точно ошибка проектирования
      Это звоночек нарушении контракта базового класса
    - Избегайте многоуровневых иерархий наследования
      Большенству людей трудно удержать в голове больше 3 уровней
      Надо помнить, что наследовоние должно уменьшать дублирование и сложность  
    - Предпочитайте полиморфизм, а не крупномасштабную проверку типов
      Наличие блоков "case" почти всегда говорит об ошибке проектирования
    - Делайте все данные закрытыми, а не защищенными
    - Множественное наследование
      Наследование - мощный и довольно опасный инструмент
      Лучше не прибегать к множественному наследованию  
  - Методы-члены и данные-члены 
    - Включайте в класс как можно меньше методов
    - Блокируйте неявно сгенерированные методы и операторы, которые вам не нужны
    - Минимизируйте число разных методов, вызываемых классов
    - Избегайте опосредованных вызовов методов других классов
      «Правило Деметры (Law of Demeter)», которое гласит, что Объект A может вызывать 
      любые из собственных методов. Если он создает Объект B, он может вызывать любые 
      методы Объекта
    - Вообще минимизируйте сотрудничество класса с другими классами
      Минимизируйте число видов создаваемых обьектов
      Минимизируйте число непосредственно вызываемых методов созданных обьектов
      Минимизируйте число вызовов методов, принадлежащих обьектам, возвр другими обьектами
  - Конструкторы
    - Инициализируйте по мере возможности все данные-члены во всех конструкторах
    - Создавайте классы одиночки с помощью закрытого конструктора
    - Если сомневаетесь, выполняйте полное копирование, а не ограниченное
      Ограниченное копирование - обычно получение ссылки на обьект
  |    
  № 6.4 Разумные причины создания классов
  Причины
    - Моделирование обьектов реального мира
      Это не главная но основная причина
    - Моделирование абстрактных обьектов
      Пример такого класса "Фигура"
    - Изоляция сложности
    - Сокрытие деталей реализации
    - Ограничение влияния изменений
    - Сокрытие глобальных данных
    - Упрощение передачи параметров в методы
    - Создание центральных точек управления
    - Облегчение повторного использования кода
    - Планирование создания семейства программ   
      Рассуждения о том как может выглядеть семейство таких программ как наша, полезно   
    - Упаковка родственных операций
      Плошая практика, но лучше чем не делать этого над блуждающими методами 
    - Выполнение специфического вида рефакторинга
  Классы, которых следует избегать  
    - Избегайте создания "божественных" классов
      Универсальный всемогущий класс это беда для проекта, разбить на классы по одной цели
    - Устраняйте неревантные классы
    - Избегайте классов, имена которых напоминают глаголы
      Похоже это должен быть не класс а метод класса
  |    
  № 6.5 Аспекты, специфические для языков
  - не важно
  |    
  № 6.6 Следующий уровень: пакеты классов
  Использование классов - лучший способ достижения модульности
  Если язык не поддерживает пакеты, поддерживайте их сами


7) [ Часть 2 / Глава 7 ] Высококачественные методы












 perfect-code-book add new part of summery

  стр 179 в chrome















[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
