---
Ресурсы:

// оф сайт
- [ https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D0%BA%D0%BE%D0%BD%D0%BD%D0%B5%D0%BB%D0%BB,_%D0%A1%D1%82%D0%B8%D0%B2 ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ Совершенный код ] это одна из лучших книг по программированию.



1) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 1 ] Добро пожаловать в мир конструирования ПО! 
  - вводная информация
  - Этапы создания ПО:
    1 Выработка требований
    2 Проектирование архитектуры
    3 Конструирование


2) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 2 ] Метафоры, позволяющие лучше понять разработку ПО 
  - Инкрементальный подход к разработке это лучшее, что есть на сегодня
  - Подходящая аналогия к разработке ПО это строительство (дома, небоскреба, будки для собаки)
  - необходимо понимать что мы строим, для этого используется планирование
  - при разработке ПО не нужно писать велосипеды, если есть написанные штуки, надо использовать


3) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 3 ] Семь раз отмерь, один раз отрежь: предварительные условия
  - перед началом создания проекта, надо провести подготовку
    и проверить все ли готово для реализации намеченного плана.
  - мы должны потратить много времени на планирование!
  - необходимо выработать как можно более широкий набор требований к продукту.
  - Первое что мы должны понять, это проблема которую мы хотим решить.
  - Определение проблемы - это формирование сути проблемы без намеков на решение.
  - Определение проблемы - это фундамент всего процесса программирования
  -       ::
         :  :         - Будущие решения
        :    :        - Тестирование системы 
       :      :       - Конструирование
      :        :      - Проектирование архитектуры
     :          :     - Выработка требований
    :            :    - Определение проблемы
   :::::::::::::::: 
  - Проблема должна быть описана на языке пользователя, 
    обычно описание не содержит технических терминов.
  - (*) к проектированию архитектуры переходим после проработки требований !
  - Архитектура — это высокоуровневая часть проекта приложения, 
    каркас, состоящий из деталей проекта.
  - Архитектура должна четко определять ответственность каждого компонента.
  - Компонент должен иметь одну область ответственности и как можно меньше знать 
    об областях ответственности других компонентов.
  - Архитектура должна быть модульной, чтобы можно было заменять модули.
  - Архитектура должна учитывать ресурсы памяти, ЦПУ, коннектов к базе и тд.
  - Архитектура должна определять подход к безопасности как на уровне проекта
    приложения, так и на уровне кода.
  - Производительность: в требованиях следует определить показатели производительности,
    а в архитектуре описать обьяснение, что такая архитектура сможет реализовать требования
  - Масштабируемость: Архитектура должна описывать, как система будет реагировать на рост
    числа пользователей, серверов, сетевых узлов, записей в БД, транзакций и т.д
  - Интернационализация/локализация: в архитектуре должно быть описано как реализуется это.
  - Обработка ошибок: стратегия обработки ошибок должна быть выражена в архитектуре
  - Отказоустойчивость: необходимо описать сценарии ошибок и отказов, которые не должны 
    приводить к потере работоспособности.
  - Возможность реализации архитектуры: нужно быть увереными, что архитектура реализуема.
    Невозможность реализации какого-то компонента может сделать проект неработоспособным.
    (*) как решение это написание прототипов таких можулей или дополнительное исследование.
  - Стратегия изменений: Архитектура должна показывать, что возможные улучшения
    рассматривались и что реализация наиболее вероятных улучшений окажется наиболее простой. 


4) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 4 ] Основные решения, которые приходится принимать при конструировании
  - Необходимо ввести стиль использования выбранного языка программирования.
  - Большинство важных принципов программирования не от конкретных языков, 
    а от способа их использовать.


5) [ Часть 2 ] Высококачественный код
5) [ Часть 2 / Глава 5 ] Высококачественный код
  - Проектирование ПО - под этим обычно понимают разработку или изобретение схемы
    преобразования спецификации приложения в готовое приложение.
  - Проектирование - "грязная" проблема. Прикол в том что такую проблему можно
    определить только через полное или частичное решение.
    (*) получается надо один раз решить проблему, чтобы получить ее ясное представление,
    а потом решить еще раз для создания работоспособного решения.
  - Проектирование это постоянный анализ конкурирующих характеристик проекта и достижение
    баланса между ними.
  - Проектирование подразумевает ограничение возможностей.
  - Проектирование не имеет единствено верного решения, 
    при решении разными разработчиками, получим несколько разных, но решающих проблему програм
  - Проектирование - процесс из проб и ошибок, постепенный процесс
  |
  № 5.2 Основные концепции проектирования:
    - Управление сложностью - самый важный технический аспект разработки ПО.
      Необходимо организовать код так, чтобы можно было безопасно работать с частями.
      Несколько не сложных фрагментов понять проще, чем один сложный.
      (*) Необходимо свести к минимому обьем существенной сложности, 
      с которым придется работать в каждый конкретный момент времени.
      (**) Необходимо сдерживать необязательный рост несущественной сложности.
      (!) все принцыпы програмирования ведут к уменьшению частичной сложности кода.
    - Желательные характеристики проекта
      - @ Минимальная сложность
        Надо создавать простые и понятные проекты
      - @ Простота сопровождения
        При проектировании нельзя забывать о людях из сопровождения
      - @ Слабоя сопряжение
        Сведение к минимому числа соединений между разными частями программы
      - @ Расширяемось
        Внесение наиболее вероятных изменений должно требовать наименьших усилий.
      - @ Возможность повторного использования
        Признах хорошего проектирования программы это когда код легко переиспользовать.
      - @ Высокий коэффициент обьединения по входу
        Хорошо когда созданный нами клас много где используется
      - @ Низкий или средний коэффициент разветвления по выходу
        Плохо когда один класс для своей работы требует ссылки на множество классов
      - @ Портируемость
        Проектировать надо так, чтобы систему можно было легко аадптировать к другой среде.
      - @ Минимальная, но полная функциональность
        Меньше кода - меньше проблем
      - @ Стратификация
        Необходимо разрабатывать систему, чтобы можно разделить по уровням декомпозиции
        Если есть старый или плохой код лучше сделать клас мост, чтобы изолировать его
      - @ Соответствие стандартным методикам
        Необходимо применять стандартные и популяные подходы
  - Уровни проектирования
    - "Уровень 1" Программная система
      Этому уровню соответствует вся система.
    - "Уровень 2" Разделение системы на подсистемы или пакеты
      Результат проектирования на этом уровне - определение основных подсистем
      Особенно важно определить правила взаимодействия и ограничивать эти связи
      Архитектура системы должна быть такой, чтобы замена подсистемы была максимально простой
      часто используемые варианты подсистем:
      - @ Подсистема пользовательского интерфейса
        изоляция GUI органична и удобна
      - @ Подсистема доступа к БД
        изоряция общения с БД отличная идея
      - @ Подсистема изоляции зависимостей от ОС
        Так как потом велик шанс задачи адоптации под другую ОС
    - "Уровень 3" разделение подсистем на классы
      Это уже уровень, где мы определяем необходимый набор классов   
      На этом уровне должно быть понятно как реализовать систему на уровне классов
    - "Уровень 4" разделение классов на методы
      Надо определить методы классов, можно этот уровень комбинировать с предыдущем
    - "Уровень 5" проектирование методов
      На этом уровне детально проектируется функциональность методов
      Например пишется псевдогод
  |  
  № 5.3 Компоненты проектирования: эвристические принципы
    Проектирование не является детерминированным
    - @ "1" Определите обьекты реального мира
      при проектировании определяем:
        - объекты и их атрибуты (методы и данные)
          (*) однозначное соответствие обьектов реального мира и программы
          подходит для начала, но обычно это не лучшая идея
        - действия, которые могут быть выполнены над каждым объектом
          (*) например обьект сотрудник может поддерживать операцию смены имени
        - действия, которые каждый объект может выполнять над другими объектами
          (*) какой обьект может включать другой обьект,
          какой обьект может выполнять действия над другим обьектом
        - части каждого объекта, видимые другим объектам
        - открытый интерфейс каждого объекта
          (*) для каждого обьекта надо определить формальный синтаксический интерфейс
    - @ "2" Определите согласованные абстракции
      Создание абстракций позволяет работать с обьектами не вдаваясь в подробности
    - @ "3" Инкапсулируйте детали реализации
      Инкопсуляция помогает управлять сложностью блокируя доступ к ней
    - @ "4" Используйте наследование, если оно упрощает проектирование
      При правильном использовании принесет большую пользу
   - @ "5" Скрывайте секреты (к вопросу о сокрытии информации)
     Это мощный принцып, который подчеркивает необходимость сокрытия сложности
     Секретом может быть источник вероятных изменений, формат файла, алгоритм и т.д
     Класс может использовать несколько типов данных не раскрывая сведений о них
     Интерфейс класса должен сообзать как можно меньше о внутренней работе класса
     Класс должен быть похож на айсберг
   - @ "6" Определите области вероятных изменений
     Находим элементы, изменение которых кажется вероятным
     Отделяем эти элименты, чтобы при изменении как можно меньше менять
     Спроектировать интервейс который будет не зависеть от изменений
     - Чаще всего меняется:
       - Бизнес правила
       - Зависимости от оборудования
       - Ввод-вывод
       - Нестандартные возможности языка
       - Сложные аспекты проектирования и конструирования
       - Переменные статуса
       - Размеры структур данных
   - @ "7" Поддерживайте сопряжение слабым
     Сопряжение характерезует силу связи класса или метода с другими классами или методами
     Стараться создавать модули, слабо зависящие от других
     Критерии оценки сопряжения:
     - Обьем
       Обьем связи характерезует число связей, чем меньше тем лучше
       Метод, принимающий один параметр, слабее сопряжен чем метод с двумя параметрами
       Класс предоставляющий два публичных метода меньше сопряжен чем класс с 5 методами
     - Видимость
       Видимостью называют заметность связи между двумя модулями
       Необходимо делать связи как можно более очевидными и заметными
     - Гибкость
       Гибкость характерезуется легкостью изменения связи между модулями
       Идеальная связь должна быть как можно гибче
       Чем проще вызвать модуль из других модулей, тем лучше
     Выводы сопряжения:
     - Простое сопряжение посредством данных-параметров
       Означает, что между модулями передаются только элементарные типы данных
       (*) ВЫВОД: нормален и приемлен
     - Простое сопряжение посредством обьекта
       Означает, что модуль создает экземпляр данного обьекта
       (*) ВЫВОД: нормален и приемлен
     - Сопряжение посредством обьекта-параметра
       Два модуля сопряжены между собой обьектом-параметром
       Обьект-1 требует чтобы Обьект-2 передал ему Обьект-3
       (*) ВЫВОД: Это сопряжение уже жесче и менее желательно
     - Семантическое сопряжение
       Это самы коварный тип сопряжения
       Один модуль использует некоторые семантические знания о внутренней работе этого модуля
       (*) ВЫВОД: Опасно именть такие связи, надо избегать
     Надо стримиться к малой связанности, чтобы независимо работать над разными кусочками
   - @ "8" Старайтесь использовать популярные шаблоны проектирования
     Есть проблемы, требующие новых решений, но большинство уже решалось
     Шаблоны снижают сложность, предоставляя готовые абстракции
     Шаблоны снижают число ошибок, стандартезируя детали популярных решений
     Использование шаблонов, похоже на использование стандартной библиотеки
     Шаблоны имеют эврестическую ценность, указывая на возможные варианты проектирования
     Код разработтаный на популярном шаблоне, будет понятнее, чем код, разработтаный без
     Шаблоны упрощают взаимодействие между разработчиками
   - @ "9" Другие эвристические принципы
     1 Стремитесь к максимальной связности, тоесть насколько сфокусирован клас или модуль
       Связанность характерезует насколько методы и части класса соответствуют цели класса
     2 Формируйте иерархии
       Иерархия это многоуровневая структура представления информации
       Иерархия уже тысячи лет основной механизм управления сложностью
       Иерархия не устраняет деталея - она просто выталкивает их на другой уровень
     3 Формализуйте контракты классов
       Интерфейс каждого класса это его контракт взаимодействия с другими классами
     4 Грамотно назначайте сферы ответственности
     5 Проектируйте систему для тестирования
       Проектирование длятестирования часто приводит к разработке 
       более формализованных интерфейсов классов, что обычно выгодно
     6 Избегайте неудач
       Необходимо обдумывать сложные куйсы, которые могут привести к аварии
     7 Тщательно выбирайте время связывания
       Временем связывания называют, когда переменной присваивается конкретное значение
       Раннее связывание упрощает код, но снижает его Гибкость
     8 Создайте центральные точки управления
       Звучит как конфиг (application.yaml)
     9 Подумайте об использовании грубой силы
       Работающее решение с грубой силой лучше не работающего
     10 Рисуйте диаграммы
       Это мощный эвристический инструмент, лучше один раз увидеть, чем 100 раз услышать
     11 Поддерживайте модульность проекта системы
       Каждый метод или класс должен быть похож на "черный ящик"
  |
  № 5.4 Методики проектирования
  - Используйте итерацию
    Выполнив проектирование несколько раз вы повысите качество
    Если первая попытка окажется удачной не стоит останавливаться, вторая будет лучше
  - Разделяй и властвуй
    Надо разделить программу на разные области и спроектированть их по отдельности
    Инкрементальное улучшение - мощное средство управления сложностью
  - Нисходящий и восходящий подходы к проектированию
    От общего виденья к деталям или от корневых можелей к общему виду       
    Оба подхода приемлемы
  - Эксперементальное протипирование
    Мы не можем определить проблему проектирования, пока не решите ее хоть частичное
    Прототип надо выкидывать, но почти всегда его продолжают
  - Совместное проектирование
    Две головы лучше, чем одна
    Собрание с обсуждением идей или ревью и инспекция это отлично
  - Какую степень проектирования считать достаточной
    Есть множество факторов влияющих на необходимый уровень детализации
    Факторы: уровень разработчиков, сроки, размер проекта, критичность ошибки в проекте 
    Редко встречаются проекты страдающие от чрезмерного проектирования
  - Регистрация процесса проектирования
    Сохраняйте схемы текст картинки в wiki
  |
  № 5.5 Комментарии по поводу популярных методологий
  - Проектировать все или проектировать ничего, вывод проектировать в достаточной степени


6) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 6 ] классы
  № 6.1 Основы классов: абстрактные типы данных
  АТД - абстрактный тип данных (похоже реч тут идет о структурах)
  Частая ошибка это смотреть на АТД, как на контейнер хранения разношерстных методов
  - Преимущества использования АТД
    1 Возможность сокрытия деталей реализации
    2 Ограничение области видимости
    3 Более высокая информативность интерфейса
    4 Легкость оптимизации кода
    5 Легкость проверки кода
    6 Удобочитаемость и понятность кода
    7 Ограничение области использования данных
    8 Возможность работы с сущностями реального мира, 
      а не с низкоуровневыми деталями реализации  
  |    
  № 6.2 Качественные интерфейсы классов
  Первый и самый важный шаг при создании класса, создание интерфейса класса
  - Принцыпы:
   1 Выражайте в интерфейсе класса согласованный уровень абстракции
     В идеале каждый класс должен быть реализацией только одного АТД
   2 Убедитесь, что вы понимаете, реализацией какой абстракции является класс
   3 Представляйте методы вместе с противоположным им методом
   4 Убирайте посторонюю информацию в дркгие классы
     Иногда можно заметить что в классе ряд методов работает с одной половинной
     данных, а другой набор с другой половиной, значит надо разделить класс на два
   5 По мере возможности делайте интерфейсы программными, а не семантическими
     Семантический интерфейс может включать такие соображения, 
     как «Метод А должен быть вызван перед Методом B» или «Метод А вызовет ошибку
     Семантический интерфейс надо документировать, а лучше не использовать
   6 Опасайтесь нарушения целостности интерфейса при изменении класса
     Класс мог быть хорошей абстакцией с понятным интерфейсом, но после правок 
     привратиться в монстра, поэтому изменение интерфейса очень ответственный шаг
   7 Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса
   8 Рассматривайте абстракцию и связность вместе
  Хорошая инкапсуляция
  - Принцыпы:
    1 Минимизируйте доступность классов и их членов
    2 Не делайте данные-члены открытыми
    3 Не включайте в интерфейс класса закрытые детали реализации
      Надо разделять интерфейс и реализацию
    4 Не делайте предположения о клиентах класса
    5 Избегайте использования дружественных классов
    6 Не делайте метод открытым лишь потому, что он использует только открытые методы
    7 Цените легкость чтения кода выше, чем удобство его написания
    8 Очень, очень настороженно относитесь к семантическим нарушениям инкапсуляции
      Мы можем написать свой код, зная об особенностях реализации другого кода, 
      что не допустимо, так как руководствоваться должны только публичным АПИ
      Если по апи класса не понятно, как работать с классом это плохое апи, переделываем
    9 Остерегайтесь слишком жесткого сопряжения  
      - минимизируйте доступность классов и их членов
      - избегайте дружественных классов, потому что они связаны жестко
      - делайте данные базового класса закрытыми, а не защищенными: это ослабляет 
        сопряжение производных классов с базовым
      - не включайте данные члены в открытый интерфейс класса
      - остерегайтесь семантических нарушений инкапсуляции
  |    
  № 6.3 Вопросы проектирования и реализации
  В этом разделе обсудим как реализовать внутреннее устройство классов
  - Включение (отношение "содержит")
    Один класс содержит примитивный элемент данных или другой класс
    Включение - один из главных инструментов ООП
    - Реализуйте с помощью включеия отношение "содержит"
      Например обьект "Сотрудник" может содержать "Фамилия"
    - В крайнем случае реализуйте отношение "Содержит" через закрытое наследование
      Если вам приходится это делать, обычно указывает на ошибки проектирования  
    - Насторожено относитесь к классам, содержащим более семи элементов данных-членов
      Человек может удерживать в памяти 7 +/- 2 дискретных элементов
  - Наследование (отношение "является")
    Наследование подразумевает, что один класс является более специализированным вариантом
    - Реализуйте при помощи открытого наследования отношение "является"
      Базовый класс формирует ожидания и ограничения, которым будет соответствовать
      производный класс
      (!) Если производный класс не собирается полностью придерживаться контракта,
      определенного интерфейса базового класса, наследование выполнять не стоит
    - Проектируйте и документируйте классы с учетом возможности наследования или запретить
    - Соблюдайте принцип подстановки Лисков
      1 Наследование стоит использовать, только если производный класс действительно
        "является" более специализированной версией базового класса
      2 Клиенты должны иметь возможность использования подклассов через интерфейс
        базового класса, не замечая никаких различий
      3 При соблюдении принципа подстановки Лисков наследование - сильно снижает сложность
    - Убедитесь, что вы наследуете только то, что хотите наследовать
      (*) Ели вам нужна реализация класса, но не его интерфейс, используйте Включение
    - Не "переопределяйте" непереопределяемые методы-члены
      Не используйте имена непереопределяемых методов базового класса в производных
    - Перемещайте общие интерфейсы, данные и формы поведения на как можно более
      высокий уровень иерархии наследования
    - С подозрением относитесь к классам, обьекты которых создаются в единственном
      экземпляре (singleton - исключение)
    - С подозрением относитесь к базовым классам, имеющим толко один производный класс
      Похоже кто-то проектировал наперед, это плохая практика - больше кода больше проблем
    - С подозрением относитесь к классам, которые переопределяют метод, оставляя пустым
      Это почти точно ошибка проектирования
      Это звоночек нарушении контракта базового класса
    - Избегайте многоуровневых иерархий наследования
      Большенству людей трудно удержать в голове больше 3 уровней
      Надо помнить, что наследовоние должно уменьшать дублирование и сложность  
    - Предпочитайте полиморфизм, а не крупномасштабную проверку типов
      Наличие блоков "case" почти всегда говорит об ошибке проектирования
    - Делайте все данные закрытыми, а не защищенными
    - Множественное наследование
      Наследование - мощный и довольно опасный инструмент
      Лучше не прибегать к множественному наследованию  
  - Методы-члены и данные-члены 
    - Включайте в класс как можно меньше методов
    - Блокируйте неявно сгенерированные методы и операторы, которые вам не нужны
    - Минимизируйте число разных методов, вызываемых классов
    - Избегайте опосредованных вызовов методов других классов
      «Правило Деметры (Law of Demeter)», которое гласит, что Объект A может вызывать 
      любые из собственных методов. Если он создает Объект B, он может вызывать любые 
      методы Объекта
    - Вообще минимизируйте сотрудничество класса с другими классами
      Минимизируйте число видов создаваемых обьектов
      Минимизируйте число непосредственно вызываемых методов созданных обьектов
      Минимизируйте число вызовов методов, принадлежащих обьектам, возвр другими обьектами
  - Конструкторы
    - Инициализируйте по мере возможности все данные-члены во всех конструкторах
    - Создавайте классы одиночки с помощью закрытого конструктора
    - Если сомневаетесь, выполняйте полное копирование, а не ограниченное
      Ограниченное копирование - обычно получение ссылки на обьект
  |    
  № 6.4 Разумные причины создания классов
  Причины
    - Моделирование обьектов реального мира
      Это не главная но основная причина
    - Моделирование абстрактных обьектов
      Пример такого класса "Фигура"
    - Изоляция сложности
    - Сокрытие деталей реализации
    - Ограничение влияния изменений
    - Сокрытие глобальных данных
    - Упрощение передачи параметров в методы
    - Создание центральных точек управления
    - Облегчение повторного использования кода
    - Планирование создания семейства программ   
      Рассуждения о том как может выглядеть семейство таких программ как наша, полезно   
    - Упаковка родственных операций
      Плошая практика, но лучше чем не делать этого над блуждающими методами 
    - Выполнение специфического вида рефакторинга
  Классы, которых следует избегать  
    - Избегайте создания "божественных" классов
      Универсальный всемогущий класс это беда для проекта, разбить на классы по одной цели
    - Устраняйте неревантные классы
    - Избегайте классов, имена которых напоминают глаголы
      Похоже это должен быть не класс а метод класса
  |    
  № 6.5 Аспекты, специфические для языков
  - не важно
  |    
  № 6.6 Следующий уровень: пакеты классов
  Использование классов - лучший способ достижения модульности
  Если язык не поддерживает пакеты, поддерживайте их сами


7) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 7 ] Высококачественные методы
  |    
  № 7.1 Разумные причины создания методов
  - Снижение сложности
  - Формирование понятной промежуточной абстракции
  - Предотвращение дублирования кода
  - Поддержка наследования
  - Сокрытие очередности действий
  - Сокрытие операций над указателями
  - Улучшение портируемости
  - Упрощение сложных булевых проверок
  - Повышение быстродействия
  - Для уменьшения обьема других методов
  |    
  № 7.2 Проектирование на уровне методов
  Метод должен эфективно делать одну четкую задачу
  Есть разные виды связанности
  - Функциональная связанность 
    Это самый сильный и лучший вид
    Это когда метод имеет обну функцию и выполняет ее
    Примеры  GetCustomerName(), EraseFile(), AgeFromBirthdate()
  - Последовательная связанность
    Вид связи не желателен, но приемлем
    Это плохой вид связанности, суть в том что действия в методе связаны порядком вызова
    Надо сделать из такого метода несколько отдельных методов
  - Коммуникационная связанность
    Вид связи не желателен, но приемлем
    Это когда мы используем одни и те же данные и операции не связаны другим способом
    Две операции в методе обьеденяет только то, что они обращаются к одним данным
    Такой метод надо разделять на отдельные
  - Временная связанность
    Вид связи не желателен, но приемлем
    Обьединение на основании, что все они выполняются в один интервал времени
    Пример: Startup(), Shutdown()
    Решение это не делать в методе вызов действий напрямую, а пусть читается конфиг
    и уже исходя из конфига делается набор действий
  |    
  № 7.3 Удачные имена методов
  - Описывайте все, что метод выполняет   
  - Избегайте невыразительных и неоднозначных глаголов
    Невыразительное имя означает не ясную цель метода, а это плохой метод
  - Не используйте для дифференциации имен методов исключительно номера
    Дич, нечего обсуждать
  - Не ограничивайте длину имен методов искусственными правилами
  - Для именования функции используйте описание возвращаемого значения
    Пример: customerId.Next(), printer.IsReady() и pen.CurrentColor()
  - Для именования процедуры используйте выразительный глагол, дополняя его объектом
    Формату «глагол + объект»
    Пример: document.Print(), orderInfo.Check() и monthlyRevenues.Calc().
  - Дисциплинированно используйте антонимы
    Пример популярных антонимов:
     - add/remove      increment/decrement   open/close
     - begin/end       insert/delete         show/hide
     - create/destroy  lock/unlock           source/target
     - first/last      min/max               start/stop
     - get/put         next/previous         up/down
     - get/set         old/new
  - Определяйте конвенции именования часто используемых операций
    В Java конвенция есть по дефолту
  |    
  № 7.4 Насколько обьемным может быть метод?
  Отсекаем все лишнее, что осталось то и оставляем
  Большие методв больше 200 строк почти точно надо разбивать
  |    
  № 7.5 Советы по использованию параметров методов
  Интерфейсы между методами — один из основных источников ошибок
  Советы:
  - Передавайте параметры в порядке 
    «входные значения - изменяемые значения — выходные значения»
    (*) Это больше актуально для C++, но в java тоже можем так писать
  - Если несколько методов используют похожие параметры, передавайте
    их в согласованном порядке  
  - Используйте все параметры
    Наличие неиспользуемого параметра это звоночек, надо его удалить
  - Передавайте переменные статуса или кода ошибки последними
  - Не используйте параметры метода в качестве рабочих переменных
    другими словами НЕ модифицируй входные параметры без супер необходимости
    копируем значение во внутренние переменные и работаем
  - Документируйте выраженные в интерфейсе предположения о параметрах
    Что документировать:
    - вид параметров: являются ли они исключительно входными, изменяемыми или 
      исключительно выходными
    - единицы измерения (дюймы, футы, метры и т. д.)
    - смысл кодов статуса и ошибок, если для их представления не используются перечисления
      диапазоны допустимых значений
    - специфические значения, которые никогда не должны передаваться в метод
  - Ограничивайте число параметров метода примерно семью
    Если вам постоянно приходится передавать в методы слишком большое число
    аргументов, ваши методы имеют слишком сильное сопряжение. 
    Проектируйте методы или группы методов так, чтобы сопряжение было слабым
    (*) Если вы передаете одни и те же данные во многие разные методы, 
        сгруппируйте эти методы и данные в класс.
  - Подумайте об определении конвенции именования входных, изменяемых и выходных параметров
    Для Java не очень актуально (обычно не модефицируем обьект переданный в аргументах)
  - Передавайте в метод те переменные или объекты, которые нужны ему
    для поддержания абстракции интерфейса
    (*) тут есть два подхода
    У нас есть метод которому нужно скажем три поля из обьекта и вопрос передавать
    весь обьект как аргумент или только эти поля?
    - Первый (только поля)
      - это поддерживает минимальное сопряжение
      - способствует более быстрому пониманию методов
      - облегчает повторное использование
      - (*) передача всего обьекта нарушает принцып инкапсуляции
        так как мы получим обьект и получим доступ к полям, которые нам не нужны
    - Второй (весь класс)
      - удобно
      - ничего не нарушает
    - ВЫВОД
      - обы подхода не верные 
      - какую абстракцию формирует интерфейс метода?
      - Обычно наличие кода, «подготавливающего» данные перед вызовом метода 
        или «разбирающего» объект после вызова, — признак неудачного 
        проектирования метода.
  - Используйте именованные параметры
  - Убедитесь, что фактические параметры соответствуют формальным
    - это переменные, объявленные в определении метода
    - Для Java не актуально
  |    
  № 7.6 Отдельные соображения по использованию функций
  Тут вводим термины шаткие
    - Функция - это метод, возвращающий значение
    - Процедура - это метод, не возвращающий значение
  Когда использовать функцию, а когда процедуру?
    - Если основная цель вернуть значение используем функцию
  Возврат значения из функции
    - Проверяйте все возможные пути возврата
      - проверяем все сценарии выполнения ф-ии
    - Не возвращайте ссылки или указатели на локальные данные
      - (*) не актуально для Java
  |    
  № 7.7 Методы-макросы и встраиваемые методы
  - Разрабатывая макрос, заключайте в скобки все, что можно
    - " #define Cube( a ) a*a*a " отработет не верно, если заюзать Cube( 4+1 )
      так как это просто текстовая замена порядок действий удивит
  Все что дальше описано не актуально для Java
  

8) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 8 ] Защитное программирование
  |    
  № 8.1 Защита программы от неправильных входных данных
  Идея защитного программирования в том, что если методу передаются
  некорректные данные, то его работа не нарушится, даже если эти данные 
  испорчены по вине другой программы.
  Основные способы обработки входных данных:
  - Проверяйте все данные из внешних источников
    Проверяем все значения, что они попадают в допустимый интервал
    Проверяем что строки не больше определенной длины
    Проверить например SQL иньекци и т.д
  - Проверяйте значения всех входных параметров метода
    Дальше в 8.5 узнаем в каких методах важно проверять аргументы
    Это то же самое, что и прошлый пункт для данных, только тут для аргументов
  - Решите, как обрабатывать неправильные входные данные
    Что делать, если пришел неверный праметр, ответов миллион
  |    
  № 8.2 Утверждения
  Утверждения - это код, используемый во время разработки, для проверки выполнения
  Утверждения полезны, когда есть высокие требования к надежности
  Пример на Java:
    - assert denominator != 0 : ”denominator is unexpectedly equal to 0.”;
  Утверждения не предназначены для показа сообщений в промышленной версии
  При компиляции промышленной версии, обычно, утверждения удаляют
  Общие принципы использования утверждений
  - Используйте процедуры обработки ошибок для ожидаемых событий и утверждения 
    для событий, которые происходить не должны
    (*) Утверждения проверяют условия событий, которые никогда не должны происходить
  - Старайтесь не помещать выполняемый код в утверждения
    Есть вероятность что компилятор удалит этот код при отключении утверждений
  - Используйте утверждения для документирования и проверки предусловий и постусловий
    1 Предусловия — это обязательства клиентского кода перед кодом, который он вызывает
    2 Постусловия — это обязательства метода или класса перед кодом, который их использует
    3 Утверждения — удобный инструмент для документирования пред- и постусловий
  - Для большей устойчивости кода проверяйте утверждения, а затем все равно 
    обработайте возможные ошибки
  |    
  № 8.3 Способы обработки ошибок
  Способы:
    - Вернуть нейтральное значение
      Нам пришли не верные данные, а мы возвращаем приемлемое-нетральное значение
      Надо подумать о последствиях и возможно лучше остановить программу
    - Заменить следующим корректным блоком данных
      Если мы получаем непрерывно данные мы можем игнорировать ломанные данные
    - Вернуть тот же результат, что и в предыдущий раз
      Получаем значения раз в сек, есл пришла ерунда, оставляем старое значение
    - Подставить ближайшее допустимое значение
    - Записать предупреждающее сообщение в файл (в лог)
      Этот подход можно сочетать с другими  
    - Вернуть код ошибки
      Тут важно определить какая часть системы будет обрабатывать ошибки
    - Вызвать процедуру или обьект - обработчик ошибки
      Создаем мега класс и обрабатываем ошибочки, подход сомнительный
    - Показать сообщение об ошибке, где бы она ни случилась
      Тоже сомнительный подход
    - Обработать ошибку в месте возникновения наиболее подходящим способом
    - Прекратить выполнение
      Оправдано в очень критичном к безопасности ПО
  Устойчивость против корректности
    Выбор подходящего метода обработки ошибки зависит от приложения
    Корректность предпологает, что нельзя возвращать не точный результат
    Устойчивость говорит о том, что программа пытается продолжить работу не смотря
  Влияние выбора метода обработки ошибок на проектирование высокого уровня
    Способ обработки ошибок влияет на требования корректности и устойчивости 
    Выбор общего подхода к работе с некорректными данными - это вопрос архитектуры 
  |    
  № 8.4 Исключения
  Исключение - это способ метода сказать "Я не знаю, что с этим делать"
  Исключения с наследование мощные инструменты, мугут сильно влиять на общую сложность
  Советы:
    - Используйте исключения для оповещения других частей программы об ошибках, 
      которые нельзя игнорировать  
    - Генерируйте исключения только для действительно исключительных ситуаций
      Если мы никак не можем другими средствами решить проблему, кидаем исключение
    - Не используйте исключения по мелочам
      Если ошибку можем исправить на месте, то ислючение не нужно
    - Избегайте генерировать исключения в конструкторах и деструкторах,
      если только вы не перехватываете их позднее
    - Генерируйте исключения на правильном уровне абстракции
      Интерфейс метода и класса должен представлять собой целостную абстракцию. 
      Исключения — такая же часть интерфейса, как и специальные типы данных
      Плохой пример:
        - public TaxId GetTaxId() throws EOFException
          (*) вместо "EOFException" метод должен кидать искл своего уровня абстракции,
          например "TaxIdNotFoundException"
    - Вносите в описание исключения всю информацию о его причинах
      В идеале из исключения должно быть понятно как его исправить
    - Избегайте пустых блоков "catch"  
      Хотя бы оставьте комментарий, почему это не может быть исправлено
    - Выясните, какие исключения генерирует используемая библиотека
    - Рассмотрите вопрос о централизованном выводе информации об исключениях        
    - Стандартизуйте использование исключений в вашем проекте
      Способы:
      1 Создание базового класса для всех исключений
      2 Определите конкретные случаи, когда код может использовать try-catch локально
      3 Определите случаи когда нужно кудать исключение наружу
      4 решите будет ли использоваться централизованный генератор сообщений
    - Рассмотрите альтернативы исключениям
  |    
  № 8.5 Изоляция повреждений, вызванных ошибками
  Иззоляция повреждений, или баррикада, - это стратегия, сходная с тем как
    изолируют отсеки в трюме корабля
  Один из способов изоляции в целях защитного программирования состоит в разработке
    набора интерфейсов в качестве оболочки для безопасных частей кода
  Пример:
    ----------------  /                           \   --------------
    | Графический  |  \     ---------------       /   | Внутренний |
    | интерфейс    |  /     | Проверочный |       \   | Класс 1    |
    | пользователя |  \     | класс 1     |       /   --------------
    ----------------  /     ---------------       \         .
           .          \           .               /         .
           .          /           .               \         .
           .          \           .               /         . 
    ----------------  /     ---------------       \   --------------
    | Внешние      |  \     | Проверочный |       /   | Внутренний |
    | Файлы        |  /     | класс N     |       \   | Класс N    |
    ----------------  \     ---------------       /   -------------- 
    Выделение части кода для работы с непроверенными данными, так другая
    часть программы будет свободна от проверок
  (*) Такойже пожход можно применить на уровне класса, когда публичные методы 
      имеют проверки, а внутреннии уже нет       
  Удачная аналогия это аперационная, данные перед попаданием туда стериализуются и
    все, что находится в операционной считается безопасным, так как прошло проверку 
  - Преобразовывайте входные данные к нужному типу в момент ввода
    Сохранение данных в неопределенной форме сильно усложняет программу
  - Связь между барикадами и утверждениями
    Применение баррикад делает отчетливым различие между утверждениями 
      и обработкой ошибок
    Методы внцтри баррикад, должны использовать утверждения, так как поидее
    там будут проверенные данные и утверждения никогда не должны сработать,
    а снаружи исключения и их надо обрабатывать 
  - использование баррикард - это архитектурное решение
  |    
  № 8.6 Отладочные средства
  - Не применяйте ограничения промышленной версии к отладочной версии автоматически
    Промышленая версия должна работать быстро, а отладочная может позволить
      работать медленно.
    Промышленная версия должна быть экономна к ресурсам, отладочная нет
    Отладочная версия может предоставлять дополнительные возможности
  - Внедрите поддержку отладки как можно раньше
  - Используйте наступательное программирование
    Суть: Исключительные случаи должны обрабатываться так, чтобы во время 
      разработки они были очевидны, а в промышленном коде — позволяли продолжить работу
    Допустим есть "case" с 5 вариантами а по дефолту пишем в лог "Что-то не так!"    
    Вот приемы наступательного программирования:
      - Сделайте проблему достаточно мучительной, чтобы ее исправили. 
      - Заполняйте любую выделенную память, чтобы можно было обнаружить ошибки
          выделения памяти.
      - Заполняйте все файлы и потоки, чтобы выявить ошибки файловых форматов.
      - Настройте программу на отправку вам журналов ошибок по электронной почте
  - Запланируйте удаление отладочных средств
    - Для контроля версий и сборки программы используйте инструменты ant и make
      Система контроля версии - git
      Ant средство сборки, сейчас актуален maven, gradle
    - Используйте встроенный препроцессор
      Для Java не актуально
  |    
  № 8.7 Доля защитного программирования в промышленной версии
  - Оставьте код, которые проверяет существенные ошибки
  - Удалите код, проверяющий незначительные ошибки
  - Удалите код, приводящий к прекращению работы программы
    Почти всегда надо дать пользователю сохранить свои изменения перед падением
  - Оставьте код, который позволяет аккуратно завершить работу программы
  - Регистрируйте ошибки для отдела технической поддержки
  - Убедитесь, что оставленные сообщения об ошибках дружелюбны
  |    
  № 8.8 Защита от защитного программирования
  Избыток защитного программирования сам по себе создает проблемы
  Подумайте, где надо защищаться, и соответственно расставьте приоритеты 
    защитного программирования


9) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 9 ] Процесс программирования с псевдокодом
  |    
  № 9.1 Этапы создания классов и методов
  К конструированию классов можно подходить по#разному, но обычно это 
    итеративный процесс создания общей структуры класса, создание списка
    его методов, их конструирование и проверка класса как единого целого.

                              Начало
                                |
                               (.)
                       -------------------
                       | Создание        |
              |------->| Общей структуры |-------|
              |        | класса          |       |  
              |        -------------------       |   
              |                     ^            | 
              |                     |           (.) 
       -------------------          |   -------------------
       | Конструирование |          |---| Конструирование |
       | процедур        |<-------------| процедур        |
       | класса          |------------->| класса          |
       -------------------              -------------------
                |
                |
                |
                 ----> Завершение
  Этапы создания классов
    - Создание общей структуры класса 
      Определить ф-ии класса
      Определить будет ли он наследоваться
      Определить точный уровень абстракции
    - Конструирование всех методов класса
      Определив основные ф-ии надо переходить к конструированию методов
    - Оценка и тестирование всего класса
      В момент, когда класс становиться работоспособным, его надо протестировать
  Этапы построения метода
          
               Начало
                 |
                (.)
         -------------------              -------------------
         | Проектирование  |<-------------| Проверка        |
         | метода          |              | структуры       |
         |                 |------------->|                 |  
         -------------------              -------------------
             (.)                                 |
              |        При необходимости         |
              |            повторить             |
              |                                 (.) 
         -------------------              -------------------
         | Пересмотр       |<-------------| Кодирование     |
         | и тестирование  |              | метода          |
         | кода            |------------->|                 |
         -------------------              -------------------
                |
                |
                |
                 ----> Завершение
    Есть много подходов, но любимый подход автора, это начинать с псевдокода
  |    
  № 9.2 Псевдокод для профи
    - Применяйте формулировки, в точности описывающие отдельные действия
    - Избегайте синтаксических элементов языков программирования
    - Пишите псевдокод на уровне намерений
    - Пишите псевдокод на очень низком уровне с деталями
  (*) Пример хорошего псевдокода:
  Отслеживать текущее число используемых ресурсов
  Если другой ресурс доступен
    Выделить структуру для диалогового окна
    Если структура для диалогового окна может быть выделена
      Учесть, что используется еще один ресурс
      Инициализировать ресурс
      Хранить номер ресурса в вызывающей программе
    Конец «если»
  Конец «если»
  Вернуть true, если новый ресурс был создан; иначе вернуть false    
  (!) Выгоды от написания псевдокода в таком стиле:
    - Псевдокод упрощает пересмотр конструкции
    - Псевдокод поддерживает идею итеративного усовершенствования.
    - Псевдокод упрощает внесение изменений
      Одна из основ успеха отловить ошибку как можно раньше
  |    
  № 9.3 Конструирование методов с использованием ППП
  Пункты:
    1 проектирование метода
    2 кодирование метода
    3 проверка кода
    4 наведение глянца
    5 повторение предыдущих шагов при необходимости
  Проектирование метода
    Определив состав методов, начинаем их проектировать
    Как пример возьмем метод "ReportErrorMessage()" принимающий код ошибки и
      выводящий сообщение, соответствующие ошибки или в консоль или в файл
    - Проверка предварительных условий
      Убедитесь, что функции метода четко определены и соответствуют общим 
      проектным решениям.
    - Определите задачу, решаемую методом
      - задачу, решаемою методом, чтобы перейти к решению
      - информацию, скрываеммую методом
      - входные и выходные данные
      - предусловия,которые гарантированно должны соблюдаться
          до вызова метода
      - Постусловия, которые гарантированно должны соблюдаться, прежде чем
          метод вернет управление
      (*) для нашиго метода-примера получаем:
        1 метод скрывает текст сообщения и текущий метод обработки 
          (интерактивный или командной строки)
        2 выполнение каких либо предусловий не требуется
        3 входными данными является код ошибки
        4 выходные данные двух видов: сообщение об ошибке и статус, возвращаемый
          "ReportErrorMessage()" вызывающей программе
        5 возвращаемый статус должен принимать одно из двух значений: 
          Success или Failure
    - Название метода
      Хорошее наввание - признак высокого стиля программирования
      Если трудно подобрать имя это сигнал, что мы не понимаем что метод делает
      (*) для нашиго метода-примера получаем: 
        "ReportErrorMessage()" - хорошее имя
    - Решите, как тестировать метод
      В процессе написания думайте как будете тестировать
    - Исследуйте функциональность, предоставляемую стандартными библиотеками
      Основное правило улучшить качество кода это использовать библиотеки
    - Продумайте обработку ошибок
      Подумайте обо всем плохом, что может случиться с вашим методом
      Есть много подходов обработки ошибок, надо определиться и использовать
    - Думайте об эффективности 
      Когда-то эффективность это скорость, а когда то память, а иногда что-то третье 
      (*) надо убедиться что интерфейс получается максимально абстрактным,
          чтобы потом можно было бы улучшить реализачию
      Не трать время на методы, пока можно менять верхнеуровневый дизайн     
    - Исследуйте алгоритмы и типы данных
      Ищем в стандартной библиотеке языка, есл нет, то реализуем
    - Пишите псевдокод
      (*) для нашиго метода-примера получаем: 
    [  
      Установить статус по умолчанию в “сбой”.
      Найти сообщение, соответствующее коду ошибки.
        Если код ошибки корректен
          Если работа в интерактивном режиме, вывести сообщение
          и указать успешный статус.
       
          Если работа в режиме командной строки, запротоколировать
          сообщение об ошибке и указать успешный статус.
      Если код ошибки некорректен, информировать пользователя
      об обнаружении внутренней ошибки.
      
      Вернуть статус
    ]
    - Продумайте применение данных
      Надо продумать основные фрагменты данных до построения логики метода
    - Проверьте псевдокод
      Попробуйте обьяснить логику метода, убедитесь, что все сходится
    - Опишите несколько идей псевдокодом и выберите лучшую (пройдите по циклу)
      Пройдитесь по псевдокоду несколько раз, пока реализация не покажется понятной
  Кодирование метода
    
                   Начните с псевдокода
                           |
                          (.)
             ------------------------------
             | Напишите обьявление метода |
       |---->|                            |
       |     |                            |  
       |     ------------------------------ 
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Напишите первый и последний операторы, |
       |     | а псевдокод превратите в комментарии   |
       |---->| верхнего уровня                        | 
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Добавьте код после каждого комментария |
       |     |                                        |
       |---->|                                        |
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Проверьте код                          |
       |     |                                        |
       |---->|                                        |
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |     | Исправьте неточности                   |
       |     |                                        |
       |     |                                        |
       |     ------------------------------------------
       |           |      |
       |           |      |
       |------------      |
                          ---> Завершение
    - Обьявление метода
    - Напишите код под каждым комментарием
    - Проверьте, не нужна ли дальнейшая декомпозиция кода
      Если кода получается много, то вынести логику в еще один метод
  Проверка кода
    Третий шаг после проектирования и реализации - его проверка
    Сейчас надо проверить метод на ошибки, прежде чем идти дальше
    Умозрительно проверьте ошибки в методе
      Мысленно выполните все ветви метода 
    Компиляция метода
      1 Установите наивысший уровень предупреждений компилятора.
      2 Применяйте проверяющие средства (линтеры, анализаторы)
      3 Выясните причину всех сообщений об ошибках и предупреждений.
    Пройдите по коду отладчиком
    Протестируйте код
    Удалити ошибки из метода
  Наведение глянца
    1 Проверьте интерфейс метода
      Убедитесь, что применяются все входные и выходные данные
    2 Проверьте общее качество конструкции
      Убедитесь, что метод выполняет единственную задачу и делает это хорошо
      Имеем слабое сопряжение с другими методами
      Имет учитывает методику защитного программирования (барьеры/проверки)
    3 Проверьте переменные метода
      Корректность наименования, неиспользуемые обьекты, необьявленные переменные
    4 Проверьте логику метода
    5 Проверьте форматирование метода
    6 Проверьте документирование метода
    7 Удалите лишнии комментарии    
  Повторите нужное число раз
    ПО — итеративный процесс, повторите весь процесс, пока не выйдет что-то орошее
  |    
  № 9.4 Альтернативы ППП
  Для меня ППП — идеальная методика создания классов и методов. 
  Другие подходы:
    - Разработка с изначальными тестами
    - Рефакторинг
    - Проектирование по контракту
    - Бессистемное программирование
      Лепим как получиться, если вы так делаете, то используйте ППП


10)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 10 ] Общие принципы использования переменных
  |    
  № 10.1 Что вы знаете о данных?
    тут штуки
  |    
  № 10.2 Грамотное обьявление переменных













 perfect-code-book add new part of summery

  стр 253 в chrome















[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
