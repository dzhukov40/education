---
Ресурсы:

// оф сайт
- [ https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D0%BA%D0%BE%D0%BD%D0%BD%D0%B5%D0%BB%D0%BB,_%D0%A1%D1%82%D0%B8%D0%B2 ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ Совершенный код ] это одна из лучших книг по программированию.




1) [ Часть 1 / Глава 1 ] Добро пожаловать в мир конструирования ПО! 
  - вводная информация
  - Этапы создания ПО:
    1 Выработка требований
    2 Проектирование архитектуры
    3 Конструирование

2) [ Часть 1 / Глава 2 ] Метафоры, позволяющие лучше понять разработку ПО 
  - Инкрементальный подход к разработке это лучшее, что есть на сегодня
  - Подходящая аналогия к разработке ПО это строительство (дома, небоскреба, будки для собаки)
  - необходимо понимать что мы строим, для этого используется планирование
  - при разработке ПО не нужно писать велосипеды, если есть написанные штуки, надо использовать

3) [ Часть 1 / Глава 3 ] Семь раз отмерь, один раз отрежь: предварительные условия
  - перед началом создания проекта, надо провести подготовку
    и проверить все ли готово для реализации намеченного плана.
  - мы должны потратить много времени на планирование!
  - необходимо выработать как можно более широкий набор требований к продукту.
  - Первое что мы должны понять, это проблема которую мы хотим решить.
  - Определение проблемы - это формирование сути проблемы без намеков на решение.
  - Определение проблемы - это фундамент всего процесса программирования
  -       ::
         :  :         - Будущие решения
        :    :        - Тестирование системы 
       :      :       - Конструирование
      :        :      - Проектирование архитектуры
     :          :     - Выработка требований
    :            :    - Определение проблемы
   :::::::::::::::: 
  - Проблема должна быть описана на языке пользователя, 
    обычно описание не содержит технических терминов.
  - (*) к проектированию архитектуры переходим после проработки требований !
  - Архитектура — это высокоуровневая часть проекта приложения, 
    каркас, состоящий из деталей проекта.
  - Архитектура должна четко определять ответственность каждого компонента.
  - Компонент должен иметь одну область ответственности и как можно меньше знать 
    об областях ответственности других компонентов.
  - Архитектура должна быть модульной, чтобы можно было заменять модули.
  - Архитектура должна учитывать ресурсы памяти, ЦПУ, коннектов к базе и тд.
  - Архитектура должна определять подход к безопасности как на уровне проекта
    приложения, так и на уровне кода.
  - Производительность: в требованиях следует определить показатели производительности,
    а в архитектуре описать обьяснение, что такая архитектура сможет реализовать требования
  - Масштабируемость: Архитектура должна описывать, как система будет реагировать на рост
    числа пользователей, серверов, сетевых узлов, записей в БД, транзакций и т.д
  - Интернационализация/локализация: в архитектуре должно быть описано как реализуется это.
  - Обработка ошибок: стратегия обработки ошибок должна быть выражена в архитектуре
  - Отказоустойчивость: необходимо описать сценарии ошибок и отказов, которые не должны 
    приводить к потере работоспособности.
  - Возможность реализации архитектуры: нужно быть увереными, что архитектура реализуема.
    Невозможность реализации какого-то компонента может сделать проект неработоспособным.
    (*) как решение это написание прототипов таких можулей или дополнительное исследование.
  - Стратегия изменений: Архитектура должна показывать, что возможные улучшения
    рассматривались и что реализация наиболее вероятных улучшений окажется наиболее простой. 

3) [ Часть 1 / Глава 4 ] Основные решения, которые приходится принимать при конструировании
  - Необходимо ввести стиль использования выбранного языка программирования.
  - Большинство важных принципов программирования не от конкретных языков, 
    а от способа их использовать.

4) [ Часть 2 / Глава 5 ] Высококачественный код
  - Проектирование ПО - под этим обычно понимают разработку или изобретение схемы
    преобразования спецификации приложения в готовое приложение.
  - Проектирование - "грязная" проблема. Прикол в том что такую проблему можно
    определить только через полное или частичное решение.
    (*) получается надо один раз решить проблему, чтобы получить ее ясное представление,
    а потом решить еще раз для создания работоспособного решения.
  - Проектирование это постоянный анализ конкурирующих характеристик проекта и достижение
    баланса между ними.
  - Проектирование подразумевает ограничение возможностей.
  - Проектирование не имеет единствено верного решения, 
    при решении разными разработчиками, получим несколько разных, но решающих проблему програм
  - Проектирование - процесс из проб и ошибок, постепенный процесс
  |
  № 5.2 Основные концепции проектирования:
    - Управление сложностью - самый важный технический аспект разработки ПО.
      Необходимо организовать код так, чтобы можно было безопасно работать с частями.
      Несколько не сложных фрагментов понять проще, чем один сложный.
      (*) Необходимо свести к минимому обьем существенной сложности, 
      с которым придется работать в каждый конкретный момент времени.
      (**) Необходимо сдерживать необязательный рост несущественной сложности.
      (!) все принцыпы програмирования ведут к уменьшению частичной сложности кода.
    - Желательные характеристики проекта
      - @ Минимальная сложность
        Надо создавать простые и понятные проекты
      - @ Простота сопровождения
        При проектировании нельзя забывать о людях из сопровождения
      - @ Слабоя сопряжение
        Сведение к минимому числа соединений между разными частями программы
      - @ Расширяемось
        Внесение наиболее вероятных изменений должно требовать наименьших усилий.
      - @ Возможность повторного использования
        Признах хорошего проектирования программы это когда код легко переиспользовать.
      - @ Высокий коэффициент обьединения по входу
        Хорошо когда созданный нами клас много где используется
      - @ Низкий или средний коэффициент разветвления по выходу
        Плохо когда один класс для своей работы требует ссылки на множество классов
      - @ Портируемость
        Проектировать надо так, чтобы систему можно было легко аадптировать к другой среде.
      - @ Минимальная, но полная функциональность
        Меньше кода - меньше проблем
      - @ Стратификация
        Необходимо разрабатывать систему, чтобы можно разделить по уровням декомпозиции
        Если есть старый или плохой код лучше сделать клас мост, чтобы изолировать его
      - @ Соответствие стандартным методикам
        Необходимо применять стандартные и популяные подходы
  - Уровни проектирования
    - "Уровень 1" Программная система
      Этому уровню соответствует вся система.
    - "Уровень 2" Разделение системы на подсистемы или пакеты
      Результат проектирования на этом уровне - определение основных подсистем
      Особенно важно определить правила взаимодействия и ограничивать эти связи
      Архитектура системы должна быть такой, чтобы замена подсистемы была максимально простой
      часто используемые варианты подсистем:
      - @ Подсистема пользовательского интерфейса
        изоляция GUI органична и удобна
      - @ Подсистема доступа к БД
        изоряция общения с БД отличная идея
      - @ Подсистема изоляции зависимостей от ОС
        Так как потом велик шанс задачи адоптации под другую ОС
    - "Уровень 3" разделение подсистем на классы
      Это уже уровень, где мы определяем необходимый набор классов   
      На этом уровне должно быть понятно как реализовать систему на уровне классов
    - "Уровень 4" разделение классов на методы
      Надо определить методы классов, можно этот уровень комбинировать с предыдущем
    - "Уровень 5" проектирование методов
      На этом уровне детально проектируется функциональность методов
      Например пишется псевдогод
  |  
  № 5.3 Компоненты проектирования: эвристические принципы
    Проектирование не является детерминированным
    - @ "1" Определите обьекты реального мира
      при проектировании определяем:
        - объекты и их атрибуты (методы и данные)
          (*) однозначное соответствие обьектов реального мира и программы
          подходит для начала, но обычно это не лучшая идея
        - действия, которые могут быть выполнены над каждым объектом
          (*) например обьект сотрудник может поддерживать операцию смены имени
        - действия, которые каждый объект может выполнять над другими объектами
          (*) какой обьект может включать другой обьект,
          какой обьект может выполнять действия над другим обьектом
        - части каждого объекта, видимые другим объектам
        - открытый интерфейс каждого объекта
          (*) для каждого обьекта надо определить формальный синтаксический интерфейс
    - @ "2" Определите согласованные абстракции
      Создание абстракций позволяет работать с обьектами не вдаваясь в подробности
    - @ "3" Инкапсулируйте детали реализации
      Инкопсуляция помогает управлять сложностью блокируя доступ к ней
    - @ "4" Используйте наследование, если оно упрощает проектирование
      При правильном использовании принесет большую пользу
   - @ "5" Скрывайте секреты (к вопросу о сокрытии информации)
     Это мощный принцып, который подчеркивает необходимость сокрытия сложности
     Секретом может быть источник вероятных изменений, формат файла, алгоритм и т.д
     Класс может использовать несколько типов данных не раскрывая сведений о них
     Интерфейс класса должен сообзать как можно меньше о внутренней работе класса
     Класс должен быть похож на айсберг
   - @ "6" Определите области вероятных изменений
     Находим элементы, изменение которых кажется вероятным
     Отделяем эти элименты, чтобы при изменении как можно меньше менять
     Спроектировать интервейс который будет не зависеть от изменений
     - Чаще всего меняется:
       - Бизнес правила
       - Зависимости от оборудования
       - Ввод-вывод
       - Нестандартные возможности языка
       - Сложные аспекты проектирования и конструирования
       - Переменные статуса
       - Размеры структур данных
   - @ "7" Поддерживайте сопряжение слабым
     Сопряжение характерезует силу связи класса или метода с другими классами или методами
     Стараться создавать модули, слабо зависящие от других
     Критерии оценки сопряжения:
     - Обьем
       Обьем связи характерезует число связей, чем меньше тем лучше
       Метод, принимающий один параметр, слабее сопряжен чем метод с двумя параметрами
       Класс предоставляющий два публичных метода меньше сопряжен чем класс с 5 методами
     - Видимость
       Видимостью называют заметность связи между двумя модулями
       Необходимо делать связи как можно более очевидными и заметными
     - Гибкость
       Гибкость характерезуется легкостью изменения связи между модулями
       Идеальная связь должна быть как можно гибче
       Чем проще вызвать модуль из других модулей, тем лучше
     Выводы сопряжения:
     - Простое сопряжение посредством данных-параметров
       Означает, что между модулями передаются только элементарные типы данных
       (*) ВЫВОД: нормален и приемлен
     - Простое сопряжение посредством обьекта
       Означает, что модуль создает экземпляр данного обьекта
       (*) ВЫВОД: нормален и приемлен
     - Сопряжение посредством обьекта-параметра
       Два модуля сопряжены между собой обьектом-параметром
       Обьект-1 требует чтобы Обьект-2 передал ему Обьект-3
       (*) ВЫВОД: Это сопряжение уже жесче и менее желательно
     - Семантическое сопряжение
       Это самы коварный тип сопряжения
       Один модуль использует некоторые семантические знания о внутренней работе этого модуля
       (*) ВЫВОД: Опасно именть такие связи, надо избегать
     Надо стримиться к малой связанности, чтобы независимо работать над разными кусочками
   - @ "8" Старайтесь использовать популярные шаблоны проектирования
     Есть проблемы, требующие новых решений, но большинство уже решалось
     Шаблоны снижают сложность, предоставляя готовые абстракции
     Шаблоны снижают число ошибок, стандартезируя детали популярных решений
     Использование шаблонов, похоже на использование стандартной библиотеки
     Шаблоны имеют эврестическую ценность, указывая на возможные варианты проектирования
     Код разработтаный на популярном шаблоне, будет понятнее, чем код, разработтаный без
     Шаблоны упрощают взаимодействие между разработчиками
   - @ "9" Другие эвристические принципы
     1 Стремитесь к максимальной связности, тоесть насколько сфокусирован клас или модуль
       Связанность характерезует насколько методы и части класса соответствуют цели класса
     2 Формируйте иерархии
       Иерархия это многоуровневая структура представления информации
       Иерархия уже тысячи лет основной механизм управления сложностью
       Иерархия не устраняет деталея - она просто выталкивает их на другой уровень
     3 Формализуйте контракты классов
       Интерфейс каждого класса это его контракт взаимодействия с другими классами
     4 Грамотно назначайте сферы ответственности
     5 Проектируйте систему для тестирования
       Проектирование длятестирования часто приводит к разработке 
       более формализованных интерфейсов классов, что обычно выгодно
     6 Избегайте неудач
       Необходимо обдумывать сложные куйсы, которые могут привести к аварии
     7 Тщательно выбирайте время связывания
       Временем связывания называют, когда переменной присваивается конкретное значение
       Раннее связывание упрощает код, но снижает его Гибкость
     8 Создайте центральные точки управления
       Звучит как конфиг (application.yaml)
     9 Подумайте об использовании грубой силы
       Работающее решение с грубой силой лучше не работающего
     10 Рисуйте диаграммы
       Это мощный эвристический инструмент, лучше один раз увидеть, чем 100 раз услышать
     11 Поддерживайте модульность проекта системы
       Каждый метод или класс должен быть похож на "черный ящик"
  |
  № 5.4 Методики проектирования



       

  








  add new part of summery
  
  стр 129 в chrome















[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
