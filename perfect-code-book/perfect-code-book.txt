---
Ресурсы:

// оф сайт
- [ https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D0%BA%D0%BE%D0%BD%D0%BD%D0%B5%D0%BB%D0%BB,_%D0%A1%D1%82%D0%B8%D0%B2 ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ Совершенный код ] это одна из лучших книг по программированию.



1) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 1 ] Добро пожаловать в мир конструирования ПО! 
  - вводная информация
  - Этапы создания ПО:
    1 Выработка требований
    2 Проектирование архитектуры
    3 Конструирование


2) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 2 ] Метафоры, позволяющие лучше понять разработку ПО 
  - Инкрементальный подход к разработке это лучшее, что есть на сегодня
  - Подходящая аналогия к разработке ПО это строительство (дома, небоскреба, будки для собаки)
  - необходимо понимать что мы строим, для этого используется планирование
  - при разработке ПО не нужно писать велосипеды, если есть написанные штуки, надо использовать


3) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 3 ] Семь раз отмерь, один раз отрежь: предварительные условия
  - перед началом создания проекта, надо провести подготовку
    и проверить все ли готово для реализации намеченного плана.
  - мы должны потратить много времени на планирование!
  - необходимо выработать как можно более широкий набор требований к продукту.
  - Первое что мы должны понять, это проблема которую мы хотим решить.
  - Определение проблемы - это формирование сути проблемы без намеков на решение.
  - Определение проблемы - это фундамент всего процесса программирования
  -       ::
         :  :         - Будущие решения
        :    :        - Тестирование системы 
       :      :       - Конструирование
      :        :      - Проектирование архитектуры
     :          :     - Выработка требований
    :            :    - Определение проблемы
   :::::::::::::::: 
  - Проблема должна быть описана на языке пользователя, 
    обычно описание не содержит технических терминов.
  - (*) к проектированию архитектуры переходим после проработки требований !
  - Архитектура — это высокоуровневая часть проекта приложения, 
    каркас, состоящий из деталей проекта.
  - Архитектура должна четко определять ответственность каждого компонента.
  - Компонент должен иметь одну область ответственности и как можно меньше знать 
    об областях ответственности других компонентов.
  - Архитектура должна быть модульной, чтобы можно было заменять модули.
  - Архитектура должна учитывать ресурсы памяти, ЦПУ, коннектов к базе и тд.
  - Архитектура должна определять подход к безопасности как на уровне проекта
    приложения, так и на уровне кода.
  - Производительность: в требованиях следует определить показатели производительности,
    а в архитектуре описать обьяснение, что такая архитектура сможет реализовать требования
  - Масштабируемость: Архитектура должна описывать, как система будет реагировать на рост
    числа пользователей, серверов, сетевых узлов, записей в БД, транзакций и т.д
  - Интернационализация/локализация: в архитектуре должно быть описано как реализуется это.
  - Обработка ошибок: стратегия обработки ошибок должна быть выражена в архитектуре
  - Отказоустойчивость: необходимо описать сценарии ошибок и отказов, которые не должны 
    приводить к потере работоспособности.
  - Возможность реализации архитектуры: нужно быть увереными, что архитектура реализуема.
    Невозможность реализации какого-то компонента может сделать проект неработоспособным.
    (*) как решение это написание прототипов таких можулей или дополнительное исследование.
  - Стратегия изменений: Архитектура должна показывать, что возможные улучшения
    рассматривались и что реализация наиболее вероятных улучшений окажется наиболее простой. 


4) [ Часть 1 ] Основы разработки ПО
   [ Часть 1 / Глава 4 ] Основные решения, которые приходится принимать при конструировании
  - Необходимо ввести стиль использования выбранного языка программирования.
  - Большинство важных принципов программирования не от конкретных языков, 
    а от способа их использовать.


5) [ Часть 2 ] Высококачественный код
5) [ Часть 2 / Глава 5 ] Высококачественный код
  - Проектирование ПО - под этим обычно понимают разработку или изобретение схемы
    преобразования спецификации приложения в готовое приложение.
  - Проектирование - "грязная" проблема. Прикол в том что такую проблему можно
    определить только через полное или частичное решение.
    (*) получается надо один раз решить проблему, чтобы получить ее ясное представление,
    а потом решить еще раз для создания работоспособного решения.
  - Проектирование это постоянный анализ конкурирующих характеристик проекта и достижение
    баланса между ними.
  - Проектирование подразумевает ограничение возможностей.
  - Проектирование не имеет единствено верного решения, 
    при решении разными разработчиками, получим несколько разных, но решающих проблему програм
  - Проектирование - процесс из проб и ошибок, постепенный процесс
  |
  № 5.2 Основные концепции проектирования:
    - Управление сложностью - самый важный технический аспект разработки ПО.
      Необходимо организовать код так, чтобы можно было безопасно работать с частями.
      Несколько не сложных фрагментов понять проще, чем один сложный.
      (*) Необходимо свести к минимому обьем существенной сложности, 
      с которым придется работать в каждый конкретный момент времени.
      (**) Необходимо сдерживать необязательный рост несущественной сложности.
      (!) все принцыпы програмирования ведут к уменьшению частичной сложности кода.
    - Желательные характеристики проекта
      - @ Минимальная сложность
        Надо создавать простые и понятные проекты
      - @ Простота сопровождения
        При проектировании нельзя забывать о людях из сопровождения
      - @ Слабоя сопряжение
        Сведение к минимому числа соединений между разными частями программы
      - @ Расширяемось
        Внесение наиболее вероятных изменений должно требовать наименьших усилий.
      - @ Возможность повторного использования
        Признах хорошего проектирования программы это когда код легко переиспользовать.
      - @ Высокий коэффициент обьединения по входу
        Хорошо когда созданный нами клас много где используется
      - @ Низкий или средний коэффициент разветвления по выходу
        Плохо когда один класс для своей работы требует ссылки на множество классов
      - @ Портируемость
        Проектировать надо так, чтобы систему можно было легко аадптировать к другой среде.
      - @ Минимальная, но полная функциональность
        Меньше кода - меньше проблем
      - @ Стратификация
        Необходимо разрабатывать систему, чтобы можно разделить по уровням декомпозиции
        Если есть старый или плохой код лучше сделать клас мост, чтобы изолировать его
      - @ Соответствие стандартным методикам
        Необходимо применять стандартные и популяные подходы
  - Уровни проектирования
    - "Уровень 1" Программная система
      Этому уровню соответствует вся система.
    - "Уровень 2" Разделение системы на подсистемы или пакеты
      Результат проектирования на этом уровне - определение основных подсистем
      Особенно важно определить правила взаимодействия и ограничивать эти связи
      Архитектура системы должна быть такой, чтобы замена подсистемы была максимально простой
      часто используемые варианты подсистем:
      - @ Подсистема пользовательского интерфейса
        изоляция GUI органична и удобна
      - @ Подсистема доступа к БД
        изоряция общения с БД отличная идея
      - @ Подсистема изоляции зависимостей от ОС
        Так как потом велик шанс задачи адоптации под другую ОС
    - "Уровень 3" разделение подсистем на классы
      Это уже уровень, где мы определяем необходимый набор классов   
      На этом уровне должно быть понятно как реализовать систему на уровне классов
    - "Уровень 4" разделение классов на методы
      Надо определить методы классов, можно этот уровень комбинировать с предыдущем
    - "Уровень 5" проектирование методов
      На этом уровне детально проектируется функциональность методов
      Например пишется псевдогод
  |  
  № 5.3 Компоненты проектирования: эвристические принципы
    Проектирование не является детерминированным
    - @ "1" Определите обьекты реального мира
      при проектировании определяем:
        - объекты и их атрибуты (методы и данные)
          (*) однозначное соответствие обьектов реального мира и программы
          подходит для начала, но обычно это не лучшая идея
        - действия, которые могут быть выполнены над каждым объектом
          (*) например обьект сотрудник может поддерживать операцию смены имени
        - действия, которые каждый объект может выполнять над другими объектами
          (*) какой обьект может включать другой обьект,
          какой обьект может выполнять действия над другим обьектом
        - части каждого объекта, видимые другим объектам
        - открытый интерфейс каждого объекта
          (*) для каждого обьекта надо определить формальный синтаксический интерфейс
    - @ "2" Определите согласованные абстракции
      Создание абстракций позволяет работать с обьектами не вдаваясь в подробности
    - @ "3" Инкапсулируйте детали реализации
      Инкопсуляция помогает управлять сложностью блокируя доступ к ней
    - @ "4" Используйте наследование, если оно упрощает проектирование
      При правильном использовании принесет большую пользу
   - @ "5" Скрывайте секреты (к вопросу о сокрытии информации)
     Это мощный принцып, который подчеркивает необходимость сокрытия сложности
     Секретом может быть источник вероятных изменений, формат файла, алгоритм и т.д
     Класс может использовать несколько типов данных не раскрывая сведений о них
     Интерфейс класса должен сообзать как можно меньше о внутренней работе класса
     Класс должен быть похож на айсберг
   - @ "6" Определите области вероятных изменений
     Находим элементы, изменение которых кажется вероятным
     Отделяем эти элименты, чтобы при изменении как можно меньше менять
     Спроектировать интервейс который будет не зависеть от изменений
     - Чаще всего меняется:
       - Бизнес правила
       - Зависимости от оборудования
       - Ввод-вывод
       - Нестандартные возможности языка
       - Сложные аспекты проектирования и конструирования
       - Переменные статуса
       - Размеры структур данных
   - @ "7" Поддерживайте сопряжение слабым
     Сопряжение характерезует силу связи класса или метода с другими классами или методами
     Стараться создавать модули, слабо зависящие от других
     Критерии оценки сопряжения:
     - Обьем
       Обьем связи характерезует число связей, чем меньше тем лучше
       Метод, принимающий один параметр, слабее сопряжен чем метод с двумя параметрами
       Класс предоставляющий два публичных метода меньше сопряжен чем класс с 5 методами
     - Видимость
       Видимостью называют заметность связи между двумя модулями
       Необходимо делать связи как можно более очевидными и заметными
     - Гибкость
       Гибкость характерезуется легкостью изменения связи между модулями
       Идеальная связь должна быть как можно гибче
       Чем проще вызвать модуль из других модулей, тем лучше
     Выводы сопряжения:
     - Простое сопряжение посредством данных-параметров
       Означает, что между модулями передаются только элементарные типы данных
       (*) ВЫВОД: нормален и приемлен
     - Простое сопряжение посредством обьекта
       Означает, что модуль создает экземпляр данного обьекта
       (*) ВЫВОД: нормален и приемлен
     - Сопряжение посредством обьекта-параметра
       Два модуля сопряжены между собой обьектом-параметром
       Обьект-1 требует чтобы Обьект-2 передал ему Обьект-3
       (*) ВЫВОД: Это сопряжение уже жесче и менее желательно
     - Семантическое сопряжение
       Это самы коварный тип сопряжения
       Один модуль использует некоторые семантические знания о внутренней работе этого модуля
       (*) ВЫВОД: Опасно именть такие связи, надо избегать
     Надо стримиться к малой связанности, чтобы независимо работать над разными кусочками
   - @ "8" Старайтесь использовать популярные шаблоны проектирования
     Есть проблемы, требующие новых решений, но большинство уже решалось
     Шаблоны снижают сложность, предоставляя готовые абстракции
     Шаблоны снижают число ошибок, стандартезируя детали популярных решений
     Использование шаблонов, похоже на использование стандартной библиотеки
     Шаблоны имеют эврестическую ценность, указывая на возможные варианты проектирования
     Код разработтаный на популярном шаблоне, будет понятнее, чем код, разработтаный без
     Шаблоны упрощают взаимодействие между разработчиками
   - @ "9" Другие эвристические принципы
     1 Стремитесь к максимальной связности, тоесть насколько сфокусирован клас или модуль
       Связанность характерезует насколько методы и части класса соответствуют цели класса
     2 Формируйте иерархии
       Иерархия это многоуровневая структура представления информации
       Иерархия уже тысячи лет основной механизм управления сложностью
       Иерархия не устраняет деталея - она просто выталкивает их на другой уровень
     3 Формализуйте контракты классов
       Интерфейс каждого класса это его контракт взаимодействия с другими классами
     4 Грамотно назначайте сферы ответственности
     5 Проектируйте систему для тестирования
       Проектирование длятестирования часто приводит к разработке 
       более формализованных интерфейсов классов, что обычно выгодно
     6 Избегайте неудач
       Необходимо обдумывать сложные куйсы, которые могут привести к аварии
     7 Тщательно выбирайте время связывания
       Временем связывания называют, когда переменной присваивается конкретное значение
       Раннее связывание упрощает код, но снижает его Гибкость
     8 Создайте центральные точки управления
       Звучит как конфиг (application.yaml)
     9 Подумайте об использовании грубой силы
       Работающее решение с грубой силой лучше не работающего
     10 Рисуйте диаграммы
       Это мощный эвристический инструмент, лучше один раз увидеть, чем 100 раз услышать
     11 Поддерживайте модульность проекта системы
       Каждый метод или класс должен быть похож на "черный ящик"
  |
  № 5.4 Методики проектирования
  - Используйте итерацию
    Выполнив проектирование несколько раз вы повысите качество
    Если первая попытка окажется удачной не стоит останавливаться, вторая будет лучше
  - Разделяй и властвуй
    Надо разделить программу на разные области и спроектированть их по отдельности
    Инкрементальное улучшение - мощное средство управления сложностью
  - Нисходящий и восходящий подходы к проектированию
    От общего виденья к деталям или от корневых можелей к общему виду       
    Оба подхода приемлемы
  - Эксперементальное протипирование
    Мы не можем определить проблему проектирования, пока не решите ее хоть частичное
    Прототип надо выкидывать, но почти всегда его продолжают
  - Совместное проектирование
    Две головы лучше, чем одна
    Собрание с обсуждением идей или ревью и инспекция это отлично
  - Какую степень проектирования считать достаточной
    Есть множество факторов влияющих на необходимый уровень детализации
    Факторы: уровень разработчиков, сроки, размер проекта, критичность ошибки в проекте 
    Редко встречаются проекты страдающие от чрезмерного проектирования
  - Регистрация процесса проектирования
    Сохраняйте схемы текст картинки в wiki
  |
  № 5.5 Комментарии по поводу популярных методологий
  - Проектировать все или проектировать ничего, вывод проектировать в достаточной степени


6) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 6 ] классы
  № 6.1 Основы классов: абстрактные типы данных
  АТД - абстрактный тип данных (похоже реч тут идет о структурах)
  Частая ошибка это смотреть на АТД, как на контейнер хранения разношерстных методов
  - Преимущества использования АТД
    1 Возможность сокрытия деталей реализации
    2 Ограничение области видимости
    3 Более высокая информативность интерфейса
    4 Легкость оптимизации кода
    5 Легкость проверки кода
    6 Удобочитаемость и понятность кода
    7 Ограничение области использования данных
    8 Возможность работы с сущностями реального мира, 
      а не с низкоуровневыми деталями реализации  
  |    
  № 6.2 Качественные интерфейсы классов
  Первый и самый важный шаг при создании класса, создание интерфейса класса
  - Принцыпы:
   1 Выражайте в интерфейсе класса согласованный уровень абстракции
     В идеале каждый класс должен быть реализацией только одного АТД
   2 Убедитесь, что вы понимаете, реализацией какой абстракции является класс
   3 Представляйте методы вместе с противоположным им методом
   4 Убирайте посторонюю информацию в дркгие классы
     Иногда можно заметить что в классе ряд методов работает с одной половинной
     данных, а другой набор с другой половиной, значит надо разделить класс на два
   5 По мере возможности делайте интерфейсы программными, а не семантическими
     Семантический интерфейс может включать такие соображения, 
     как «Метод А должен быть вызван перед Методом B» или «Метод А вызовет ошибку
     Семантический интерфейс надо документировать, а лучше не использовать
   6 Опасайтесь нарушения целостности интерфейса при изменении класса
     Класс мог быть хорошей абстакцией с понятным интерфейсом, но после правок 
     привратиться в монстра, поэтому изменение интерфейса очень ответственный шаг
   7 Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса
   8 Рассматривайте абстракцию и связность вместе
  Хорошая инкапсуляция
  - Принцыпы:
    1 Минимизируйте доступность классов и их членов
    2 Не делайте данные-члены открытыми
    3 Не включайте в интерфейс класса закрытые детали реализации
      Надо разделять интерфейс и реализацию
    4 Не делайте предположения о клиентах класса
    5 Избегайте использования дружественных классов
    6 Не делайте метод открытым лишь потому, что он использует только открытые методы
    7 Цените легкость чтения кода выше, чем удобство его написания
    8 Очень, очень настороженно относитесь к семантическим нарушениям инкапсуляции
      Мы можем написать свой код, зная об особенностях реализации другого кода, 
      что не допустимо, так как руководствоваться должны только публичным АПИ
      Если по апи класса не понятно, как работать с классом это плохое апи, переделываем
    9 Остерегайтесь слишком жесткого сопряжения  
      - минимизируйте доступность классов и их членов
      - избегайте дружественных классов, потому что они связаны жестко
      - делайте данные базового класса закрытыми, а не защищенными: это ослабляет 
        сопряжение производных классов с базовым
      - не включайте данные члены в открытый интерфейс класса
      - остерегайтесь семантических нарушений инкапсуляции
  |    
  № 6.3 Вопросы проектирования и реализации
  В этом разделе обсудим как реализовать внутреннее устройство классов
  - Включение (отношение "содержит")
    Один класс содержит примитивный элемент данных или другой класс
    Включение - один из главных инструментов ООП
    - Реализуйте с помощью включеия отношение "содержит"
      Например обьект "Сотрудник" может содержать "Фамилия"
    - В крайнем случае реализуйте отношение "Содержит" через закрытое наследование
      Если вам приходится это делать, обычно указывает на ошибки проектирования  
    - Насторожено относитесь к классам, содержащим более семи элементов данных-членов
      Человек может удерживать в памяти 7 +/- 2 дискретных элементов
  - Наследование (отношение "является")
    Наследование подразумевает, что один класс является более специализированным вариантом
    - Реализуйте при помощи открытого наследования отношение "является"
      Базовый класс формирует ожидания и ограничения, которым будет соответствовать
      производный класс
      (!) Если производный класс не собирается полностью придерживаться контракта,
      определенного интерфейса базового класса, наследование выполнять не стоит
    - Проектируйте и документируйте классы с учетом возможности наследования или запретить
    - Соблюдайте принцип подстановки Лисков
      1 Наследование стоит использовать, только если производный класс действительно
        "является" более специализированной версией базового класса
      2 Клиенты должны иметь возможность использования подклассов через интерфейс
        базового класса, не замечая никаких различий
      3 При соблюдении принципа подстановки Лисков наследование - сильно снижает сложность
    - Убедитесь, что вы наследуете только то, что хотите наследовать
      (*) Ели вам нужна реализация класса, но не его интерфейс, используйте Включение
    - Не "переопределяйте" непереопределяемые методы-члены
      Не используйте имена непереопределяемых методов базового класса в производных
    - Перемещайте общие интерфейсы, данные и формы поведения на как можно более
      высокий уровень иерархии наследования
    - С подозрением относитесь к классам, обьекты которых создаются в единственном
      экземпляре (singleton - исключение)
    - С подозрением относитесь к базовым классам, имеющим толко один производный класс
      Похоже кто-то проектировал наперед, это плохая практика - больше кода больше проблем
    - С подозрением относитесь к классам, которые переопределяют метод, оставляя пустым
      Это почти точно ошибка проектирования
      Это звоночек нарушении контракта базового класса
    - Избегайте многоуровневых иерархий наследования
      Большенству людей трудно удержать в голове больше 3 уровней
      Надо помнить, что наследовоние должно уменьшать дублирование и сложность  
    - Предпочитайте полиморфизм, а не крупномасштабную проверку типов
      Наличие блоков "case" почти всегда говорит об ошибке проектирования
    - Делайте все данные закрытыми, а не защищенными
    - Множественное наследование
      Наследование - мощный и довольно опасный инструмент
      Лучше не прибегать к множественному наследованию  
  - Методы-члены и данные-члены 
    - Включайте в класс как можно меньше методов
    - Блокируйте неявно сгенерированные методы и операторы, которые вам не нужны
    - Минимизируйте число разных методов, вызываемых классов
    - Избегайте опосредованных вызовов методов других классов
      «Правило Деметры (Law of Demeter)», которое гласит, что Объект A может вызывать 
      любые из собственных методов. Если он создает Объект B, он может вызывать любые 
      методы Объекта
    - Вообще минимизируйте сотрудничество класса с другими классами
      Минимизируйте число видов создаваемых обьектов
      Минимизируйте число непосредственно вызываемых методов созданных обьектов
      Минимизируйте число вызовов методов, принадлежащих обьектам, возвр другими обьектами
  - Конструкторы
    - Инициализируйте по мере возможности все данные-члены во всех конструкторах
    - Создавайте классы одиночки с помощью закрытого конструктора
    - Если сомневаетесь, выполняйте полное копирование, а не ограниченное
      Ограниченное копирование - обычно получение ссылки на обьект
  |    
  № 6.4 Разумные причины создания классов
  Причины
    - Моделирование обьектов реального мира
      Это не главная но основная причина
    - Моделирование абстрактных обьектов
      Пример такого класса "Фигура"
    - Изоляция сложности
    - Сокрытие деталей реализации
    - Ограничение влияния изменений
    - Сокрытие глобальных данных
    - Упрощение передачи параметров в методы
    - Создание центральных точек управления
    - Облегчение повторного использования кода
    - Планирование создания семейства программ   
      Рассуждения о том как может выглядеть семейство таких программ как наша, полезно   
    - Упаковка родственных операций
      Плошая практика, но лучше чем не делать этого над блуждающими методами 
    - Выполнение специфического вида рефакторинга
  Классы, которых следует избегать  
    - Избегайте создания "божественных" классов
      Универсальный всемогущий класс это беда для проекта, разбить на классы по одной цели
    - Устраняйте неревантные классы
    - Избегайте классов, имена которых напоминают глаголы
      Похоже это должен быть не класс а метод класса
  |    
  № 6.5 Аспекты, специфические для языков
  - не важно
  |    
  № 6.6 Следующий уровень: пакеты классов
  Использование классов - лучший способ достижения модульности
  Если язык не поддерживает пакеты, поддерживайте их сами


7) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 7 ] Высококачественные методы
  |    
  № 7.1 Разумные причины создания методов
  - Снижение сложности
  - Формирование понятной промежуточной абстракции
  - Предотвращение дублирования кода
  - Поддержка наследования
  - Сокрытие очередности действий
  - Сокрытие операций над указателями
  - Улучшение портируемости
  - Упрощение сложных булевых проверок
  - Повышение быстродействия
  - Для уменьшения обьема других методов
  |    
  № 7.2 Проектирование на уровне методов
  Метод должен эфективно делать одну четкую задачу
  Есть разные виды связанности
  - Функциональная связанность 
    Это самый сильный и лучший вид
    Это когда метод имеет обну функцию и выполняет ее
    Примеры  GetCustomerName(), EraseFile(), AgeFromBirthdate()
  - Последовательная связанность
    Вид связи не желателен, но приемлем
    Это плохой вид связанности, суть в том что действия в методе связаны порядком вызова
    Надо сделать из такого метода несколько отдельных методов
  - Коммуникационная связанность
    Вид связи не желателен, но приемлем
    Это когда мы используем одни и те же данные и операции не связаны другим способом
    Две операции в методе обьеденяет только то, что они обращаются к одним данным
    Такой метод надо разделять на отдельные
  - Временная связанность
    Вид связи не желателен, но приемлем
    Обьединение на основании, что все они выполняются в один интервал времени
    Пример: Startup(), Shutdown()
    Решение это не делать в методе вызов действий напрямую, а пусть читается конфиг
    и уже исходя из конфига делается набор действий
  |    
  № 7.3 Удачные имена методов
  - Описывайте все, что метод выполняет   
  - Избегайте невыразительных и неоднозначных глаголов
    Невыразительное имя означает не ясную цель метода, а это плохой метод
  - Не используйте для дифференциации имен методов исключительно номера
    Дич, нечего обсуждать
  - Не ограничивайте длину имен методов искусственными правилами
  - Для именования функции используйте описание возвращаемого значения
    Пример: customerId.Next(), printer.IsReady() и pen.CurrentColor()
  - Для именования процедуры используйте выразительный глагол, дополняя его объектом
    Формату «глагол + объект»
    Пример: document.Print(), orderInfo.Check() и monthlyRevenues.Calc().
  - Дисциплинированно используйте антонимы
    Пример популярных антонимов:
     - add/remove      increment/decrement   open/close
     - begin/end       insert/delete         show/hide
     - create/destroy  lock/unlock           source/target
     - first/last      min/max               start/stop
     - get/put         next/previous         up/down
     - get/set         old/new
  - Определяйте конвенции именования часто используемых операций
    В Java конвенция есть по дефолту
  |    
  № 7.4 Насколько обьемным может быть метод?
  Отсекаем все лишнее, что осталось то и оставляем
  Большие методв больше 200 строк почти точно надо разбивать
  |    
  № 7.5 Советы по использованию параметров методов
  Интерфейсы между методами — один из основных источников ошибок
  Советы:
  - Передавайте параметры в порядке 
    «входные значения - изменяемые значения — выходные значения»
    (*) Это больше актуально для C++, но в java тоже можем так писать
  - Если несколько методов используют похожие параметры, передавайте
    их в согласованном порядке  
  - Используйте все параметры
    Наличие неиспользуемого параметра это звоночек, надо его удалить
  - Передавайте переменные статуса или кода ошибки последними
  - Не используйте параметры метода в качестве рабочих переменных
    другими словами НЕ модифицируй входные параметры без супер необходимости
    копируем значение во внутренние переменные и работаем
  - Документируйте выраженные в интерфейсе предположения о параметрах
    Что документировать:
    - вид параметров: являются ли они исключительно входными, изменяемыми или 
      исключительно выходными
    - единицы измерения (дюймы, футы, метры и т. д.)
    - смысл кодов статуса и ошибок, если для их представления не используются перечисления
      диапазоны допустимых значений
    - специфические значения, которые никогда не должны передаваться в метод
  - Ограничивайте число параметров метода примерно семью
    Если вам постоянно приходится передавать в методы слишком большое число
    аргументов, ваши методы имеют слишком сильное сопряжение. 
    Проектируйте методы или группы методов так, чтобы сопряжение было слабым
    (*) Если вы передаете одни и те же данные во многие разные методы, 
        сгруппируйте эти методы и данные в класс.
  - Подумайте об определении конвенции именования входных, изменяемых и выходных параметров
    Для Java не очень актуально (обычно не модефицируем обьект переданный в аргументах)
  - Передавайте в метод те переменные или объекты, которые нужны ему
    для поддержания абстракции интерфейса
    (*) тут есть два подхода
    У нас есть метод которому нужно скажем три поля из обьекта и вопрос передавать
    весь обьект как аргумент или только эти поля?
    - Первый (только поля)
      - это поддерживает минимальное сопряжение
      - способствует более быстрому пониманию методов
      - облегчает повторное использование
      - (*) передача всего обьекта нарушает принцып инкапсуляции
        так как мы получим обьект и получим доступ к полям, которые нам не нужны
    - Второй (весь класс)
      - удобно
      - ничего не нарушает
    - ВЫВОД
      - обы подхода не верные 
      - какую абстракцию формирует интерфейс метода?
      - Обычно наличие кода, «подготавливающего» данные перед вызовом метода 
        или «разбирающего» объект после вызова, — признак неудачного 
        проектирования метода.
  - Используйте именованные параметры
  - Убедитесь, что фактические параметры соответствуют формальным
    - это переменные, объявленные в определении метода
    - Для Java не актуально
  |    
  № 7.6 Отдельные соображения по использованию функций
  Тут вводим термины шаткие
    - Функция - это метод, возвращающий значение
    - Процедура - это метод, не возвращающий значение
  Когда использовать функцию, а когда процедуру?
    - Если основная цель вернуть значение используем функцию
  Возврат значения из функции
    - Проверяйте все возможные пути возврата
      - проверяем все сценарии выполнения ф-ии
    - Не возвращайте ссылки или указатели на локальные данные
      - (*) не актуально для Java
  |    
  № 7.7 Методы-макросы и встраиваемые методы
  - Разрабатывая макрос, заключайте в скобки все, что можно
    - " #define Cube( a ) a*a*a " отработет не верно, если заюзать Cube( 4+1 )
      так как это просто текстовая замена порядок действий удивит
  Все что дальше описано не актуально для Java
  

8) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 8 ] Защитное программирование
  |    
  № 8.1 Защита программы от неправильных входных данных
  Идея защитного программирования в том, что если методу передаются
  некорректные данные, то его работа не нарушится, даже если эти данные 
  испорчены по вине другой программы.
  Основные способы обработки входных данных:
  - Проверяйте все данные из внешних источников
    Проверяем все значения, что они попадают в допустимый интервал
    Проверяем что строки не больше определенной длины
    Проверить например SQL иньекци и т.д
  - Проверяйте значения всех входных параметров метода
    Дальше в 8.5 узнаем в каких методах важно проверять аргументы
    Это то же самое, что и прошлый пункт для данных, только тут для аргументов
  - Решите, как обрабатывать неправильные входные данные
    Что делать, если пришел неверный праметр, ответов миллион
  |    
  № 8.2 Утверждения
  Утверждения - это код, используемый во время разработки, для проверки выполнения
  Утверждения полезны, когда есть высокие требования к надежности
  Пример на Java:
    - assert denominator != 0 : ”denominator is unexpectedly equal to 0.”;
  Утверждения не предназначены для показа сообщений в промышленной версии
  При компиляции промышленной версии, обычно, утверждения удаляют
  Общие принципы использования утверждений
  - Используйте процедуры обработки ошибок для ожидаемых событий и утверждения 
    для событий, которые происходить не должны
    (*) Утверждения проверяют условия событий, которые никогда не должны происходить
  - Старайтесь не помещать выполняемый код в утверждения
    Есть вероятность что компилятор удалит этот код при отключении утверждений
  - Используйте утверждения для документирования и проверки предусловий и постусловий
    1 Предусловия — это обязательства клиентского кода перед кодом, который он вызывает
    2 Постусловия — это обязательства метода или класса перед кодом, который их использует
    3 Утверждения — удобный инструмент для документирования пред- и постусловий
  - Для большей устойчивости кода проверяйте утверждения, а затем все равно 
    обработайте возможные ошибки
  |    
  № 8.3 Способы обработки ошибок
  Способы:
    - Вернуть нейтральное значение
      Нам пришли не верные данные, а мы возвращаем приемлемое-нетральное значение
      Надо подумать о последствиях и возможно лучше остановить программу
    - Заменить следующим корректным блоком данных
      Если мы получаем непрерывно данные мы можем игнорировать ломанные данные
    - Вернуть тот же результат, что и в предыдущий раз
      Получаем значения раз в сек, есл пришла ерунда, оставляем старое значение
    - Подставить ближайшее допустимое значение
    - Записать предупреждающее сообщение в файл (в лог)
      Этот подход можно сочетать с другими  
    - Вернуть код ошибки
      Тут важно определить какая часть системы будет обрабатывать ошибки
    - Вызвать процедуру или обьект - обработчик ошибки
      Создаем мега класс и обрабатываем ошибочки, подход сомнительный
    - Показать сообщение об ошибке, где бы она ни случилась
      Тоже сомнительный подход
    - Обработать ошибку в месте возникновения наиболее подходящим способом
    - Прекратить выполнение
      Оправдано в очень критичном к безопасности ПО
  Устойчивость против корректности
    Выбор подходящего метода обработки ошибки зависит от приложения
    Корректность предпологает, что нельзя возвращать не точный результат
    Устойчивость говорит о том, что программа пытается продолжить работу не смотря
  Влияние выбора метода обработки ошибок на проектирование высокого уровня
    Способ обработки ошибок влияет на требования корректности и устойчивости 
    Выбор общего подхода к работе с некорректными данными - это вопрос архитектуры 
  |    
  № 8.4 Исключения
  Исключение - это способ метода сказать "Я не знаю, что с этим делать"
  Исключения с наследование мощные инструменты, мугут сильно влиять на общую сложность
  Советы:
    - Используйте исключения для оповещения других частей программы об ошибках, 
      которые нельзя игнорировать  
    - Генерируйте исключения только для действительно исключительных ситуаций
      Если мы никак не можем другими средствами решить проблему, кидаем исключение
    - Не используйте исключения по мелочам
      Если ошибку можем исправить на месте, то ислючение не нужно
    - Избегайте генерировать исключения в конструкторах и деструкторах,
      если только вы не перехватываете их позднее
    - Генерируйте исключения на правильном уровне абстракции
      Интерфейс метода и класса должен представлять собой целостную абстракцию. 
      Исключения — такая же часть интерфейса, как и специальные типы данных
      Плохой пример:
        - public TaxId GetTaxId() throws EOFException
          (*) вместо "EOFException" метод должен кидать искл своего уровня абстракции,
          например "TaxIdNotFoundException"
    - Вносите в описание исключения всю информацию о его причинах
      В идеале из исключения должно быть понятно как его исправить
    - Избегайте пустых блоков "catch"  
      Хотя бы оставьте комментарий, почему это не может быть исправлено
    - Выясните, какие исключения генерирует используемая библиотека
    - Рассмотрите вопрос о централизованном выводе информации об исключениях        
    - Стандартизуйте использование исключений в вашем проекте
      Способы:
      1 Создание базового класса для всех исключений
      2 Определите конкретные случаи, когда код может использовать try-catch локально
      3 Определите случаи когда нужно кудать исключение наружу
      4 решите будет ли использоваться централизованный генератор сообщений
    - Рассмотрите альтернативы исключениям
  |    
  № 8.5 Изоляция повреждений, вызванных ошибками
  Иззоляция повреждений, или баррикада, - это стратегия, сходная с тем как
    изолируют отсеки в трюме корабля
  Один из способов изоляции в целях защитного программирования состоит в разработке
    набора интерфейсов в качестве оболочки для безопасных частей кода
  Пример:
    ----------------  /                           \   --------------
    | Графический  |  \     ---------------       /   | Внутренний |
    | интерфейс    |  /     | Проверочный |       \   | Класс 1    |
    | пользователя |  \     | класс 1     |       /   --------------
    ----------------  /     ---------------       \         .
           .          \           .               /         .
           .          /           .               \         .
           .          \           .               /         . 
    ----------------  /     ---------------       \   --------------
    | Внешние      |  \     | Проверочный |       /   | Внутренний |
    | Файлы        |  /     | класс N     |       \   | Класс N    |
    ----------------  \     ---------------       /   -------------- 
    Выделение части кода для работы с непроверенными данными, так другая
    часть программы будет свободна от проверок
  (*) Такойже пожход можно применить на уровне класса, когда публичные методы 
      имеют проверки, а внутреннии уже нет       
  Удачная аналогия это аперационная, данные перед попаданием туда стериализуются и
    все, что находится в операционной считается безопасным, так как прошло проверку 
  - Преобразовывайте входные данные к нужному типу в момент ввода
    Сохранение данных в неопределенной форме сильно усложняет программу
  - Связь между барикадами и утверждениями
    Применение баррикад делает отчетливым различие между утверждениями 
      и обработкой ошибок
    Методы внцтри баррикад, должны использовать утверждения, так как поидее
    там будут проверенные данные и утверждения никогда не должны сработать,
    а снаружи исключения и их надо обрабатывать 
  - использование баррикард - это архитектурное решение
  |    
  № 8.6 Отладочные средства
  - Не применяйте ограничения промышленной версии к отладочной версии автоматически
    Промышленая версия должна работать быстро, а отладочная может позволить
      работать медленно.
    Промышленная версия должна быть экономна к ресурсам, отладочная нет
    Отладочная версия может предоставлять дополнительные возможности
  - Внедрите поддержку отладки как можно раньше
  - Используйте наступательное программирование
    Суть: Исключительные случаи должны обрабатываться так, чтобы во время 
      разработки они были очевидны, а в промышленном коде — позволяли продолжить работу
    Допустим есть "case" с 5 вариантами а по дефолту пишем в лог "Что-то не так!"    
    Вот приемы наступательного программирования:
      - Сделайте проблему достаточно мучительной, чтобы ее исправили. 
      - Заполняйте любую выделенную память, чтобы можно было обнаружить ошибки
          выделения памяти.
      - Заполняйте все файлы и потоки, чтобы выявить ошибки файловых форматов.
      - Настройте программу на отправку вам журналов ошибок по электронной почте
  - Запланируйте удаление отладочных средств
    - Для контроля версий и сборки программы используйте инструменты ant и make
      Система контроля версии - git
      Ant средство сборки, сейчас актуален maven, gradle
    - Используйте встроенный препроцессор
      Для Java не актуально
  |    
  № 8.7 Доля защитного программирования в промышленной версии
  - Оставьте код, которые проверяет существенные ошибки
  - Удалите код, проверяющий незначительные ошибки
  - Удалите код, приводящий к прекращению работы программы
    Почти всегда надо дать пользователю сохранить свои изменения перед падением
  - Оставьте код, который позволяет аккуратно завершить работу программы
  - Регистрируйте ошибки для отдела технической поддержки
  - Убедитесь, что оставленные сообщения об ошибках дружелюбны
  |    
  № 8.8 Защита от защитного программирования
  Избыток защитного программирования сам по себе создает проблемы
  Подумайте, где надо защищаться, и соответственно расставьте приоритеты 
    защитного программирования


9) [ Часть 2 ] Высококачественный код
   [ Часть 2 / Глава 9 ] Процесс программирования с псевдокодом
  |    
  № 9.1 Этапы создания классов и методов
  К конструированию классов можно подходить по#разному, но обычно это 
    итеративный процесс создания общей структуры класса, создание списка
    его методов, их конструирование и проверка класса как единого целого.

                              Начало
                                |
                               (.)
                       -------------------
                       | Создание        |
              |------->| Общей структуры |-------|
              |        | класса          |       |  
              |        -------------------       |   
              |                     ^            | 
              |                     |           (.) 
       -------------------          |   -------------------
       | Конструирование |          |---| Конструирование |
       | процедур        |<-------------| процедур        |
       | класса          |------------->| класса          |
       -------------------              -------------------
                |
                |
                |
                 ----> Завершение
  Этапы создания классов
    - Создание общей структуры класса 
      Определить ф-ии класса
      Определить будет ли он наследоваться
      Определить точный уровень абстракции
    - Конструирование всех методов класса
      Определив основные ф-ии надо переходить к конструированию методов
    - Оценка и тестирование всего класса
      В момент, когда класс становиться работоспособным, его надо протестировать
  Этапы построения метода
          
               Начало
                 |
                (.)
         -------------------              -------------------
         | Проектирование  |<-------------| Проверка        |
         | метода          |              | структуры       |
         |                 |------------->|                 |  
         -------------------              -------------------
             (.)                                 |
              |        При необходимости         |
              |            повторить             |
              |                                 (.) 
         -------------------              -------------------
         | Пересмотр       |<-------------| Кодирование     |
         | и тестирование  |              | метода          |
         | кода            |------------->|                 |
         -------------------              -------------------
                |
                |
                |
                 ----> Завершение
    Есть много подходов, но любимый подход автора, это начинать с псевдокода
  |    
  № 9.2 Псевдокод для профи
    - Применяйте формулировки, в точности описывающие отдельные действия
    - Избегайте синтаксических элементов языков программирования
    - Пишите псевдокод на уровне намерений
    - Пишите псевдокод на очень низком уровне с деталями
  (*) Пример хорошего псевдокода:
  Отслеживать текущее число используемых ресурсов
  Если другой ресурс доступен
    Выделить структуру для диалогового окна
    Если структура для диалогового окна может быть выделена
      Учесть, что используется еще один ресурс
      Инициализировать ресурс
      Хранить номер ресурса в вызывающей программе
    Конец «если»
  Конец «если»
  Вернуть true, если новый ресурс был создан; иначе вернуть false    
  (!) Выгоды от написания псевдокода в таком стиле:
    - Псевдокод упрощает пересмотр конструкции
    - Псевдокод поддерживает идею итеративного усовершенствования.
    - Псевдокод упрощает внесение изменений
      Одна из основ успеха отловить ошибку как можно раньше
  |    
  № 9.3 Конструирование методов с использованием ППП
  Пункты:
    1 проектирование метода
    2 кодирование метода
    3 проверка кода
    4 наведение глянца
    5 повторение предыдущих шагов при необходимости
  Проектирование метода
    Определив состав методов, начинаем их проектировать
    Как пример возьмем метод "ReportErrorMessage()" принимающий код ошибки и
      выводящий сообщение, соответствующие ошибки или в консоль или в файл
    - Проверка предварительных условий
      Убедитесь, что функции метода четко определены и соответствуют общим 
      проектным решениям.
    - Определите задачу, решаемую методом
      - задачу, решаемою методом, чтобы перейти к решению
      - информацию, скрываеммую методом
      - входные и выходные данные
      - предусловия,которые гарантированно должны соблюдаться
          до вызова метода
      - Постусловия, которые гарантированно должны соблюдаться, прежде чем
          метод вернет управление
      (*) для нашиго метода-примера получаем:
        1 метод скрывает текст сообщения и текущий метод обработки 
          (интерактивный или командной строки)
        2 выполнение каких либо предусловий не требуется
        3 входными данными является код ошибки
        4 выходные данные двух видов: сообщение об ошибке и статус, возвращаемый
          "ReportErrorMessage()" вызывающей программе
        5 возвращаемый статус должен принимать одно из двух значений: 
          Success или Failure
    - Название метода
      Хорошее наввание - признак высокого стиля программирования
      Если трудно подобрать имя это сигнал, что мы не понимаем что метод делает
      (*) для нашиго метода-примера получаем: 
        "ReportErrorMessage()" - хорошее имя
    - Решите, как тестировать метод
      В процессе написания думайте как будете тестировать
    - Исследуйте функциональность, предоставляемую стандартными библиотеками
      Основное правило улучшить качество кода это использовать библиотеки
    - Продумайте обработку ошибок
      Подумайте обо всем плохом, что может случиться с вашим методом
      Есть много подходов обработки ошибок, надо определиться и использовать
    - Думайте об эффективности 
      Когда-то эффективность это скорость, а когда то память, а иногда что-то третье 
      (*) надо убедиться что интерфейс получается максимально абстрактным,
          чтобы потом можно было бы улучшить реализачию
      Не трать время на методы, пока можно менять верхнеуровневый дизайн     
    - Исследуйте алгоритмы и типы данных
      Ищем в стандартной библиотеке языка, есл нет, то реализуем
    - Пишите псевдокод
      (*) для нашиго метода-примера получаем: 
    [  
      Установить статус по умолчанию в “сбой”.
      Найти сообщение, соответствующее коду ошибки.
        Если код ошибки корректен
          Если работа в интерактивном режиме, вывести сообщение
          и указать успешный статус.
       
          Если работа в режиме командной строки, запротоколировать
          сообщение об ошибке и указать успешный статус.
      Если код ошибки некорректен, информировать пользователя
      об обнаружении внутренней ошибки.
      
      Вернуть статус
    ]
    - Продумайте применение данных
      Надо продумать основные фрагменты данных до построения логики метода
    - Проверьте псевдокод
      Попробуйте обьяснить логику метода, убедитесь, что все сходится
    - Опишите несколько идей псевдокодом и выберите лучшую (пройдите по циклу)
      Пройдитесь по псевдокоду несколько раз, пока реализация не покажется понятной
  Кодирование метода
    
                   Начните с псевдокода
                           |
                          (.)
             ------------------------------
             | Напишите обьявление метода |
       |---->|                            |
       |     |                            |  
       |     ------------------------------ 
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Напишите первый и последний операторы, |
       |     | а псевдокод превратите в комментарии   |
       |---->| верхнего уровня                        | 
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Добавьте код после каждого комментария |
       |     |                                        |
       |---->|                                        |
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |<----| Проверьте код                          |
       |     |                                        |
       |---->|                                        |
       |     ------------------------------------------
       |                  |
       |                 (.)
       |     ------------------------------------------
       |     | Исправьте неточности                   |
       |     |                                        |
       |     |                                        |
       |     ------------------------------------------
       |           |      |
       |           |      |
       |------------      |
                          ---> Завершение
    - Обьявление метода
    - Напишите код под каждым комментарием
    - Проверьте, не нужна ли дальнейшая декомпозиция кода
      Если кода получается много, то вынести логику в еще один метод
  Проверка кода
    Третий шаг после проектирования и реализации - его проверка
    Сейчас надо проверить метод на ошибки, прежде чем идти дальше
    Умозрительно проверьте ошибки в методе
      Мысленно выполните все ветви метода 
    Компиляция метода
      1 Установите наивысший уровень предупреждений компилятора.
      2 Применяйте проверяющие средства (линтеры, анализаторы)
      3 Выясните причину всех сообщений об ошибках и предупреждений.
    Пройдите по коду отладчиком
    Протестируйте код
    Удалити ошибки из метода
  Наведение глянца
    1 Проверьте интерфейс метода
      Убедитесь, что применяются все входные и выходные данные
    2 Проверьте общее качество конструкции
      Убедитесь, что метод выполняет единственную задачу и делает это хорошо
      Имеем слабое сопряжение с другими методами
      Имет учитывает методику защитного программирования (барьеры/проверки)
    3 Проверьте переменные метода
      Корректность наименования, неиспользуемые обьекты, необьявленные переменные
    4 Проверьте логику метода
    5 Проверьте форматирование метода
    6 Проверьте документирование метода
    7 Удалите лишнии комментарии    
  Повторите нужное число раз
    ПО — итеративный процесс, повторите весь процесс, пока не выйдет что-то орошее
  |    
  № 9.4 Альтернативы ППП
  Для меня ППП — идеальная методика создания классов и методов. 
  Другие подходы:
    - Разработка с изначальными тестами
    - Рефакторинг
    - Проектирование по контракту
    - Бессистемное программирование
      Лепим как получиться, если вы так делаете, то используйте ППП


10)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 10 ] Общие принципы использования переменных
  |    
  № 10.1 Что вы знаете о данных?
    тут штуки
  |    
  № 10.2 Грамотное обьявление переменных
  Неявные обьявления
    Неявное объявление переменных — одна из самых опасных возможностей языка 
    Советы: 
    - Отключите неявные объявления
    - Объявляйте все переменные
    - Используйте конвенции именования
    - Проверяйте имена переменных
  |    
  № 10.3 Принципы инициализации переменных
  - Инициализируйте каждую переменную при ее объявлении
    Простая и эффективная методика безопасного программирования
  - Инициализируйте каждую переменную там, где она используется в первый раз  
  - В идеальном случае сразу объявляйте и определяйте каждую переменную
     непосредственно перед первым обращением к ней
  - Объявляйте переменные по мере возможности как final или const   
  - Уделяйте особое внимание счетчикам и аккумуляторам
    Это про цыклы где мы юзаем i,j,n которые часто забывают обнулять
  - Инициализируйте данные члены класса в его конструкторе
  - Настройте компилятор так, чтобы он автоматически инициализировал все переменные 
  - Внимательно изучайте предупреждения компилятора
  - Проверяйте корректность входных параметров
    Прежде чем в переменную положить значение, надо убедиться, что это возможно
  - Инициализируйте рабочую память при запуске программы
    Можно использовать специальную утилиту, чтобы заполнить всю память
      определенным значением перед запуском программы. Это может помочь
      найти ошибки
  |    
  № 10.4 Область видимости
  Локализуйте обращения к переменным
    Код, расположенный между обращениями к переменной, является «окном уязвимости»  
    Чем кучнее получается использовать переменные, тем легче читать код
  Делайте время жизни переменных как можно короче
    Это уменьшает окно уязвимости, снижая вероятность неверного или неумышленного 
      изменения переменной между действительно нужными обращениями к ней.   
    Чем меньше время жизни, тем обычно лучше контроль сложности программы
  Общие советы по минимизации области видимости
    Инициализируйте переменные, используемые в цикле, непосредственно перед циклом, 
      а не в начале метода, содержащего цикл    
    Не присваивайте переменной значение вплоть до его использования
    Группируйте связанные команды
    Разбивайте группы связанных команд на отдельные методы
    Начинайте с самой ограниченной области видимости и расширяйте ее только 
      при необходимости
  Комментарии по поводу минимизации области видимости
    Ограничивайте область видимости каждой переменной минимальным фрагментом кода.
  |    
  № 10.5 Персистентность
  «Персистентность» — характеризует длительность существования данных
  Для Java не актуально, так как мы защищены от обращения по произвольным указателям
  |    
  № 10.6 Время связывания
  «время связывания» — момент, когда переменная и ее значение связываются вместе
  Обычно чем позднее можно сделать связывание, тем гибче получается код, но сложнее
  |    
  № 10.7 Связь между типами данных и управляющими структурами
  Между типами данных и управляющими структурами существуют однозначные отношения
  1 Последовательные данные соответствуют последовательности команд
    это набор блоков данных, используемых в определенном порядке
  2 Селективные данные соответствуют операторам if и case
     Представляют собой набор, допускающий использование одного и только одного 
       элемента данных в каждый конкретный момент времени 
  3 Итеративные данные соответствуют циклам
    данные одного типа, повторяющиеся более одного раза 
  |    
  № 10.8 Единственность цели каждой переменной
  - Используйте каждую переменную только с одной целью
  - Избегайте переменных, имеющих скрытый смысл
    Например "pageCount" можем использовать значение -1 как ошибку, 
      это однозначно плохой путь, так как переменная обьединяет две цели в себе
  - Убеждайтесь в том, что используются все объявленные переменные 


11)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 11 ] Сила имени переменных
  |    
  № 11.1 Общие принципы выбора имен переменных
  Самый важный принцип именования переменных
    Имя должно полно и точно описывать сущность
    Переменную, представляющую число членов олимпийской команды США, 
      можно было бы назвать numberOfPeopleOnTheUsOlympicTeam
  Ориентация на проблему
    Хорошее имя в большей степени выражает что, а не как
  Оптимальная длина имени переменной
    Примерно 10–16 символов
  Имена переменных и область видимости
    Более длинные имена лучше присваивать редко используемым или глобальным 
      переменным, а более короткие — локальным переменным или переменным в циклах
    Дополняйте имена, относящиеся к глобальному пространству имен, спецификаторами
      В C++ и C# для разделения используется "namespace"
      В Java можем использовать "packeg"  
  Спецификаторы вычисляемых значений
    Переменные, содержащие вычисляемые значения: суммы, средние величины и т. д
      Дополните Total, Sum, Average, Max, Min или Pointer, укажите его в конце имени
  Антонимы, часто встречающиеся в именах переменных
    - begin/end          first/last
    - locked/unlocked    min/max
    - next/previous      old/new
    - opened/closed      visible/invisible
    - source/target      source/destination
    - up/down
  |    
  № 11.2 Именование конкретных типов данных
  Именование индексов циклов
    В качестве индексов циклов используют переменные i, j и k
    Если же переменную предполагается использовать вне цикла, ей следует 
      присвоить более выразительное имя  
  Именование переменных статуса
    Старайтесь не присваивать переменной статуса имя flag
    Обычно в качестве флага удобно использовать "enum"  
  Именование временных переменных
    Относитесь к «временным» переменным с подозрением
    Использование tmp или x для временного хранения, надо подумать над именем!
  Именование булевых переменных
    Помните типичные имена булевых переменных
      - [done] используйте как признак завершения цикла или другой операции
      - [error] как признак ошибки
      - [found] обнаружено ли некоторое значение    
      - [success] как признак успешного завершения операции 
    Присваивайте булевым переменным имена, подразумевающие значение true или false
      Поэтому имя status лучше заменить на имя вроде error или statusOK, 
        а имя sourceFile — на sourceFileAvailable, sourceFileFound или подобное имя, 
        соответствующее сути переменной    
    Используйте утвердительные имена булевых переменных
      Не использовать -> такие как notFound, notdone и notSuccessful
  Именование перечислений
    Принадлежность переменных к тому или иному перечислению можно пояснить, 
      дополнив их имена префиксами, такими как Color_, Planet_ или Month_
  Именование констант
    Имя FIVE — плохое имя константы, надо имя дать не зависящее от значения
      CYCLES_NEEDED — хорошее имя.  
  |    
  № 11.3 Сила конвенций именования
  Зачем нужны конвенции?
    1 Они позволяют больше принимать как данное и фокусироваться на других вещах
    2 Сходство имен облегчает понимание незнакомых переменных
    3 Они ускоряют изучение кода нового проекта
    4 Они подавляют «размножение» имен, уменьшает варианты наименования переменных
    5 Можете именами реализовать отсутствующие возможности языка
    (*) наличие хоть какой#то конвенции обычно предпочтительнее, чем ее отсутствие
  Когда следует использовать конвенцию именования?
    Рекомендации:
      - над проектом работают несколько программистов
      - программу будут изменять и сопровождать другие программисты 
      - обзор программы выполняют другие программисты из вашей компании
      - программа так велика, что вы не можете полностью охватить ее умом
      - программа будет использоваться длительное время
      - прикладная область имеет необычную терминологию и вы хотите 
          стандартизовать применение терминов или аббревиатур в коде  
    Степень формальности конвенций
      Формальная конвенция — важнейшее средство улучшения удобочитаемости программы  
  |    
  № 11.4 Неформальные конвенции именования
  Конвенция, не зависящая от языка
    - Проведите различие между именами переменных и именами методов
    - Проведите различие между классами и объектами
    - Идентифицируйте глобальные переменные
      (*) сделать префикс "g_", для Java не актуально
    - Идентифицируйте переменные'члены
      (*) сделать префикс "m_", для Java не актуально
    - Идентифицируйте определения типов
      (*) сделать префикс "t_Color, t_Menu", для Java не актуально  
    - Идентифицируйте именованные константы
      (*) сделать префикс "c_", для Java не актуально  
    - Идентифицируйте элементы перечислений
      (*) сделать префикс "e_", для Java не актуально  
    - Форматируйте имена так, чтобы их было легко читать
  Конвенции, специфические для конкретных языков
    для Java нету, пропускаем этот пункт
  Программирование с использованием нескольких языков
    похожк тут вредный совет следовать одной конвенции, но кажется лучше так не делать    
  |    
  № 11.5 Стандартные префиксы
  Венгерская нотация — представляет собой набор детальных принципов 
    именования переменных и методов
  Cуть — создание стандартизованного набора лаконичных точных аббревиатур
  Стандартизованный префикс состоит из: аббревиатуры типа и семантического префикса
  Аббревиатура типа, определенного пользователем
    Аббревиатура UDT обозначает тип объекта или переменной
    Мы берем слова, которые будем использовать и договариваемся о короткой форме
    Пример:
      - doc   Документ
      - pa    Абзац (paragraph)
      - scr   Область экрана
      - sel   Выбранный текст
      - wn    Окно
  Семантические префиксы
    Дополняют аббревиатуры UDT, характеризуя использование переменной или объекта.
    Пример:
      - c    Количество (записей, символов и т. д.).
      - g    Глобальная переменная. 
      - i    Индекс массива.
  Достоинства стандартизованных префиксов
    - Однообразные имена легче читать
    - Делают имена более компактными  
  |    
  № 11.6 Грамотное сокращение имен переменных
  Общие советы по сокращению имен
    - используйте стандартные аббревиатуры 
    - удаляйте все гласные, не являющиеся первыми буквами имен 
        (computer — cmptr, screen — scrn, apple — appl, integer — intgr)
    - удаляйте артикли и союзы, такие как and, or, the и т.д
    - сохраняйте одну или несколько первых букв каждого слова
    - «обрезайте» слова согласованно: после первой, второй или третьей буквы
    - сохраняйте первую и последнюю буквы каждого слова
    - сохраняйте до трех выразительных слов
    - удаляйте бесполезные суффиксы: ing, ed и т.д. 
    - сохраняйте наиболее выразительный звук каждого слога
    - проверяйте, чтобы смысл имени переменной в ходе сокращения не искажался 
  Фонетические аббревиатуры
    не используйте такой способ (сокращение на основе того как слышится)
  Комментарии по поводу сокращения имен
  - Не сокращайте слова только на один символ
  - Сокращайте имена согласованно
    Всегда используйте один и тот же вариант сокращения
  - Сокращайте имена так, чтобы их можно было произнести
  - Избегайте комбинаций, допускающих неверное прочтение или произношение имени
  - Обращайтесь к словарю для разрешения конфликтов имен
  - Документируйте очень короткие имена прямо в коде при помощи таблиц    
  - Указывайте все сокращения в проектном документе "Стандартные аббревиатуры"  
    Cоздать документ «Стандартные аббревиатуры», описывающий все аббревиатуры 
      конкретного проекта 
    Этот совет иллюстрирует различие между удобством написания кода и удобством 
      его чтения
  - Помните, что имена создаются в первую очередь для программистов, читающих код
  |    
  № 11.7 Имена, которых следует избегать
  - Избегайте обманчивых имен или аббревиатур
  - Избегайте имен, имеющих похожие значения
  - Избегайте переменных, имеющих разную суть, но похожие имена 
  - Избегайте имен, имеющих похожее звучание, таких как wrap и rap
  - Избегайте имен, включающих цифры
  - Избегайте орфографических ошибок
  - Избегайте слов, при написании которых люди часто допускают ошибки 
  - Проводите различие между именами не только по регистру букв
  - Избегайте смешения естественных языков
  - Избегайте имен стандартных типов, переменных и методов
  - Избегайте имен, содержащих символы, которые можно спутать с другими символами


12)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 12 ] Основные типы данных
  |    
  № 12.1 Числа в общем
  - Избегайте «магических чисел»
  - Ошибки деления на ноль
    Если такая возможность существует, напишите код, предупреждающий 
      появление ошибки
  - Выполняйте преобразования типов понятно
  - Избегайте сравнений разных типов
  - Обращайте внимание на предупреждения вашего компилятора   
     Легче предоставить работу компилятору, чем выполнять ее самому
  |    
  № 12.2 Целые числа
  - Проверяйте целочисленность операций деления
    выражение 7/10 не равно 0,7
  - Проверяйте переполнение целых чисел
    Надо учитывать это, будет ли тут число хранится больше чем может вместить
  - Проверяйте на переполнение промежуточные результаты
  |    
  № 12.3 Числа с плавающей запятой
  - Избегайте сложения и вычитания слишком разных по размеру чисел
    Это позволит минимизировать проблему округления
  - Избегайте сравнений на равенство
    Запрет на сравнение по равенству, только больше или меньше
  - Предупреждайте ошибки округления
    1 Измените тип переменной на тип с большей точностью
    2 Используйте двоично десятичные переменные
    3 Измените тип с плавающей запятой на целые значения
  - Проверяйте поддержку специальных типов данных в языке 
      и дополнительных библиотеках
  |    
  № 12.4 Символы и строки
  - Избегайте магических символов и строк
    Используйте именованные константы
    причины избегать:
    1 менять можно будет в одном месте
    2 потом можно это сгрупировать в класс
    3 дублирование может привести к лишним затратам памяти
  - Следите за ошибками завышения/занижения на единицу
    не актуально для Java
  - Узнайте, как ваш язык и система поддерживают Unicode   
    в Java, все строки хранятся в формате Unicode
  - Разработайте стратегию интернационализации/локализации в ранний 
      период жизни программы
    Надо решить какие строки будут находиться во внешних ресурсах, для
      локализации
  - Если вам известно, что нужно поддерживать только один алфавит, 
      рассмотрите вариант использования набора символов ISO 8859
  - Если вам необходимо поддерживать несколько языков, используйте Unicod
  - Выберите целостную стратегию преобразования строковых типов
  |    
  № 12.5 Логические переменные
  - Используйте логические переменные для документирования программы
    Можно использовать переменную с говорящим именем, а не просто условие
  - Используйте логические переменные для упрощения сложных условий
    разбиваем сложное на сумму простого
  |    
  № 12.6 Перечислимые типы
  - Используйте перечислимые типы для читабельности
    видите числовую константу, подумайте: не заменить ли ее перечислимым типом
  - Используйте перечислимые типы для надежности
  - Используйте перечислимые типы для модифицируемости
  - Используйте перечислимые типы как альтернативу логическим переменным
    для методов которые возвращают true/false
  - Проверяйте некорректные значения
    в switch-case или if-else используйте ветку когда пришло что-то неожиданное
  - Настройте первый и последний элемент перечислимого типа для использования 
      в качестве границ циклов
  - Зарезервируйте первый элемент перечислимого типа как недопустимый
    не актуально для Java
  - Точно укажите в стандартах кодирования для проекта, как должны использоваться 
      первый и последний элементы, и неукоснительно придерживайтесь этого
    не актуально для Java  
  |    
  № 12.7 Именованные константы
  - Используйте именованные константы в объявлениях данных
  - Избегайте литеральных значений, даже «безопасных»
    (For i = 1 To 12) что такое 12, выносим в именнованную константу
  - Имитируйте именованные константы с помощью переменных или классов правильной 
      области видимости
    не актуально для Java 
  - Последовательно используйте именованные константы
  |    
  № 12.8 Массивы
 - Убедитесь, что все значения индексов массива не выходят за его границы
 - Обдумайте применение контейнеров вместо массивов или рассматривайте массивы 
     как последовательные структуры
   Если мы будем использовать массивы без произвольного доступа к элементам,
     то код обычно получается более производительным
 - Проверяйте конечные точки массивов
   не актуально для Java 
  |    
  № 12.9 Создание собственных типов данных (псевдонимы)
  (*) typedef в (c/C++), в Java такой возможности нет


13)  [ Часть 3 ] Переменные
     [ Часть 3 / Глава 13 ] Нестандартные типы данных
  |    
  № 13.1 Структуры
  Иногда классы называют структурами, если они состоят только из данных
  - Используйте структуры для прояснения взаимоотношений между данными
    Обьединяем связанные данные и используем вместе
    Четкая структурированность данных улучшает код
  - Используйте структуры для упрощения операций с блоками данных
    Упрощает операции над цельным кусочком связанных данных
  - Используйте структуры для упрощения списка параметров
  - Используйте структуры для упрощения сопровождения
  |    
  № 13.2 Указатели
  Парадигма для понимания указателей
    каждый указатель состоит из двух частей: области памяти и знания
      1 Область памяти
        Область памяти — это адрес, представленный в виде числа
        Чтобы обратиться к данным, надо пойти по этому адресу и 
          как-то интерпритировать данные в этой области
      2 Знание, как интерпретировать содержимое 
        Информация о том как интерпритировать данные определяется типом указателя
  Основные советы по использованию указателей
  - Изолируйте операции с указателями в методах или классах
  - Выполняйте объявление и определение указателей одновременно
  - Удаляйте указатели в той же области действия, где они были созданы
  - Проверяйте указатели перед их применением
  - Проверяйте переменную, на которую ссылается указатель, перед ее использованием  
  - Используйте закрепленные признаки для проверки повреждения памяти
    можно кусочек памяти выделять и класть туда хитрое число, которое
      потом можно прочитать и проверить, что мы в нужном кусочке памяти
  - Добавьте явную избыточность
    добавить несколько полей тегов 
  - Используйте для ясности дополнительные переменные указателей
    куда указывает pointer->next->last->next ? не делайте такие цепочки вызовов 
  - Нарисуйте картинку
    так станет понятно кто на что указывает
  - Удаляйте указатели в связных списках в правильном порядке
    иногда удалив память элемента можем потерять ссылку на следующий элемент
  - Выделите «запасной парашют» памяти
    Заранее выделяем парашут памяти, чтобы когда память кончится созранить все
      данные и безопасно завершиться
  - Уничтожайте мусор
    Записывайте мусор в освобожденные блоки памяти, чтобы быстрее отловить
      ошибки работы с указателями
  - Устанавливайте указатели null при их удалении или освобождении
    висячий указатель - обращение к нему после вызова функций delete или free
    чтобы обезопасить себя после освобождения памяти присваиваем null 
  - Проверяйте корректность указателя перед его удалением
    если присваивали Null то проверяем на null
  - Отслеживайте распределение памяти для указателей
    Ведите список указателей, для которых была выделена память
  - Напишите методы оболочки, чтобы централизовать стратегию борьбы с ошибками 
      в указателях
    1 SAFE_NEW
      Вызывает new для выделения памяти, добавляет указатель в список 
      задействованных указателей и возвращает вновь созданный указатель 
      вызывающей стороне. Он может также проверить, что оператор new не 
      вернул null (ошибка нехватки памяти).
    2 SAFE_DELETE
      Проверяет, находится ли переданный ему указатель в списке
      действительных указателей. Если он там есть, метод записывает мусор 
      в адресуемую им память, удаляет указатель из списка, 
      вызывает C++ оператор delete для освобождения памяти и устанавливает 
      указатель в null.
  - Используйте технологию, не основанную на указателях
    если можете не использовать указатели, то не используйте
  |    
  № 13.3 Глобальные данные
  Распространенные проблемы с глобальными данными
    - Непреднамеренные изменения глобальных данных
    - Причудливые проблемы при использовании псевдонимов для глобальных данных
    - Проблемы реентерабельности глобальных данных
      Многопоточное программирование создает вероятность обращения к общим данным
      Затруднение повторного использования кода, вызванное глобальными
        данными
      Глобальные данные как вирус они лияют на исходный код, но и распространяются
        по новым программам, использующим какие либо классы из старой.
    - Проблемы с неопределенным порядком инициализации глобальных данных
    - Нарушение модульности и интеллектуальной управляемости, привносимое 
        глобальными данными
  Причины для использования глобальных данных
    - Хранение глобальных значений
      Если данные относятся ко всей программе, то логично их вынести
    - Эмуляция именованных констант
    - Эмуляция перечислимых типов
    - Оптимизация обращений к часто используемым данным
    - Исключение бродячих данных
  Используйте глобальные данные только как последнее средство
    - Начните с объявления всех переменных локальными и делайте их глобальными 
        только по необходимости
    - Различайте глобальные переменные и переменные'члены класса
    - Используйте методы доступа
  Используйте методы доступа вместо глобальных данных
    - Преимущества методов доступа
      1 Вы получаете централизованный контроль над данными
      2 Все ссылки на переменную будут изолированы
      3 Получаете главные преимущества сокрытия информации
      4 Методы доступа легко преобразуются в абстрактные типы данных
        вместо "if lineCount > MAX_LINES" -> "if PageFull()"
    - Как использовать методы доступа
      1 Требуйте, чтобы весь код обращался к данным через методы доступа
      2 Не валите все глобальные данные в одну кучу
      3 Управляйте доступом к глобальным переменным с помощьюблокировок
      4 Встройте уровень абстракции в методы доступа
      5 Выполняйте доступ к данным на одном и том же уровне абстракции
  Как уменьшить риск использования глобальных данных
    Обычно наличие глобальных данных говорит о неверном проектировании  
    Есть только микро набор кейсов, когда использование глоб данных оправдано
    - Разработайте именование, которое сделает глобальные переменные очевидными        
    - Создайте хорошо аннотированный список всех глобальных переменных
      Иметь список глобальных переменных — очень полезно
    - Не храните промежуточных результатов в глобальных переменных
    - Не считайте, что вы не используете глобальные переменные, поместив
        все данные в чудовищный объект и передавая его всюду   


14)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 14 ] Организация последовательно кода
  |    
  № 14.1 Организация последовательно кода
  - Организуйте код так, чтобы зависимости были очевидными
    из кода должен быть очевиден порядок действий и зависимости
      одного вызова от другого
  - Называйте методы так, чтобы зависимости были очевидными
  - Используйте параметры методов, чтобы сделать зависимости очевидными  
    в этом приере есть намек что порядок методов важен:
    " InitializeExpenseData( expenseData )
      ComputeMarketingExpense( expenseData )
      ComputeSalesExpense( expenseData ) "
  - Документируйте неявные зависимости с помощью комментариев    
    при таком вызове методов, без коментария не понятно важен ли порядок
    " InitializeExpenseData
      ComputeMarketingExpense
      ComputeSalesExpense "
  - Проверяйте зависимости с помощью утверждений или кода обработки ошибок
  |    
  № 14.2 Операторы, следующие в произвольном порядке
  - Размещение кода для чтения сверху вниз
    обеспечить чтение программы сверху вниз, а не перескакивая с места на место
  - Группировка взаимосвязанных выражений
    Размещайте взаимосвязанные выражения вместе. 
 


15)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 15 ] Условные операторы
  |    
  № 15.1 Операторы if
  - Простые операторы if-then
    1 Сначала напишите код номинального хода алгоритма, затем опишите 
      исключительные случаи
    2 Убедитесь, что при сравнении на равенство ветвление корректно
    3 Размещайте нормальный вариант после if, а не после else 
    4 Размещайте осмысленные выражения после оператора if
    5 Рассмотрите вопрос использования блока else
    6 Проверяйте корректность выражения else
    7 Проверяйте возможную перестановку блоков if и else
  - Последовательности операторов if-then-else
    1 Упрощайте сложные проверки с помощью вызовов логических функций
    2 Размещайте наиболее вероятные варианты раньше остальных
    3 Убедитесь, что учтены все варианты
    4 Замените последовательности if-then-else другими конструкциями, 
      которые поддерживает ваш язык программирования 
  |    
  № 15.2 Операторы case
  - Выбор наиболее эффективного порядка вариантов
    1 Упорядочивайте варианты по алфавиту или численно
    2 Поместите правильный вариант первым
    3 Отсортируйте варианты по частоте
  - Советы по использованию операторов case
    1 Сделайте обработку каждого варианта простой
    2 Не конструируйте искусственные переменные с целью получить 
      возможность использовать оператор case
    3 Используйте вариант по умолчанию только для обработки настоящих
      значений по умолчанию
    4 Используйте вариант по умолчанию для выявления ошибок
      " default:
          DisplayInternalError( “Internal Error 905” ); "
    5 В C++ и Java старайтесь не писать код, проваливающийся сквозь блоки 
        оператора case
      лучше всегда использовать "break;"
    

16)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 16 ] Циклы
  |    
  № 16.1 Выбор типа цикла
  Обычно есть несколько типов циклов:
    - Цикл с подсчетом выполняется определенное количество раз
    - Постоянно вычисляемый цикл, который не знает когда остановится
    - Бесконечный цикл выполняется все время с момента старта
    - Цикл с итератором выполняет некоторые действия однократно 
      для каждого элемента контейнерного класса
  Когда использовать цикл while
    Если вы заранее не знаете, сколько итераций нужно
  Когда использовать цикл for
    Если вам нужен цикл, выполняющийся определенное количество раз
  Когда использовать цикл foreach
    Когда нам что то надо сделать над всеми элементамми массива или контейнера
  |    
  № 16.2 Управление циклом
  Вход в цикл
    - Размещайте вход в цикл только в одном месте
    - Размещайте инициализационный код непосредственно перед циклом
    - Используйте while (true) для бесконечных циклов
    - Предпочитайте циклы for, если они применимы
    - Не используйте цикл for, если цикл while подходит больше
  Обработка середины цикла
    - Используйте { и } для обрамления выражений в цикле
    - Избегайте пустых циклов
    - Располагайте служебные операции либо в начале, либо в конце цикла
      Служебные операции цикла — это выражения вроде i = i + 1 или j++
    - Заставьте каждый цикл выполнять только одну функцию
      Циклы должны быть подобны методам в том плане, что каждый должен 
        делать только одно дело и делать его хорошо
  Завершение цикла
    - Убедитесь, что выполнение цикла закончилось
    - Сделайте условие завершения цикла очевидным
    - Не играйте с индексом цикла for для завершения цикла
      писать в теле цикла i = 99999, говорит о плохом дизайне
    - Избегайте писать код, зависящий от последнего значения индекса цикла
      Использование значения индекса цикла после его завершения — дурной тон
      Заведите отдельную переменную, которую потом используйте
    - Рассмотрите использование счетчиков безопасности
      Для очень критичных к сбоям участах кода можно использовать это:
      Счетчик безопасности — это переменная, увеличивающаяся при каждом проходе 
      цикла, чтобы определить, не слишком ли много раз выполняется цикл.
    - Досрочное завершение цикла
      Операторы continue и break, если можно без них, то кайф, но
        лучше использовать их чем флаги для условия цикла
    - Рассмотрите использование операторов break вместо логических флагов 
        в цикле while
    - Остерегайтесь цикла с множеством операторов break, разбросанных по
        всему коду
    - Используйте continue для проверок в начале цикла
      Например если при чтении файла мы должны игнорировать некоторые символы 
    - Используйте структуру break с метками, если ваш язык ее поддерживает
      Это удобно когда надо выйти во внешний цикл
    - Используйте операторы break и continue очень осторожно
      Круто если цикл можно понять не смотрев в его серединку, использование
      "break" заставляет смотреть тело цикла
  Проверка граничных точек
    При разработке цикла обычно особо интересны три точки:
      1 начало цикла, 2 серединка, 3 его конец
  Использование переменных цикла
    - Используйте порядковые или перечислимые типы для границ массивов и циклов  
    - Используйте смысловые имена переменных, чтобы сделать вложенные 
      циклы читабельными
      пример:
      "
      for ( int payCodeIdx = 0; payCodeIdx < numPayCodes; payCodeIdx++ ) {
       for (int month = 0; month < 12; month++ ) {
        for ( int divisionIdx = 0; divisionIdx < numDivisions; divisionIdx++ ) {
         sum = sum + transaction[ month ][ payCodeIdx ][ divisionIdx ];
        }
       }
      }
      "
    - Используйте смысловые имена во избежание пересечения индексов
    - Ограничивайте видимость переменных'индексов цикла самим циклом
  Насколько длинным может быть цикл?
    - Делайте циклы достаточно короткими, чтобы их можно было увидеть 
      сразу целиком
        (*) круто если не длиннее 20 строк
    - Ограничивайте вложенность тремя уровнями
    - Выделяйте внутреннюю часть длинных циклов в отдельные методы
    - Делайте длинные циклы особенно ясными
  |    
  № 16.3 Простое создание цикла — изнутри наружу
  Шаг 1: В комментариях напишите шаги, которые должно выполнять тело цикла
    "
      — Получить ставку из таблицы.
      — Добавить ставку к общей сумме.
    "
  Шаг 2: Замените комментарии в теле цикла на код, насколько это возможно
    "
      rate = table[ ]
      totalRate = totalRate + rate
    "
  Шаг 3: Далее добавьте индексы
    "
      rate = table[ census.Age ][ census.Gender ]
      totalRate = totalRate + rate
    "
  Шаг 4: построение цикла вокруг существующих выражений
    "
      For person = firstPerson to lastPerson
        rate = table[ census.Age, census.Gender ]
        totalRate = totalRate + rate
      End For
    "
  Шаг 5: поместить цикл for вокруг существующего кода
    "
      For person = firstPerson to lastPerson
        rate = table[ census[ person ].Age, census[ person ].Gender ]
        totalRate = totalRate + rate
      End For
    "
  Последний шаг:  напишите необходимую инициализацию
    "
      totalRate = 0
      For person = firstPerson to lastPerson
        rate = table[ census[ person ].Age, census[ person ].Gender ]
        totalRate = totalRate + rate
      End For
    "
  |    
  № 16.4 Соответствие между циклами и массивами
  Циклы и массивы часто связаны друг с другом


17)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 17 ] Нестандартные управляющие структуры
  |    
  № 17.1 Множественные возвраты из метода
  Операторы return и exit — управляющие структуры, которые позволяют 
    программе при желании завершить работу метода
  - Используйте return, если это повышает читабельность
  - Упрощайте сложную обработку ошибок с помощью сторожевых 
    операторов (досрочных return или exit)
    (*) например, чтобы избежать большой вложенности
  - Минимизируйте число возвратов из каждого метода
  |    
  № 17.2 Рекурсия
  Обычно рекурсию применяют, когда небольшую часть задачи легко решить, 
    а саму задачу просто разложить на составные части
  Советы по использованию рекурсии
    - Убедитесь, что рекурсия остановится
    - Предотвращайте бесконечную рекурсию с помощью счетчиков безопасности 
    - Ограничьте рекурсию одним методом
    - Следите за стеком
    - Не используйте рекурсию для факториалов и чисел Фибоначчи
      обычно рекурсия не оптимальна с точки зрения ресурсов
  |    
  № 17.3 Оператор goto
  Аргументы против goto
    1 код без goto — более качественный
    2 корректность кода, не содержащего goto, доказать легче
    3 код с операторами goto трудно форматировать
    4 применение goto препятствует оптимизации, выполняемой компилятором
    5 goto - зло 
  Аргументы в защиту goto
    1 Оператор goto может пригодиться в методе, который сначала распределяет 
      ресурсы, выполняет с ними какие#то операции, а потом освобождает 
      эти ресурсы
    2 Порой goto позволяет создать более быстрый и короткий код
  Воображаемая дискуссия по поводу goto
    Обычно сторонники модут придумать кейс удобного использования goto,
    а противники также пример плохого использования
  Обработка ошибок и операторы goto
    - Переписать с помощью вложенных операторов if
      Это стандартный, приводимый в учебниках подход к удалению операторов goto
      Может получиться большая вложенность
    - Переписать код с использованием статусной переменной
      (*) также называемой переменной состояния
      создайте переменную, которая будет показывать, не находится ли
        метод в состоянии ошибки.
      такой подход не даст расти вложенности
    - Переписать с помощью try-finally
  Операторы goto и совместное использование кода в блоке else    
    В общем случае написание нового метода — лучший подход   
  Краткий итог основных принципов использования goto
    Использование goto — это вопрос религии
    Моя догма: в современных языках вы легко можете обойтись без goto
  |    
  № 17.4 Перспективы нестандартных управляющих структур
  не актуально


18)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 18 ] Табличные методы
  |    
  № 18.1 Основные вопросы использования табличных методов
  Табличный метод — это схема, позволяющая искать информацию в таблице, а не
    использовать для этого логические выражения, такие как if и case.
  Пример:
    мы можем городить логику из условий или сделать массив или таблицу
      возможных ответов, а мы только вычисляем нужный индекс и выдаем ответ
  Два вопроса применения табличных методов
    1 как будет выполняться поиск записей в таблице
      - прямой доступ
      - индексированный доступ
      - ступенчатый доступ
    2 что хранить в таблице
      - данные
      - ссылку на метод
  |    
  № 18.2 Таблицы с прямым доступом
  Пример определения количества дней в месяце
    можно городить условия на проверку номера месяца и выдачи ответа,
    но куда круче просто записать значения в массив и отдавать по индексу
  Пример со ставками страхования
    страховка зависит от: от возраста, пола, семейного положения и от того,
      курит ли страхователь, если напрямую писать код, получится каша условий
    (*) формируем набор факторов и определяем функцию:
      "rate = rateTable( smokingStatus, gender, maritalStatus, age )"
      функция идет в таблицу и берет значение, скорее многомерный обьект
  Пример гибкого формата сообщения
    например есть огромное колличество вариантов сообщений и мы их просто
    храним и вызываем их вывод обращаясь по номеру
  Подгонка значений ключа
    не всегда можно однозначно взять значение по таблице, если ключ диапазон
    тоесть значения возраста от 0 до 14 типо одно и тоже
    Способы работы с неточным ключем
      1 Продублировать информацию, чтобы использовать ключ напрямую
        берем и просто дублируем данные для диапазона
      2 Преобразовать ключ, чтобы использовать его напрямую
        применяем к параметру нормирующую функцию, например нумеруем диапазоны
      3 Изолируйте преобразование ключа в собственном методе
  |    
  № 18.3 Таблицы с индексированным доступом
  Для больших таблиц надо использовать индекс, как бы оглавление
  Тоесть мы делаем промежуточный массив чтобы в нем хранить адреса в таблице
  |    
  № 18.4 Таблицы со ступенчатым доступом
  Основная идея ступенчатой структуры в том, что записи в таблице 
    соответствуют некоторому диапазону данных, а не отдельным элементам
  (*) пример, мы просто идем по ступенькам и находим нужный диапазон:
  "
    Dim rangeLimit() As Double = { 50.0, 65.0, 75.0, 90.0, 100.0 }
    Dim grade() As String = { ”F”, “D”, “C”, “B”, “A” }
  "
  |    
  № 18.5 Другие примеры табличного поиска
  не актуально


19)  [ Часть 4 ] Операторы
     [ Часть 4 / Глава 19 ] Общие вопросы управления
  |    
  № 19.1 Логические выражения
  Использование true и false в логических проверках
    Используйте неявное сравнение логических величин с true или false
      вместо "while ( (a > b) = true )" пишем "while ( a > b )"
  Упрощение сложных выражений
    - Разбивайте проверки на части с помощью новых логических переменных     
    - Размещайте сложные выражения в логических функциях
    - Используйте таблицы решений для замены сложных условий
  Составление позитивных логических выражений
    - В операторах if заменяйте негативные выражения позитивными, меняя 
        местами блоки if и else
    - Применяйте теоремы Деморгана для упрощения логических проверок 
        с отрицаниями
      Заменяем "if ( !displayOK || !printerOK )" на 
        "if ( !( displayOK && printerOK ) )"
      Таблица преобразований:
        1 not A and not B     -->   not ( A or B )
        2 not A and B         -->   not ( A or not B )
        3 A and not B         -->   not ( not A or B )
        4 A and B             -->   not ( not A or not B )
        5 not A or not B*     -->   not ( A and B )
        6 not A or B          -->   not ( A and not B )
        7 A or not B          -->   not ( not A and B )
        8 A or B              -->   not ( not A and not B )
  Использование скобок для пояснения логических выражений
    - Лучше использовать скобки, если порядок действий не очевиден
    - Заключайте в скобки логическое выражение целиком
  Понимание правил вычисления логических выражений
    пример опасного кусочка:
      "while ( i < MAX_ELEMENTS and item[ i ] <> 0 )"
      если будет вычисляться не лениво то будет проблема с последним элементом      
  Упорядочение числовых выражений соответствии со значениями на числовой прямой
    по порядку слева направо, от наименьших к наибольшим
  Общие принципы сравнения с 0
    - Неявно сравнивайте логические переменные
    - Сравнивайте числа с 0
      Для чисел пишите: "while ( balance != 0 )" а не "while ( balance )"
    - Сравнивайте указатели с NULL
      Для указател: "while ( bufferPtr != NULL ) " а не "while ( bufferPtr )"
  Общие проблемы с логическими выражениями
    - В C'подобных языках, помещайте константы с левой стороны сравнений
      Кажется не удобным и контр интуитивным для Java  
    - В языке Java учитывайте разницу между a==b и a.equals(b) 
  |    
  № 19.2 Составные операторы (блоки)
  - Пишите обе скобки одновременно
    Заполняйте блок после написания двух скобочек
  - Используйте скобки для пояснения условных операторов
    Всегда пищем { } в Java даже для одной строчки
  |    
  № 19.3 Пустые выражения
  - Привлекайте внимание к пустым выражениям
  - Создайте для пустых выражений встроенную функцию DoNothing()
    Так сможите логко находить такие места, или пишите коменты
  - Подумайте, не будет ли код яснее с непустым телом цикла
  |    
  № 19.4 Укрощение опасно глубокой вложенности
  Чрезмерные отступы и вложенность зло, полное зло
  Сводка методик уменьшения глубины вложенности
    - Упростите вложенные if с помощью повторной проверки части условия
    - Упростите вложенные if с помощью блока с выходом
    - Преобразуйте вложенные if в набор if-then-else
    - Преобразуйте вложенные if в оператор case
    - Факторизуйте глубоко вложенный код в отдельный метод
    - Используйте более объектно'ориентированный подход
    - Перепроектируйте глубоко вложенный код
  |    
  № 19.5 Основа программирования: структурное программирование
  Суть структурного программирования состоит в простой идее: 
    программа должна использовать управляющие конструкции с одним входом 
    и одним выходом
  Вы можете читать ее сверху вниз, и практически так же она выполняется
  Три компонента структурного программирования
    - Последовательность
      это набор операторов, выполняющихся по порядку
    - Выбор
      это управляющая конструкция, которая заставляет операторы 
        выполняться избирательно.
    - Итерация
      это управляющая структура, которая заставляет группу операторов 
        выполняться несколько раз
  |    
  № 19.6 Управляющие структуры и сложность
  Одной из единиц измерения «программной сложности» является число 
    воображаемых объектов, которые вам приходится одновременно держать 
    в уме, чтобы разобраться в программе
  Насколько важна сложность?
    Контролируй сложность, уменьшай сложность
  Общие принципы уменьшения сложности
    вы можете уменьшить сложность ваших программ и количество усилий, 
      прилагаемых для их понимания.  
    Как измерить сложность
      например можно считать точками принятия решения, чем больше тем сложнее
    Что делать с этим измерением сложности
      0–5 Этот метод, возможно, в порядке
      6–10 Начинайте думать о способах упрощения метода
      10+ Вынесите часть кода в отдельный метод и вызывайте его


20)  [ Часть 5 ] Усовершенствование кода
     [ Часть 5 / Глава 20 ] Качество ПО
  |    
  № 20.1 Характеристики качества ПО
  внешнии характеристики качества ПО:
    1 Корректность
      отсутствие/наличие дефектов в спецификации, проекте и реализации системы 
    2 Практичность
      легкость изучения и использования системы.
    3 Эффективность
      степень использования системных ресурсов
    4 Надежность
      способность системы выполнять необходимые функции в предопределенных 
        условиях, средний интервал между отказами
    5 Целостность
      ограничение доступа к системе для неавторизованных пользователей     
      одновременное изменение взаимосвязанных данных  
      хранение только допустимых значений 
    6 Адаптируемость
      возможность использования системы без ее изменения в тех областях 
      или средах, на которые она не была ориентирована непосредственно
    7 Правильность
      Правильность характеризует выполнение системой ее функций
    8 Живучесть
      способность системы продолжать работу  
  внутренние характеристики качества ПО:
    1 Удобство сопровождения
      легкость добавления новой функциональности
      повышение быстродействия
      исправление дефектоы
    2 Гибкость
      масштаб изменений для использования в других областях или средах
    3 Портируемость
      легкость изменений для использованию в других средах
    4 Возможность повторного использования
      легкость использования частей системы в других системах
    5 Удобочитаемость
      легкость чтения и понимания исходного кода системы
    6 Тестируемость
    7 Понятность  
  |    
  № 20.2 Методики повышения качества ПО
  - Целевые характеристики качества ПО
    определяем целевые внешние и внутренние характеристики ПО 
  - Явный контроль качества
    нужно всегда следить за качеством ПО
  - Стратегия тестирования
  - Принципы разработки ПО
  - Неформальные технические обзоры
  - Формальные технические обзоры
  - Внешний аудит
  Процесс разработки
    - Процедуры контроля изменений
      Повышению качества ПО часто препятствуют неконтролируемые изменения
      могут приводить к несоответствию кода и требований
      (*) контроль изменений — важнейшее условие для высокого качества ПО 
    - Оценка результатов
    - Прототипирование  
  Задание целей
    Явное задание целевых аспектов качества — простой и очевидный способ
      повышения качества ПО  
  |    
  № 20.3 Относительная эффективность методик контроля качества ПО
  Не все методики контроля качества имеют одинаковую эффективность
  Эффективность обнаружения дефектов
    таблица:
      ----------------------------------------------------
      | Методика                         | Типичная      |
      | устранения дефектов              | эффективность |
      |----------------------------------|---------------|
      | Неформальные                     |     35%       |
      | обзоры проекта                   |               |
      |----------------------------------|---------------|
      | Формальные                       |     55%       |
      | инспекции проекта                |               |
      |----------------------------------|---------------|
      | Неформальные                     |     25%       |
      | обзоры кода                      |               |
      |----------------------------------|---------------|
      | Формальные                       |      60%      |
      | инспекции кода                   |               |
      |----------------------------------|---------------|
      | Моделирование                    |      65%      |
      | или прототипирование             |               |
      |----------------------------------|---------------|
      | Самостоятельная                  |      40%      |
      | проверка кода                    |               |
      |----------------------------------|---------------|
      | Блочное тестирование             |      30%      |
      |----------------------------------|---------------|
      | Тестирование новых               |      30%      |
      | функций (компонентов)            |               |
      |----------------------------------|---------------|
      | Интеграционное                   |      35%      |
      | тестирование                     |               |
      |----------------------------------|---------------|
      | Регрессивное                     |      25%      |
      | тестирование                     |               |
      |----------------------------------|---------------|
      | Тестирование системы             |      40%      |
      |----------------------------------|---------------|
      | Ограниченное бета-тес-           |      35%      |
      | тирование (менее чем             |               |
      | в 10 организациях)               |               |
      |----------------------------------|---------------|
      | Крупномасштабное бета-           |      75%      |
      | тестирование (более чем          |               |
      | в 1000 организаций)              |               |
      |----------------------------------|---------------|
    (*) ВЫВОД: надо комбинировать несколько методик!
  Стоимость нахождения дефектов  
    Некоторые методики обнаружения дефектов дороже других
    Инспекции обходятся дешевле, чем тестирование        
  |    
  № 20.4 Когда выполнять контроль качества ПО?
  Дефекты проникают в ПО на всех стадиях разработки, поэтому 
  контролю качества следует уделять должное внимание на всех этапах проекта
  |    
  № 20.5 Главный Закон Контроля Качества ПО
  Главный Закон Контроля Качества ПО заключается в том, что повышение 
    качества системы снижает расходы на ее разработку
  Самый длительный этап в большинстве проектов — отладка и исправление 
    неправильного кода
  Устранение дефектов на самом деле — самый дорогой и длительный 
    этап разработки ПО
   

21)  [ Часть 5 ] Усовершенствование кода
     [ Часть 5 / Глава 21 ] Совместное конструирование
  |    
  № 21.1 Обзор методик совместной разработки ПО
  - Совместное конструирование дополняет другие методики контроля качества
    Цель - повысить качество ПО
  - Совместное конструирование способствует усвоению корпоративной 
      культуры и обмену опытом программирования
     Обзоры — тот механизм, который создает начинающим и опытным 
       программистам все условия для обсуждения технических вопросов
       (*) мини-демо что мы ввели в сбере это похоже на обзоры
  - Все формы совместного конструирования предполагают совместное 
      владение результатами работы 
    1 повышение качества кода
    2 уход одного из участников не критичен, так как все вместе кодят
    3 возможность ревьюить любому
  - Сотрудничество возможно не только во время конструирования, 
      но и до и после него
  |    
  № 21.2 Парное программирование
  Один кодит другой следит и подсказывает или делает предложения
  Условия успешности парного программирования:
    1 Поддерживайте парное программирование стандартами кодирования
    2 Не позволяйте парному программированию превратиться в наблюдение
    3 Не используйте парное программирование для реализации простых фрагментов
    4 Регулярно меняйте состав пар и назначаемые парам задачи
    5 Объединяйте в пару людей, предпочитающих одинаковый темп работы
    6 Убедитесь, что оба члена пары видят экран 
    7 Не объединяйте в пару людей, которые не нравятся друг другу
    8 Не составляйте пару из людей, которые ранее не программировали в паре
    9 Назначьте лидера группы
  Достоинства парного программирования:
    1 позволяет успешно противостоять стрессу
    2 повышение качества кода
    3 как правило пары пишут быстрее и с меньшим числом ошибок
    4 шаринг знаний
  |    
  № 21.3 Формальные инспекции
  - Каких результатов можно ожидать от инспекций?
    Комбинация инспекций проекта и кода обычно позволяет устранить 80% ошибок
  - Роли участников инспекции
    1 Координатор
    2 Автор
    3 Инспектор
    4 Секретарь
    5 Руководители
  - Общая процедура инспекции
    1 Планирование
    2 Обзор
    3 Подготовка
    4 Инспекционное Собрание
    5 Отчет об инспекции
    6 Исправление дефектов
    7 контроль
    8 Дополнительные соображения
  - Личностные аспекты инспекций
    Инспекция - это именно поиск дефектов
  |    
  № 21.4 Другие методики совместной разработки ПО
  Другие типы совместной разработки исследованы хуже, чем инспекции 
  или парное программирование, поэтому мы рассмотрим их менее подробно.
  - Анализ проекта или кода
    (*) берем проблему или кусок кода и обсуждаем
    1 за проведение анализа обычно отвечает автор проекта или кода
    2 предметом анализа являются технические вопросы
    3 все участники готовятся к анализу
    4 анализ позволяет опытным программистам передавать опыт
    5 главная цель анализа — обнаружение ошибок, а не их исправление
    6 руководители в анализе не участвуют
  - Чтение кода
    (*) читаем исходный код в поисках ошибок
    1 Определяем строки кода, от 1000 до 10 000 строк;
    2 Двое или более разработчиков читают код. 
    3 Участники обзора читают код независимо друг от друга (1000 строк в день)
    4 После того как завершили чтение кода, автор кода проводит собрание
    5 Автор кода исправляет обнаруженные проблемы
  - Презентация
     Цель презентации — показать заказчику, что работа продвигается успешно  
  |    
  № 21.5 Сравнение методик совместного конструирования
    описана дополнительная информация как список книг


22)  [ Часть 5 ] Усовершенствование кода
     [ Часть 5 / Глава 22 ] Тестирование, выполняемое разработчиками
  |    
  № 22.0
  Тестирование — самая популярная методика повышения качества
  Виды тестирования:
    1 Блочным тестирование
      тестирование полного класса, метода или небольшого приложения, 
      написанного одним программистом или группой, выполняемое отдельно 
      от прочих частей системы
    2 Тестирование компонента
      тестирование класса, пакета, небольшого приложения или другого 
      элемента системы
    3 Интеграционное тестирование
      совместное выполнение двух или более классов, пакетов, компонентов 
      или подсистем
    4 Регрессивным тестированием
      называют повторное выполнение тестов, направленное на обнаружение 
      дефектов в программе
    5 Тестирование системы
      выполнение ПО в его окончательной конфигурации, интегрированного 
      с другими программными и аппаратными системами  
    (*) Тестирование обычно разделяют на две обширных категории: 
      - «тестирование методом черного ящика»
      - «тестирование методом белого (прозрачного) ящика»
  |    
  № 22.1 Тестирование, выполняемое разработчиками, и качество ПО
  Тестирование — важная часть любой программы контроля качества, а зачастую 
    и единственная
  По ряду описанных ниже причин большинство разработчиков испытывают при 
    тестировании затруднения
  Важные пунктики:
    1 Цель тестирования противоположна целям других этапов разработки
    2 Тестирование никогда не доказывает отсутствия ошибок
    3 Тестирование не повышает качества ПО 
    4 Тестирование требует, чтобы вы рассчитывали найти ошибки в своем коде
  Тестирование во время конструирования
    Проектировать классы следует так, чтобы они казались черными ящиками
    Однако при тестировании класса выгодно обращаться как с прозрачным ящиком
  |    
  № 22.2 Рекомендуемый подход к тестированию, выполняемому разработчиками
  Систематичный подход к тестированию, выполняемому разработчиками, 
  позволяет находить максимальное число дефектов всех типов при минимуме усилий
  Советы/правила:
    1 Тестируйте программу на предмет реализации каждого существенного 
        требования.
    2 Используя «базисное тестирование», дополните тесты требований и проекта
        детальными тестами
    3 Используйте контрольный список ошибок
    (*) Проектируйте тесты вместе с системой
  Когда создавать тесты?
    - создание тестов до написания кода требует тех же усилий
    - если вы пишете сначала тесты, вы найдете дефекты раньше 
    - предварительное написание тестов заставляет хоть немного задумываться о
        требованиях и проекте до написания кода
    - предварительное написание тестов позволяет найти проблемы в 
        требованиях до написания кода
  Ограничения тестирования, выполняемого разработчиками
    - Разработчики обычно выполняют «чистые тесты»
      Чистые тесты просто подтверждение, что все работает
      (*) надо на один чистый тест создавать 5 грязных
    - Разработчики часто имеют слишком оптимистичное представление о покрытии 
      кода тестами  
    - Разработчики часто упускают из виду более сложные аспекты покрытия 
      кода тестами
  |    
  № 22.3 Приемы тестирования
  Почему невозможно доказать корректность программы, протестировав ее?
    должны были бы протестировать ее со всеми возможными входными 
    значениями и их комбинациями.
    Даже для очень простых программ это нереально
  Неполное тестирование
    На практике искуство тестирования заключается в выборе тестов, 
    способствующих с максимальной вероятностью обнаружить ошибку.
    Нужно найти ряд тестов, покрывающих много функционала
  Структурированное базисное тестирование
    идея: вы должны протестировать каждый оператор программы хотя бы раз
    напряжный подход, тоесть мы покрываем каждый if тестом
  Тестирование, основанное на потоках данных
    Общее
      идея: основанного на потоках данных, в том, что использование данных 
      не менее подвержено ошибкам, чем поток управления.
      Тут фокус на переменных обьектах и работе с памятью
      Тоесть тесты пишутся на кейсы, когда мы как-то работаем с созданием
      переменных, удалением и инициализацией в зависимости от параметров
    Изменения состояния данных
      общие правила как мы работаем с переменными, для Java не интересно
  Разделение на классы эквивалентности
    Если два теста приводят к обнаружению одних и тех же ошибок, вам 
      нужен лишь один из них
    Разделение на классы позволяет избавиться от не нужных тестов 
  Угадывание ошибок
    это примитовное название довольно здравой Идеей  
    мы разрабатываем кейсы исходя из предположений о вероятных ошибок
  Анализ граничных условий
    меньше MAX, MAX, больше MAX  
  Классы плохих данных
     можно тестировать на предмет нескольких других классов плохих данных. 
     Типичными примерами плохих данных можно считать:
     - недостаток данных (или их отсутствие);
     - избыток данных;
     - неверный вид данных (некорректные данные);
     - неверный размер данных;
     - неинициализированные данные
  Классы хороших данных
    При поиске ошибок легко упустить из виду тот факт, что номинальный 
    случай также может содержать ошибку        
  Используйте тесты, позволяющие легко проверить результаты вручную
    круглые цифры могут легко прикинуть ошибку, если она будет в тесте  
  |    
  № 22.4 Типичные ошибки
  Какие классы содержат наибольшее число ошибок?
    80% ошибок содержится в 20% классов или методов проекта 
    обычно 20% методов определяют всю логику ПО, там и надо искать ошибки
  Классификация ошибок
    Распределение:
    - 25,18% Структурные ошибки
    - 22,44% Ошибки в данных
    - 16,19% Ошибки в реализации функциональности
    - 9,88% Ошибки конструирования
    - 8,98% Ошибки интеграции
    - 8,12% Ошибки в функциональных требованиях
    - 2,76% Ошибки в определении или выполнении тестов
    - 1,74% Системные ошибки, ошибки в архитектуре ПО
    - 4,71% Другие ошибки    
    1 Большинство ошибок имеет довольно ограниченную область видимости
    2 Многие ошибки не связаны с конструированием
    3 Как правило, ошибки конструирования лежат на совести программистов  
    4 На удивление распространенной причиной проблем являются опечатки
    5 Довольно часто причиной ошибок является неправильное понимание проекта
    6 Большинство ошибок легко исправить
    7 Оценивайте опыт борьбы с ошибками в своей организации
  Доля ошибок, обусловленных неграмотным конструированием    
    - В небольших проектах дефекты конструирования составляют большинство 
      всех ошибок. 
    - Дефекты конструирования составляют минимум 35% всех дефектов 
      независимо от размера проекта.
    - Хотя ошибки конструирования и дешевле исправлять, чем ошибки выработки
      требований и проектирования, это все равно дорого. 
  Сколько ошибок можно ожидать?
    - Средний для отрасли показатель таков: примерно 1–25 ошибок на 1000
      строк кода
    - и Microsoft сообщает о таких показателях, как 10–20 дефектов на 1000 
      строк кода во время внутреннего тестирования
    - Харлан Миллз придумал «разработку методом чистой комнаты» — методику,
      позволяющую достигнуть всего лишь 3 дефектов на 1000 строк кода во 
      время внутреннего тестирования
    - применяющие методику Team Software Process (TSP), достигают 
      уровня 0,06 дефекта на 1000 строк кода 
  Ошибки самого тестирования
  Ниже дано несколько советов по снижению числа ошибок в тестах
    1 Проверяйте свою работу
      Разрабатывайте тесты так же тщательно, как и код
    2 Планируйте тестирование программы так же, как и ее разработку
      Планирование тестирования следует начинать на этапе выработки требований 
    3 Храните тесты
      Посвятите немного времени проверке качества тестов
    4 Встраивайте блочные тесты в среду тестирования
  |    
  № 22.5 Инструменты тестирования
  Создание лесов для тестирования отдельных классов
    Общее:
      Термин «леса» (scaffolding) пришел в программирование из строительства. 
      Строительные леса создаются для того, чтобы рабочие получили доступ 
      к определенным частям здания. В программировании леса создаются
      исключительно для упрощения тестирования кода
    что обычно делают вспомогательные методы или классы:
      1 немедленно возвращать управление, не выполнив никаких действий;
      2 тестировать полученные данные;
      3 выводить диагностическое сообщение (например, значения входных 
        параметров) на экран или записывать в файл;
      4 запрашивать возвращаемые значения у программиста;
      5 возвращать стандартный ответ независимо от полученных данных;
      6 впустую тратить ресурсы процессора, выделенные реальному объекту 
        или методу;
      7 играть роль более медленной, объемной, простой или менее точной 
        версии реального объекта или метода.
    Другим типом лесов является поддельный метод, вызывающий реальный 
      тестируемый метод. Такой метод, называемый «драйвером» или иногда 
      «тестовой сбруей» (test harness), может:
        1 вызывать объект, передавая ему некоторые данные;
        2 запрашивать информацию у программиста и передавать ее объекту;
        3 принимать параметры командной строки (если ОС это поддерживает) 
          и передавать их объекту;
        4 читать аргументы из файла и передавать их объекту;
        5 вызывать объект несколько раз, передавая ему при каждом вызове 
          новый предопределенный набор входных данных.
    Последний тип лесов, фиктивный файл
  Инструменты сравнения файлов
  Генераторы тестовых данных
    1 Правильно спроектированные генераторы случайных данных способны 
      генерировать комбинации тестовых данных, о которых вы могли 
      бы не подумать.
    2 Генераторы случайных данных могут протестировать программу тщательнее,
      чем вы сами.
    3 Со временем вы можете улучшить случайные тесты, обратив повышенное 
      внимание на реалистичный диапазон входных значений. 
    4 Модульное проектирование сполна окупается во время тестирования.
    5 Вы можете повторно использовать тестовый драйвер даже после изменения
      тестируемого им кода.
  Мониторы покрытия кода тестами
    Надо следить что везде есть тесты
  Регистраторы данных
    Некоторые инструменты могут следить за программой и собирать информацию
    о ее состоянии в случае краха подобно «черному ящику», устанавливаемому 
    в самолетах для определения причин крушения. Эффективная регистрация 
    данных облегчает диагностику ошибок и сопровождение программы после 
    ее выпуска.
  Символические отладчики
    Символический отладчик — это технологическое дополнение анализа и 
    инспекций кода. Отладчик может выполнять код строка за строкой, 
    позволяет следить за значениями переменных и всегда интерпретирует 
    код так же, как компьютер 
  Инструменты возмущения состояния системы
    Многие программисты могут рассказать истории о программах, 
    которые работают 99 раз из 100, но при сотом запуске с теми же данными
    терпят крах  
    Инструментыт тестирования:
      1 Заполнение памяти 
        Иногда память целесообразно заполнять конкретным значением
      2 «Встряхивание» памяти 
        не актуально, типо сделать сдвиг по адресам памяти
      3 Селективный сбой памяти
        Драйвер памяти позволяет имитировать недостаток или неудачный 
        запрос памяти, может отказывать в запросе памяти после
        произвольного числа успешных запросов или предоставлять 
        запрошенную память после произвольного числа неудовлетворенных 
        запросов.
      4 Проверка доступа к памяти (проверка границ)  
        Инструменты проверки границ следят за операциями над указателями, 
        гарантируя их корректность.
  Базы данных для хранения информации об ошибках
    Такого еще не видел, но звучит интересно 
  |    
  № 22.6 Оптимизация процесса тестирования
  Планирование тестирования
    Эффективность тестирования заметно повышается, если его спланировать 
    в самом начале работы над проектом  
  Повторное (регрессивное) тестирование
    Тестирование, призванное гарантировать, что программа не сделала шаг 
    назад, или не «регрессировала», называется «регрессивным».
  Автоматизированное тестирование
    Единственный практичный способ управления регрессивным 
    тестированием — его автоматизация.
  |    
  № 22.7 Протоколы тестирования
  Обеспечить повторяемость процесса тестирования недостаточно — вы
  должны оценивать и проект, чтобы можно было точно сказать, 
  улучшается он в результате изменений или ухудшается
  Какие данные стоит собирать:

1 административное описание дефекта (дата обнаружения, сотрудник, 
  сообщивший о дефекте, номер сборки программы, дата исправления);
2 полное описание проблемы;
3 действия, предпринятые для воспроизведения проблемы;
4 предложенные способы решения проблемы;
5 родственные дефекты;
6 тяжесть проблемы (например, критическая проблема, «неприятная» или 
  косметическая);
7 источник дефекта: выработка требований, проектирование, кодирование или
  тестирование;
8 вид дефекта кодирования: ошибка занижения или завышения на 1, ошибка 
  присваивания, недопустимый индекс массива, неправильный вызов метода и т. д.;
9 классы и методы, измененные при исправлении дефекта;
10 число строк, затронутых дефектом;
11 время, ушедшее на нахождение дефекта;
12 время, ушедшее на исправление дефекта.
Собирая эти данные, вы сможете подсчитывать некоторые показатели, 
  позволяющие сделать вывод об изменении качества проекта:
  1 число дефектов в каждом классе; все числа целесообразно отсортировать в
    порядке от худшего класса к лучшему и, возможно, нормализовать по размеру
    класса;
  2 число дефектов в каждом методе, все числа целесообразно отсортировать в
    порядке от худшего метода к лучшему и, возможно, нормализовать по 
    размеру метода;
  3 среднее время тестирования в расчете на один обнаруженный дефект;
  4 среднее число обнаруженных дефектов в расчете на один тест;
  5 среднее время программирования в расчете на один исправленный дефект;
  6 процент кода, покрытого тестами;
  7 число дефектов, относящихся к каждой категории тяжести


23)  [ Часть 5 ] Усовершенствование кода
     [ Часть 5 / Глава 23 ] Отладка
  |    
  № 23.0
  Отладка — это процесс определения и устранения причин ошибок. 
  Этим она отличается от тестирования, направленного на обнаружение ошибок.
  |    
  № 23.1 Общие вопросы отладки
  Отладка и качество ПО
   - О качестве нужно заботиться с самого начала работы над программой.
   - Лучший способ создания качественной программы заключается в 
     тщательной выработке требований, грамотном проектировании и
     применении высококачественных методик кодирования.
   - Отладка — это средство для крайних случаев   
  Различия в эффективности отладки
    Лучшие программисты обнаружили больше дефектов за меньшее время 
    и исправили их более корректно. Нет нужды выбирать между качеством, 
    стоимостью и быстротой — они идут рука об руку  
  Дефекты как возможности обучения
    Вам не нужно учиться исправлять дефекты — вам нужно знать, как 
    их избегать
    - Изучить программу, над которой работаете
      Наличие дефекта указывает на то, что вы должны лучше изучить 
      программу, потому что, если б вы уже отлично ее знали, в ней 
      не было бы дефектов
    - Изучить собственные ошибки
      Все дефекты вашей программы лежат на вашей совести. 
      Обнаружив ошибку, спросите себя, как и почему вы допустили ее. 
      Как вы могли найти ее быстрее? Как ее можно было предотвратить? 
      Содержит ли код другие подобные ошибки? 
      Можно ли исправить их до того, как они приведут к проблемам?
    - Изучить качество своего кода с точки зрения кого-то, 
        кому придется читать его
    - Изучить используемые способы решения проблем
       Быстро ли вы находите дефекты? 
       Может, ваш подход к отладке неэффективен?
    - Изучить используемые способы исправления дефектов
      Кроме способа поиска дефектов, вы можете изучить и свой способ 
      их исправления
  Неэффективный подход
    Руководство Дьявола по отладке
      1 Поиск дефектов, основанный на гадании
      2 Тщательный анализ проблемы — пустая трата времени
      3 Исправление ошибок самым очевидным образом
  |    
  № 23.2 Поиск дефекта
  Научный метод отладки
    Классический научный:
      1. Сбор данных при помощи повторяющихся экспериментов.
      2. Формулирование гипотезы, объясняющей релевантные данные.
      3. Разработка эксперимента, призванного подтвердить или опровергнуть
         гипотезу.
      4. Подтверждение или опровержение гипотезы.
      5. Повторение процесса в случае надобности.
    Эффективный метод поиска дефекта:
      1. Стабилизация ошибки.
      2. Определение источника ошибки.
        a. Сбор данных, приводящих к дефекту.
        b. Анализ собранных данных и формулирование гипотезы, 
           объясняющей дефект.
        c. Определение способа подтверждения или опровержения гипотезы, 
           основанного или на тестировании программы, или на изучении кода
        d. Подтверждение или опровержение гипотезы при помощи процедуры,
           определенной
      3. Исправление дефекта.
      4. Тестирование исправления.
      5. Поиск похожих ошибок.
    Стабилизация ошибки
      Если дефект проявляется не всегда, его почти невозможно диагностировать
      Перевод несистематического дефекта в разряд предсказуемых — один 
        из самых сложных аспектов отладки.  
    Определение источника ошибки
  Советы по поиску причин дефектов
    Формулируя гипотезу, используйте все имеющиеся данные
    Детализируйте тесты, приводящие к ошибке
    Проверяйте код при помощи блочных тестов
    Используйте разные инструменты
    Воспроизведите ошибку несколькими способами
    Генерируйте больше данных для формулирования большего числа гипотез
    Используйте результаты отрицательных тестов
    Используйте «мозговой штурм» для построения нескольких гипотез
    Составьте список подходов, которые стоит попробовать
    Сократите подозрительную область кода
    С подозрением относитесь к классам и методам, которые содержали 
      дефекты ранее   
    Проверьте код, который был изменен недавно
    Расширьте подозрительный фрагмент кода
    Выполняйте интеграцию инкрементно
    Проверяйте наличие распространенных дефектов
    Обсудите проблему с кем'то другим
    Отдохните от проблемы
    Установите лимит времени для быстрой и грязной отладки
  Синтаксические ошибки
    Не полагайтесь на номера строк в сообщениях компилятора
    Не доверяйте сообщениям компилятора
    Не доверяйте второму сообщению компилятора
    Разделяй и властвуй
    Грамотно ищите неверно размещенные комментарии и кавычки
  |    
  № 23.3 Устранение дефекта
  Прежде чем браться за решение проблемы, поймите ее
  Не ограничивайтесь пониманием проблемы — поймите программу
  Подтвердите диагноз проблемы
  Расслабьтесь
  Сохраняйте первоначальный исходный код
  Устраняйте проблему, а не ее симптомы
  Изменяйте код только при наличии веских оснований
  Вносите в код по одному изменению за раз
  Проверяйте исправления
  Добавляйте в набор тестов блочные тесты, приводящие к проявлению
    имеющихся дефектов
  Поищите похожие дефекты
  |    
  № 23.4 Психологические аспекты отладки
  «Психологическая установка» и слепота при отладке
    вы видите то, что ожидаете увидеть
  «Психологическая дистанция»
    Если дать кому-нибудь длинный список слов и сказать, что все 
    они имеют отношение к уткам, человек может с легкостью перепутать 
    слова «Queck» и «Quack», потому что они кажутся похожими. 
    Психологическая дистанция между ними мала. Гораздо труднее перепутать 
    «Tuack» и «Quack», хотя они тоже различаются только одной буквой
  |    
  № 23.5 Инструменты отладки — очевидные и не очень
  Утилиты сравнения исходного кода
    Утилиты сравнения исходного кода (такие как Diff) полезны
  Предупреждающие сообщения компилятора
    Задайте в компиляторе максимально строгий уровень диагностики и
      устраняйте все ошибки и предупреждения  
    Рассматривайте предупреждения как ошибки
    Стандартизуйте параметры компиляции в масштабе всего проекта
  Утилиты расширенной проверки синтаксиса и логики
    Существуют инструменты, проверяющие код тщательнее, чем компилятор
  Инструменты профилирования выполнения программы
    Исследуйте результаты работы инструмента профилирования, чтобы 
      гарантировать, что каждая часть программы выполняется за разумный 
      интервал времени.        
  Среды тестирования и леса
    выделение проблемного фрагмента кода и его тестирование в изоляции 
      от других фрагментов
  Отладчики
    Хорошие отладчики позволяют полностью исследовать данные, в том 
      числе структурированные и динамически выделенные


24)  [ Часть 5 ] Усовершенствование кода
     [ Часть 5 / Глава 24 ] Рефакторинг
  |    
  № 24.0
  Реальность: во время разработки первоначальной версии системы в код
  вносятся значительные изменения. Многие из изменений во время 
  кодирования не менее масштабны, чем изменения, характерные для
  стадии сопровождения программы
  |    
  № 24.1 Виды эволюции ПО
  Общее:
    Эволюция ПО похожа на биологическую эволюцию тем, что лишь немногие 
    мутации выгодны. При здоровой эволюции кода его развитие напоминает 
    превращение обезьян в неандертальцев, а неандертальцев — в 
    программистов, которые, как известно, являются самыми высокоразвитыми 
    существами на Земле 
  Философия эволюции ПО
    эволюция ПО во время его разработки — неизбежный и важный процесс 
      и спланировав его, вы сможете извлечь из него выгоду
    При необходимости изменения кода старайтесь улучшить его, чтобы 
      облегчить внесение изменений в будущем
  |    
  № 24.2 Введение в рефакторинг
  Разумные причины выполнения рефакторинга
    - Код повторяется
    - Метод слишком велик
    - Цикл слишком велик или слишком глубоко вложен в другие циклы
    - Класс имеет плохую связность
      Если класс имеет множество никак не связанных аспектов 
      ответственности, разбейте его на несколько классов, так чтобы 
      каждый из них получил связный набор аспектов.  
    - Интерфейс класса не формирует согласованную абстракцию
      интерфейс иногда становится монстром, не поддающимся сопровождению 
      и не улучшающим интеллектуальную управляемость программы
    - Метод принимает слишком много параметров
    - Отдельные части класса изменяются независимо от других частей
    - При изменении программы требуется параллельно изменять несколько
        классов
    - Вам приходится параллельно изменять несколько иерархий наследования
    - Вам приходится параллельно изменять несколько блоков case
    - Родственные элементы данных, используемые вместе, не организованы
        в классы 
    - Метод использует больше элементов другого класса, чем своего 
        собственного
    - Элементарный тип данных перегружен
    - Класс имеет слишком ограниченную функциональность
    - По цепи методов передаются бродячие данные
      Данные, передаваемые в метод лишь затем, чтобы он передал 
      их другому методу, называются «бродячими»
    - Объект-посредник ничего не делает
    - Один класс слишком много знает о другом классе
    - Метод имеет неудачное имя
    - Данные-члены сделаны открытыми
    - Подкласс использует только малую долю методов своих предков
    - Сложный код объясняется при помощи комментариев
    - Код содержит глобальные переменные
    - Перед вызовом метода выполняется подготовительный код 
      (после вызова метода выполняется код «уборки»)
    - Программа содержит код, который может когда'нибудь понадобиться
      1 Требования к коду, «проектируемому впрок», не разрабатываются 
        в полном объеме, поэтому программист скорее всего не угадает 
        эти будущие требования. Код, «написанный в расчете на будущее», 
        в итоге придется выбросить 
      2 Программисты, использующие код, который в свое время был 
        «спроектирован впрок», не знают об этом или предполагают, 
        что код лучше, чем есть на самом деле.
      3 Дополнительный код, «проектируемый впрок», создает дополнительную 
        сложность, что приводит к дополнительному тестированию, исправлению 
        дефектов и т. д. Результат — замедление работы над проектом 
  Когда не следует выполнять рефакторинг?
    Целенаправленный процесс изменений может быть эффективной стратегией, 
    обеспечивающей постепенное повышение качества программы при ее 
    сопровождении и предотвращающей всем известную смертельную 
    спираль энтропии ПО, но само по себе изменение достоинств не имеет.      
  |    
  № 24.3 Отдельные виды рефакторинга
  Рефакторинг на уровне данных
    - Замена магического числа на именованную константу
    - Присвоение переменной более ясного или информативного имени
    - Встраивание выражения в код
    - Замена выражения на вызов метода
    - Введение промежуточной переменной
    - Преобразование многоцелевой переменной в несколько одноцелевых 
      переменных
    - Использование локальной переменной вместо параметра
    - Преобразование элементарного типа данных в класс
    - Преобразование набора кодов в класс или перечисление
    - Преобразование набора кодов в класс, имеющий производные классы
    - Преобразование массива в класс
    - Инкапсуляция набора
    - Замена традиционной записи на класс данных 
  Рефакторинг на уровне отдельных операторов
    - Извлечение метода из другого метода
      Превратите фрагмент метода в отдельный метод
    - Встраивание кода метода
    - Преобразование объемного метода в класс
    - Замена сложного алгоритма на простой
    - Добавление параметра
    - Удаление параметра
    - Отделение операций запроса данных от операций изменения данных
    - Объединение похожих методов путем их параметризации
    - Разделение метода, поведение которого зависит от полученных параметров 
    - Передача в метод целого объекта вместо отдельных полей
    - Передача в метод отдельных полей вместо целого объекта
    - Инкапсуляция нисходящего приведения типов
  Рефакторинг реализации классов
    - Замена объектов'значений на объекты'ссылки
    - Замена объектов'ссылок на объекты'значения
    - Замена виртуальных методов на инициализацию данных
    - Изменение положения методов'членов или данных-членов в 
      иерархии наследования
    - Перемещение специализированного кода в подкласс
    - Объединение похожего кода и его перемещение в суперкласс
  Рефакторинг интерфейсов классов
    - Перемещение метода в другой класс
    - Разделение одного класса на несколько
    - Удаление класса
    - Сокрытие делегата
    - Удаление посредника      
    - Замена наследования на делегирование
    - Замена делегирования на наследование
    - Создание внешнего метода
    - Создание класса-расширения
    - Инкапсуляция открытой переменной-члена
    - Удаление методов установки значений неизменяемых полей
    - Сокрытие методов, которые не следует вызывать извне класса
    - Инкапсуляция неиспользуемых методов
    - Объединение суперкласса и подкласса, имеющих очень похожую 
      реализацию  
  Рефакторинг на уровне системы
    - Создание эталонного источника данных, которые вы не можете 
        контролировать    
    - Изменение однонаправленной связи между классами на двунаправленную
    - Изменение двунаправленной связи между классами на однонаправленную
    - Предоставление фабричного метода вместо простого конструктора
    - Замена кодов ошибок на исключения или наоборот
  |    
  № 24.4 Безопасный рефакторинг
  Рефакторинг — эффективный способ повышения качества кода. Но, как и 
  все эффективные инструменты, при неверном использовании он может 
  причинить вред.
  Советы:
    - Сохраняйте первоначальный код
    - Стремитесь ограничить объем отдельных видов рефакторинга
    - Выполняйте отдельные виды рефакторинга по одному за раз
    - Составьте список действий, которые вы собираетесь предпринять
    - Составьте и поддерживайте список видов рефакторинга, которые 
      следует выполнить позже 
    - Часто создавайте контрольные точки
    - Используйте предупреждения компилятора 
    - Выполняйте регрессивное тестирование
    - Создавайте дополнительные тесты
    - Выполняйте обзоры изменений
    - Изменяйте подход в зависимости от рискованности рефакторинга
  Плохие причины выполнения рефакторинга
    - Не рассматривайте рефакторинг как оправдание написания плохого 
      кода с намерением исправить его позднее    
    - Не рассматривайте рефакторинг как способ, позволяющий избежать 
      переписывания кода
  |    
  № 24.5 Стратегии рефакторинга
  Правило 80/20. Тратьте время на 20% видов рефакторинга, 
  обеспечивающих 80% выгоды.
  Советы:
    - Выполняйте рефакторинг при создании новых методов
    - Выполняйте рефакторинг при создании новых классов
    - Выполняйте рефакторинг при исправлении дефектов
    - Выполняйте рефакторинг модулей, подверженных ошибкам
    - Выполняйте рефакторинг сложных модулей
    - При сопровождении программы улучшайте фрагменты, к которым 
      прикасаетесь
    - Определите интерфейс между аккуратным и безобразным кодом и 
        переместите безобразный код на другую сторону этого интерфейса
      Работая с системой, вы можете постепенно перемещать грязный код 
      через «интерфейс между двумя мирами» в более организованный 
      идеальный мир


25)  [ Часть 5 ] Усовершенствование кода
     [ Часть 5 / Глава 25 ] Стратегии оптимизации кода
  |    
  № 25.0
  Оптимизация кода — лишь один из способов повышения производительности
  программы. Часто можно найти другие способы, обеспечивающие большее 
  повышение производительности за меньшее время и с меньшим вредом 
  для кода
  |    
  № 25.1 Общее обсуждение производительности ПО
  Характеристики качества и производительность
    Пользователей больше интересуют явные характеристики программы, 
      а не качество кода.
    Производительность только косвенно связана с быстродействием кода
  Производительность и оптимизация кода
    Решив, что эффективность кода — будь то его быстродействие или 
    объем — должна быть приоритетом, не торопитесь улучшать 
    быстродействие или объем на уровне кода, а рассмотрите 
    несколько вариантов. 
    Подумайте об эффективности в контексте:
    1 Требования к программе
      Прежде чем тратить время на решение проблемы с производительностью, 
      убедитесь, что она действительно требует решения
      Реализация некоторых требовоний может требовать огромных затрат,
      ослабление требований может существенно упростить проект
    2 Проект программы
      Проект программы определяет ее основные черты — главным образом, 
        способ ее разделения на классы. Проект может как облегчить, 
        так и затруднить создание высокопроизводительной системы
      Если объем и быстродействие программы действительно
        важны, разработайте архитектуру так, чтобы она позволяла 
        добиться намеченных показателей, а затем задайте для отдельных 
        подсистем, функций и классов целевые показатели использования 
        ресурсов.
    3 Проекты классов и методов
      Одним из способов повышения производительности на этом уровне
      является выбор типа данных или алгоритма, от чего обычно
      зависит и объем используемой памяти, и быстрота выполнения кода.
    4 Взаимодействие программы с ОС
      Низкая производительность в этом случае может объясняться большим 
      объемом или медленным выполнением методов ОС
    5 Компиляция кода
      Иногда правильный выбор компилятора позволяет вообще забыть 
      о дальнейшей оптимизации кода. 
    6 Оборудование
      покупка нового оборудования
    7 Оптимизация кода
      «Оптимизация» подразумевает внесение небольших изменений, 
      затрагивающих один класс, один метод, 
      а чаще всего — несколько строк кода.
  |    
  № 25.2 Введение в оптимизацию кода
  Общее:
    Это не самый эффективный способ повышения производительности: 
    улучшение архитектуры программы, перепроектирование классов и 
    выбор более эффективного алгоритма обычно приводят к более 
    впечатляющим результатам.
  Принцип Парето
    Принцип Парето, известный также как «правило 80/20», гласит, 
      что 80% результата можно получить, приложив 20% усилий.
    Следствие очевидно: вам нужно найти в коде «горячие точки» 
      и сосредоточиться на оптимизации процентов, используемых более всего.
  Бабушкины сказки
    Популярные заблуждения:
      1 Сокращение числа строк высокоуровневого кода повышает 
        быстродействие или уменьшает объем итогового 
        машинного кода — НЕВЕРНО!
          Это означает, что независимо от эстетической привлекательности 
          компактного кода ничего определенного о связи между числом 
          строк кода на высокоуровневом языке и объемом и быстродействием 
          итоговой программы сказать нельзя.
      2 Одни операции, вероятно, выполняются быстрее или компактнее
        других — НЕВЕРНО!
          Без измерения производительности вы никак не сможете точно 
          узнать, помогли ваши изменения программе или навредили
      3 Оптимизацию следует выполнять по мере написания кода — НЕВЕРНО! 
        - До создания полностью работоспособной программы найти узкие
            места в коде почти невозможно.
        - Если оптимизация выполняется после создания полной 
            системы, разработчики могут определить все проблемные 
            области и их относительную важность, что 
            способствует эффективному распределению времени
        - Концентрация на оптимизации во время первоначальной 
            разработки отвлекает от достижения других целей
      4 Быстродействие программы не менее важно, чем ее 
          корректность — НЕВЕРНО!
    Когда выполнять оптимизацию?
      Написав корректную программу, оцените ее производительность. 
      Если программа громоздка, сделайте ее быстрой и компактной.
      Не оптимизируйте ее, пока не убедитесь, что это на самом
      деле нужно.  
    Оптимизация кода компилятором
      Оптимизирующие компиляторы лучше оптимизируют простой код. 
      Если вы жонглируете индексами циклов и делаете другие 
      «хитрые» вещи, компилятору будет труднее выполнить свою 
      работу, от чего пострадает ваша программа.    
  |    
  № 25.3 Где искать жир и патоку?
  Общее:
    Без профилирования программы вы никогда не сможете с уверенностью 
    сказать, какие фрагменты медленны и огромны, но некоторые операции 
    давно славятся ленью и ожирением, так что вы можете начать
    исследование именно с них
  Частые причины снижения эффективности
    - Операции ввода/вывода
    - Замещение страниц
      Операция, заставляющая ОС заменять страницы памяти,
      выполняется гораздо медленнее, чем операция, ограниченная одной 
      страницей памяти
    - Системные вызовы
      Если вас беспокоит производительность, узнайте, насколько дороги 
        системные вызовы в вашей системе
    - Интерпретируемые языки
      Компилируемый язык в сотни раз быстрее
    - Ошибки
  Относительное быстродействие распространенных операций     
    Слишком не существенная оптимизация
  |    
  № 25.4 Оценка производительности
  Общее:
    Обнаружив горячие точки и оптимизировав их, снова оцените код, 
      чтобы узнать, насколько вы его улучшили
    Если оценка эффективности не оправдывает себя, не стоит приносить 
      понятность кода в жертву сомнительному повышению производительности.
  Оценка должна быть точной
    Используйте инструменты профилирования или системный таймер 
      и методы, регистрирующие истекшее время выполнения операций.
  |    
  № 25.5 Итерация
  Никакие три или даже четыре вида оптимизации не позволили бы мне 
    достичь цели, однако итоговая их комбинация оказалась эффективной. 
    Мораль: если копать достаточно глубоко, можно добиться подчас 
    неожиданных результатов
  |    
  № 25.6 Подход к оптимизации кода: резюме
  Алгоритм:
    1. Напишите хороший и понятный код, поддающийся легкому изменению.
    2. Если производительность вас не устраивает:
      a. сохраните работоспособную версию кода, чтобы позднее вы
         могли вернуться к «последнему нормальному состоянию»;
      b. оцените производительность системы с целью нахождения горячих точек;
      c. узнайте, обусловлено ли плохое быстродействие неадекватным 
         проектом, неверными типами данных или неудачными алгоритмами 
         и определите, уместна ли оптимизация кода; если оптимизация 
         кода неуместна, вернитесь к п. 1;
      d. оптимизируйте узкое место, определенное на этапе (c);
      e. оцените каждое улучшение по одному за раз;
      f. если оптимизация не привела к улучшению кода, вернитесь к коду, 
         сохраненному на этапе (a) (как правило, более чем в половине 
         случаев попытки оптимизации будут приводить лишь к незначительному 
         повышению производительности или к ее снижению).
    3. Повторите процесс, начиная с п. 2.


26)  [ Часть 5 ] Усовершенствование кода
     [ Часть 5 / Глава 26 ] Методики оптимизации кода
  |    
  № 26.0
  То, о чем мы будем говорить в этой главе, возможно, лучше 
  называть «антирефакторингом». Эти изменения ухудшают внутреннуюю 
  структуру программы ради повышения ее производительности. 
  |    
  № 26.1 Логика
  Прекращение проверки сразу же после получения ответа
    Если какая-то проверка не прошла другие не делаем
  Упорядочение тестов по частоте
    Упорядочивайте тесты так, чтобы самый быстрый и чаще всего 
      оказывающийся истинным тест выполнялся первым.
  Сравнение быстродействия похожих структур логики
    В одном из языков case гораздо лучше, чем if-then-else, 
    а в другом наоборот. В третьем языке различие 
    относительно невелико    
  Замена сложных выражений на обращение к таблице
    Иногда просмотр таблицы может оказаться более быстрым, чем 
    выполнение сложной логической цепи. Суть сложной цепи обычно 
    сводится к категоризации чего#то и выполнении того или иного 
    действия, основанного на конкретной категории 
  Отложенные вычисления
    Один из моих бывших соседей любил все откладывать на потом. 
    В оправдание своей лени он говорил, что многое из того, что 
    люди порываются сделать, делать просто не нужно. Если 
    подождать достаточно долго, утверждал он, неважные дела канут 
    в Лету, и он не будет тратить на них свое время
  |    
  № 26.2 Циклы
  Размыкание цикла
    возможно проверки внутри цикла можно вынести наружу
  Объединение циклов
    Если два цикла работают с одним набором элементов, можно 
    выполнить их объединение (jamming).
  Развертывание цикла
    Полное развертывание цикла — быстрое решение, эффективное 
    при малом числе элементов, но оно непрактично, если 
    элементов много или вы не знаете заранее, с каким числом 
    элементов вы будете иметь дело  
  Минимизация объема работы, выполняемой внутри циклов
  Сигнальные значения
    для Java не актуально
  Вложение более ресурсоемкого цикла в менее ресурсоемкий    
    Ключ к улучшению цикла в том, что внешний цикл состоит из 
    гораздо большего числа итераций, чем внутренний  
  Снижение стоимости операций
    Под снижением стоимости (strength reduction) понимают замену 
    дорогой операции на более дешевую, например, умножения на сложение
  |    
  № 26.3 Изменения типов данных
  Использование целых чисел вместо чисел с плавающей запятой
    Сложение и умножение целых чисел, как правило, выполняются 
    быстрее, чем аналогичные операции над числами с плавающей запятой.  
  Использование массивов с минимальным числом измерений
  Минимизация числа обращений к массивам
  Использование дополнительных индексов
    Индекс длины строки
      Примером использования дополнительного индекса может служить 
        одна из форм представления строк  
    Независимая параллельная структура индексации
       Если каждый элемент данных велик, вы можете создать
       вспомогательную структуру, состоящую из ключевых значений и 
       указателей на подробную информацию  
  Кэширование
    это такой способ хранения нескольких значений, при котором
      значения, используемые чаще всего, получить легче, чем значения, 
      используемые реже.    
    Вы можете кэшировать и результаты ресурсоемких вычислений, 
      особенно если их параметры просты.
  |    
  № 26.4 Выражения
  Алгебраические тождества
    Так, следующие выражения логически эквивалентны:
      1 not a and not b
      2 not (a or b)  
  Снижение стоимости операций
    Как уже было сказано, снижение стоимости операций подразумевает 
    замену дорогой операции более дешевой. 
    Вот некоторые возможные варианты:  
      1 замена умножения сложением;
      2 замена возведения в степень умножением;
      3 замена тригонометрических функций их эквивалентами;
      4 замена типа longlong на long или int (следите при этом 
        за аспектами производительности, связанными с применением 
        целых чисел естественной и неестественной длины);
      5 замена чисел с плавающей запятой числами с фиксированной 
        точкой или целые числа;
      6 замена чисел с плавающей запятой с удвоенной точностью 
        числами с одинарной точностью;
      7 замена умножения и деления целых чисел на два операциями сдвига
    Инициализация во время компиляции
      пример:
      "
        const double LOG2 = 0.69314718;
        ...
        unsigned int Log2( unsigned int x ) {
          return (unsigned int) ( log( x ) / LOG2 );
        }  
      "
  Недостатки системных методов
    Например, большинство системных математических методов написаны 
    с тем расчетом, чтобы космонавт, отправившийся на Луну, прилунился 
    с точностью ±2 фута. Если вам не нужна такая точность, нет смысла 
    тратить на нее время.  
  Использование констант корректного типа
    Используйте именованные константы и литералы, имеющие тот же тип, 
    что и переменные, которым они присваиваются. 
  Предварительное вычисление результатов
    На более сложном уровне вы можете вычислить табличные данные один 
      раз при запуске программы и использовать их позднее; вы также 
      можете сохранить результаты в файле данных или встроить их 
      в программу
    Оптимизация программы путем предварительного вычисления выражений 
    имеет несколько вариантов:
      1 вычисление результатов до выполнения программы и связывание 
        их с константами во время компиляции;
      2 вычисление результатов до выполнения программы и присвоение 
        их переменным, используемым в период выполнения;  
      3 вычисление результатов до выполнения программы и сохранение
        их в файле, загружаемом в период выполнения;
      4 однократное вычисление результатов при запуске программы и 
        их использование во всех последующих случаях;
      5 вычисление как можно большего числа значений до начала цикла, 
        позволяющее свести к минимуму объем работы, выполняемой 
        внутри цикла;
      6 вычисление результатов при возникновении первой потребности 
        в них и их сохранение, позволяющее получить результаты, 
        когда они понадобятся снова.
  Устранение часто используемых подвыражений
    Если какое#то выражение повторяется в коде несколько раз, 
      присвойте его значение переменной и используйте переменную 
      вместо вычисления выражения в нескольких местах.  
  |    
  № 26.5 Методы
  Общее:
    Одним из самых эффективных способов оптимизации кода
    является грамотная декомпозиция программы на методы.
    Небольшие, хорошо определенные методы делают програм#
    му компактнее, устраняя повторяющиеся фрагменты кода
  Встраивание методов
    в Java автоматически делается  
  |    
  № 26.6 Переписывание кода на низкоуровневом языке
  Типичный подход к оптимизации при помощи низкоуровневого
  языка таков:
    1. Напишите все приложение на высокоуровневом языке.
    2. Выполните полное тестирование приложения и проверьте его корректность.
    3. Если производительность недостаточна, выполните профилирование 
       приложения с целью выявления горячих точек. Так как около 
       50% времени выполнения программы обычно приходится примерно 
       на 5% кода, горячими точками обычно будут небольшие 
       фрагменты программы.
    4. Перепишите несколько небольших фрагментов на низкоуровневом языке 
       для повышения общей производительности программы.
  |    
  № 26.7  Если что-то одно изменяется, что-то другое всегда 
    остается постоянным
  Есть один хороший способ сопротивления соблазну преждевременной 
  оптимизации и содействия созданию ясного и простого кода: требуйте, 
  чтобы оптимизация приводила к измеримому улучшению.


27)  [ Часть 6 ] Системные вопросы
     [ Часть 6 / Глава 27 ] Как размер программы влияет на конструирование
  |     
  № 27.1 Взаимодействие и размер
  Чем больше путей взаимодействия, тем больше времени вы тратите на 
    общение и тем больше вероятность появления ошибок в процессе 
    взаимодействия. Проекты большего размера требуют принятия 
    организационных мер, которые упорядочивают взаимодействие или 
    существенно его ограничивают.
  |     
  № 27.2 Диапазон размеров проектов
  Поскольку над большими проектами работает больше программистов, 
    чем над маленькими, то в них занят больший процент всех 
    программистов
  табличка:
    Размер команды разработчиков     Примерная доля программистов (в %)
    13                               5%
    410                              10%
    1125                             15%
    2650                             20%
    50+                              50%
  |     
  № 27.3 Влияние размера проекта на возникновение ошибок
  Размер проекта влияет как на количество, так и на тип возникающих 
    ошибок. Вы могли и не предполагать, что тип ошибок также 
    подвержен влиянию, но с ростом размера проекта обычно все больший 
    процент ошибок можно отнести к просчетам в технических требованиях
    и проектировании
  Число ошибок значительно возрастает при увеличении размера проекта,
    и очень большие проекты имеют до четырех раз больше ошибок на 1000 
    строк кода, чем маленькие.
  |     
  № 27.4 Влияние размера проекта на производительность
  С увеличением размера проекта все больше на производительность
    начинают влиять численность команды и организация
  |     
  № 27.5 Влияние размера проекта на процесс разработки
  Соотношение между выполняемыми операциями и размер
    В малых проектах конструирование является наиболее заметной 
      частью проекта: на него приходится до 65% всего времени 
      разработки. В средних по величине проектах конструирование
      все еще доминирует, но его доля снижается до 50% от всех трудозатрат    
    Соотношение между видами деятельности изменяется, потому что при
      разных размерах проекта разные виды деятельности становятся
      критическими
    Далее приведены виды деятельности, затраты на которые с ростом 
    размера проекта увеличиваются нелинейно:
      1 взаимодействие;
      2 планирование;
      3 управление;
      4 разработка требований;
      5 функциональное проектирование системы;
      6 проектирование и спецификация интерфейса;
      7 архитектура;
      8 интеграция;
      9 удаление дефектов;
      10 системное тестирование;
      11 документирование
  Программы, продукты, системы и системные продукты
    Более тонкое воздействие оказывают качество и сложность 
      окончательной версии программного продукта.
  Методология и размер
    В маленьких проектах методология скорее случайна и
    инстинктивна — в больших она скрупулезна и тщательно спланирована    


28)  [ Часть 6 ] Системные вопросы
     [ Часть 6 / Глава 28] Управление конструированием
  |     
  № 28.1 Поощрение хорошего кодирования
  Вопросы внедрения стандартов
    В одних организациях стандарты полезны, в других — не очень
  Технологии поощрения хорошего кодирования
    - Назначьте двух человек на каждую часть проекта
    - Рецензируйте каждую строку кода
    - Введите процедуру подписания кода
    - Распространяйте для ознакомления хорошие примеры кода       
    - Подчеркивайте, что код — это общее имущество
    - Награждайте за хороший код
       1 Награда должна представлять интерес для программиста.
       2 Код, поощряемый таким образом, должен быть исключительно хорошим.
    - Один простой стандарт
  Роль этой книги
    Она не предназначена для оправдания жестких стандартов — используйте 
    ее как повод для дискуссии, источник сведений о хорошей программной 
    практике, а также для поиска таких методик, которые могут дать 
    преимущества в вашей среде программирования        
  |     
  № 28.2 Управление конфигурацией
  - Что такое управление конфигурацией?
    Управление конфигурацией — это практика определения элементов проекта 
      и систематическая обработка изменений таким образом, чтобы система 
      могла поддерживать свою целостность длительное время
    Если вы не контролируете изменения в технических требованиях, это 
      может закончиться написанием кода для тех частей системы, которые 
      в какой#то момент были отменены
  - Изменения в требованиях и проекте
    Советы:
      1 Следуйте систематической процедуре контроля изменений
        Установив систематическую процедуру, вы даете понять, что 
          изменения будут рассмотрены в контексте наибольшей пользы 
          для проекта в целом
      2 Обрабатывайте запросы на изменения группами
        Решение этой проблемы состоит в записи всех идей и предложений 
          (независимо от легкости их реализации) и сохранения их до тех
          пор, пока не появится возможность ими заняться 
      3 Оценивайте затраты на каждое изменение
        Каждый раз, когда ваш заказчик, босс или вы сами намерены 
          изменить систему, оценивайте время, необходимое на внесение 
          изменения, включая рецензирование кода этого изменения и 
          повторное тестирование всей системы.
      4 Относитесь с подозрением к изменениям большого объема
        Некоторое количество изменений неизбежно, но большой объем 
          запросов на изменение сигнализирует о том, что требования, 
          архитектура или высокоуровневое проектирование не были 
          выполнены достаточно качественно, чтобы способствовать 
          эффективному конструированию.
      5 Учредите комитет контроля изменений
        Комитет периодически собирается и рассматривает предложенные 
          изменения. Он одобряет, отвергает или откладывает каждое 
          изменение
      6 Соблюдайте бюрократические процедуры, но не позволяйте страху 
          перед бюрократией препятствовать эффективному контролю изменений
        Контроль изменений имеет тенденцию к бюрократизации, поэтому 
          важно искать способы по рационализации этого процесса
  - Изменения в коде программного обеспечения
    Программы управления версиями
      Контроль версий — необходимая составляющая командных проектов. 
      Он становится еще более мощным оружием при интеграции управления 
      версиями, отслеживания дефектов и управления изменениями   
  - Версии инструментария
    Для некоторых видов проектов может понадобиться реконструкция точной 
      среды, используемой для разработки каждой конкретной версии ПО, 
      включая компиляторы, компоновщики, библиотеки кода и т. д. В этом 
      случае вам также следует поместить эти инструменты в систему 
      управления версиями.    
  - Конфигурации компьютеров
    Стандартная конфигурация позволяет избежать уймы проблем, 
      связанных со слегка различающимися конфигурационными параметрами,
      версиями применяемых инструментов и т. п. Стандартизованный образ 
      диска также сильно упрощает подготовку новой машины по сравнению 
      с необходимостью устанавливать каждую программу отдельно
  - План резервного копирования
    Идея в том, чтобы периодически делать копию вашей работы.
    Завершив проект, создайте его архив. Сохраните в надежном 
      месте копию всего: исходного кода, компиляторов, инструментов, 
      требований, проекта, документации — всего, что может понадобиться 
      для полного воссоздания продукта.
  |     
  № 28.3 Оценка графика конструирования
  Общее:
    При опросах программистов по поводу разницы между ожидаемым 
    и реальным графиками выполнения проекта выяснилось, что 
    разработчики имеют склонность к оптимистичным оценкам в 
    пределах 20-30%
  Подходы к оценке:
    способы:
      - применить оценочное ПО;
      - использовать алгоритмический подход, такой как CocomoII, 
        оценочная модель Барри Бома (Boehm et al., 2000);
      - привлечь внешних экспертов для оценки проекта;
      - обсудить предполагаемые затраты на собрании;
      - оценить составные части проекта, а затем сложить их вместе;
      - предложить каждому оценить их собственные задания, а затем 
        просуммировать полученные предположения;
      - применить опыт предыдущих проектов;
      - сохранить предыдущие оценки и посмотреть, насколько они были 
        аккуратны, а затем применять их для коррекции новых предположений. 
    Определите цели
      Зачем нужна оценка? 
      Что вы оцениваете? 
      Только операции конструирования или весь процесс разработки? 
      Только затраты на проект или на проект плюс отпуска, праздники, 
        обучение и другие мероприятия, не относящиеся к проекту? 
      Насколько аккуратной должна быть оценка, чтобы соответствовать 
        вашим целям? Какую она должна иметь степень достоверности? 
      Приведут ли оптимистичная и пессимистичная оценки к существенно 
        различным результатам?
    Выделите время для оценки
      Скоропалительные оценки неаккуратны. Если вы оцениваете большой 
        проект, рассматривайте процесс оценки как минипроект и выделите 
        время для минипланирования оценки, чтобы хорошо ее выполнить.
    Выясните требования к программе  
      Определите требования или запланируйте подготовительный этап для
        исследований, прежде чем что#то оценивать.
    Делайте оценки на низком уровне детализации
      По закону больших чисел, если на одном большом интервале существует 
        10-я погрешность, ошибка составляет 10% либо в сторону увеличения, 
        либо в сторону уменьшения
    Используйте несколько способов оценки и сравнивайте полученные результаты  
      Дети быстро смекают, что, если попросить третий шарик мороженного 
        у каждого родителя в отдельности, больше шансов услышать хотя бы 
        одно «да», чем если спрашивать только одного родителя.   
    Периодически делайте повторную оценку      
      Время от времени сравнивайте реальные результаты с предполагаемыми 
        и используйте это значение в целях уточнения расчетов для 
        оставшейся части проекта
  Оценка объема работ по конструированию
    Храните сведения об опыте проектов в вашей организации и используйте 
    их для оценки времени, необходимого будущим проектам  
  Факторы влияния на график работ
    Факторы, влияющие на успех программного проекта
      1 Централизованная/распределенная разработка
      2 Размер базы данных
      3 Соответствие документации нуждам проекта
      4 Гибкость, возможная при интерпретации требований
      5 Степень активности в обслуживании рисков
      6 Опыт использования языка и инструментария
      7 Преемственность персонала (текучесть кадров)
      8 Изменчивость платформы
      9 Совершенство процесса
      10 Сложность продукта
      11 Способности программиста
      12 Требуемая надежность
      13 Способности аналитиков по изучению требований
      14 Требования повторного использования
      15 Соответствие приложения современным требованиям
      16 Ограничения хранилища (какая часть 0% 46% доступного 
         пространства будет израсходована)
      17 Сплоченность команды
      18 Опыт команды в данной прикладной области
      19 Опыт команды в работе с данной технологической платформой
      20 Временные ограничения (самого приложения)
      21 Использование специализированных программных инструментов
    А вот факторы, влияние которых на график разработки ПО измерить труднее
      - опыт и способности разработчика требований;
      - опыт и способности программиста;
      - мотивация команды;
      - качество управления;
      - объем кода, использованного повторно;
      - текучесть кадров;
      - изменчивость требований;
      - отношения с заказчиком;
      - участие пользователя в разработке требований;
      - опыт работы заказчика с данным типом приложений;
      - степень участия программистов в разработке требований;
      - обеспечение безопасности компьютера, программ и данных;
      - объем документации;
      - цели проекта (выполнение по графику, качество, удобство 
        использования или какие-то другие возможные цели).
    Оценка или контроль
      Когда у вас есть срок поставки и спецификация продукта, то основная 
        проблема в том, как управлять распределением человеческих и 
        технических ресурсов для своевременной готовности продукта.
    Что делать, если вы отстаете
      Если сроки можно сдвинуть — сдвиньте. В противном случае вы можете 
        принять одно или несколько из следующих решений:
        - Надеяться, что вы сможете наверстать упущенное
          Проекты не восполняют потерянное время позже — они отстают 
            еще больше
        - Увеличить команду
          ввод дополнительных людей на последних стадиях проекта приводит 
            к задержке его выполнения
          большее число работников не обязательно означает больший объем 
            выполненной работы
          Но если задачи делятся на части, вы можете распределить их между 
            разными людьми, даже недавно включившимися в работу
        - Сократить проект
          Если вы исключаете какуюто функцию, вы избавляетесь от 
            проектирования, кодирования, отладки, тестирования и 
            документирования этой функции, а также от создания интерфейса 
            между этой и другими функциями
          При невозможности отмены каких#то функций вы можете представить 
            более дешевую версию той же функциональности
  |     
  № 28.4 измерения
  - Для любого атрибута проекта существует возможность его измерения, 
      что в любом случае не означает отказа от его измерения
    Измерение может быть не абсолютно верным, его может быть
      трудно сделать и, возможно, придется временами уточнять,
      но измерение даст вам такой рычаг управления процессом разработки
      ПО, который вы не сможете получить иным способом  
    Заявления типа «Этот новый метод выглядит более эффективным» 
      недостаточно хороши. 
  - Отдавайте себе отчет о побочных эффектах измерения    
    Выбирайте объекты для измерения осторожно. Люди имеют склонность 
      сосредоточиваться на работе, которая измеряется, и игнорировать
      остальную.
  - Возражать против измерений означает утверждать, что лучше не знать
      о том, что на самом деле происходит
    Измерение предоставляет вам окно, через которое вы можете увидеть 
      хотя бы этот аспект проекта. Окошко может быть маленьким и мутным 
      до тех пор, пока вы не уточните свои измерения, но это все равно 
      лучше, чем не иметь окна вообще. 
  |     
  № 28.5 Гуманное отношение к программистам
  Общее:
    Атмосфера абстрактности в деятельности программистов требует 
      создания непринужденной обстановки в офисе и поддержания 
      широких контактов между коллегами
  Как программисты проводят свое время?
    каждый год тратят на прогулки столько же времени, сколько на
      обучение, втрое больше, чем на чтение технической документации,
      и в шесть раз больше, чем ний этого показателя за прошедшие годы.    
  Различия в производительности и качестве
    Конкретно в программировании многие исследования показывают разницу 
      на порядки в качестве написанных программ, их размерах и в 
      производительности программистов.  
    Индивидуальные различия
      не нашли взаимосвязи между опытом программиста и качеством кода 
        или производительностью
      Программисты различаются между собой на порядки
    Командные различия
      Хорошие программисты стремятся к объединению, так же как и 
        плохие программисты  
  Вопросы религии
    Вопросики:
      1 язык программирования;
      2 стиль отступов;
      3 размещение скобок;
      4 выбор среды разработки (IDE);
      5 стиль комментариев;
      6 компромиссы между эффективностью и читабельностью;
      7 выбор методологии — например, между методом Scrum, 
        экстремальным программированием или эволюционной разработкой;
      8 программные утилиты;
      9 соглашения по именованию;
      10 применение goto;
      11 использование глобальных переменных;
      12 измерения, особенно меры производительности, например, 
         количество строк кода в день.
    Вы вторгаетесь в область, требующую деликатного обращения
    Из уважения к теме используйте термины «предложения» и «советы»
    Старайтесь обходить спорные вопросы, предпочитая давать явные 
      поручения  
    Предложите программистам выработать собственные стандарты
  Физическая среда
    Подводя итоги, можно сказать, что если ваше рабочее место попадает 
      в худшие 25%, вы можете увеличить свою производительность примерно
      на 100%, улучшив его до соответствия первым 25%. Если у вашего 
      рабочего места средние показатели, вы все еще можете получить 
      40%-е увеличение производительности, улучшив его качество 
      до первых 25%.
  |     
  № 28.6 Управление менеджером
  Общее:
    «Управление менеджером» означает, что вам нужно объяснить 
    менеджеру, что надо делать, а не наоборот. Фокус в том, что 
    это надо сделать так, чтобы он продолжал считать, что это он вами 
    управляет. Вот несколько подходов к работе с вашим менеджером:
      1 посейте идеи того, что вы хотите сделать, а затем дождитесь, 
        пока вашего менеджера посетит мысль, что вам нужно делать 
        именно то, что вы хотите; 
      2 просвещайте вашего менеджера, как делать правильно; это 
        непрерывная работа, потому что менеджеров часто повышают, 
        переводят или увольняют;
      3 сосредоточьтесь на интересах менеджера, делая то, что он 
        или она действительно от вас хочет, и не отвлекайте его 
        внимание несущественными деталями реализации 
        (думайте об этом, как об «инкапсуляции» вашей работы);
      4 откажитесь делать то, что говорит ваш менеджер, настаивайте 
        на выполнении работы правильным образом;
      5 найдите другую работу.


29)  [ Часть 6 ] Системные вопросы
     [ Часть 6 / Глава 29] Интеграция
  |
  № 29.0 
  Тема интеграции тесно переплетается с вопросом последовательности 
    конструирования. Порядок, в котором вы создаете классы или компоненты,
    влияет на порядок их интеграции: вы не можете интегрировать то, 
    что еще не было создано. 
  |     
  № 29.1 Важность выбора подхода к интеграции
  Если вы создаете и интегрируете ПО в неправильном порядке, его 
    сложнее кодировать, сложнее тестировать и сложнее отлаживать. 
    Если ничего не работает до того, как заработает все вместе, 
    можно предположить, что проект никогда не будет завершен.
  |     
  № 29.2 Частота интеграции — поэтапная или инкрементная?
  Поэтапная интеграция
    Описание подхода:
      1. «Модульная разработка»: проектирование, кодирование, 
         тестирование и отладка каждого класса.
      2. «Системная интеграция»: объединение классов в одну 
         огромную систему.
      3. «Системная дезинтеграция»: тестирование и отладка всей системы.
    Проблема поэтапной интеграции в том, что, когда классы в 
      системе впервые соединяются вместе, неизбежно возникают 
      новые проблемы и их причины могут быть в чем угодно    
    Поэтому поэтапную интеграцию называют еще «интеграцией 
      большого взрыва»
  Инкрементная интеграция
    При инкрементной интеграции вы пишете и тестируете маленькие 
      участки программы, а затем комбинируете эти кусочки друг 
      с другом по одному.
    По мере того, как вы добавляете новые куски, система разрастается 
      и ускоряется, как разрастается и ускоряется снежный ком, 
      катящийся с горы
  Преимущества инкрементной интеграции
  - Ошибки можно легко обнаружить
    Более того, поскольку вы сталкиваетесь с меньшим числом проблем 
      одновременно, вы уменьшаете риск того, что несколько ошибок будут 
      взаимодействовать или маскировать друг друга.
  - В таком проекте система раньше становится работоспособной
    При инкрементной интеграции программисты раньше видят результаты 
      своей работы, поэтому их моральное состояние лучше, чем в том 
      случае, когда они подозревают, что их проект может никогда 
      не сделать первый вдох 
  - Вы получаете улучшенный мониторинг состояния 
  - Вы улучшите отношения с заказчиком
  - Системные модули тестируются гораздо полнее
  - Вы можете создать систему за более короткое время
  |     
  № 29.3 Стратегии инкрементной интеграции
  Общее:
    Наилучший подход к интеграции меняется от проекта к проекту, 
      и лучшим решением будет то, что будет соответствовать конкретным 
      требованиям конкретного проекта. 
  Нисходящая интеграция
    При нисходящей интеграции класс на вершине иерархии пишется 
      и интегрируется первым. Вершина иерархии — это главное окно, 
      управляющий цикл приложения.
    При нисходящей интеграции интерфейсы между классами нужно задать 
      очень тщательно.
    Нисходящая инкрементная интеграция также позволяет начать 
      кодирование до того, как все детали низкоуровневого проектирования 
      завершены
    Не так редко встречается ситуация, когда низкоуровневая проблема 
      всплывает на самый верх системы, что приводит к высокоуровневым
      изменениям и снижает выгоду от раннего начала работы по интеграции
    Хорошей альтернативой нисходящей интеграции в чистом виде может 
      стать подход с вертикальным секционированием (рис. 29#6). При этом 
      систему реализуют сверху вниз по частям, возможно, по очереди 
      выделяя функциональные области и переходя от одной к другой
  Восходящая интеграция
    При восходящей интеграции вы пишете и интегрируете сначала классы, 
      находящиеся в низу иерархии. Добавление низкоуровневых классов по 
      одному, а не всех одновременно — вот что делает восходящую интеграцию
      инкрементной стратегией.
    Сначала вы пишете тестовые драйверы для выполнения низкоуровневых 
      классов, а затем добавляете эти классы к тестовым драйверам, 
      пристраивая их по мере готовности. Добавляя класс более высокого 
      уровня, вы заменяете классы драйверов реальными.    
    Восходящая интеграция требует, чтобы проектирование всей системы было
      завершено до начала интеграции. 
    Как и нисходящую, восходящую интеграцию в чистом виде используют 
      редко — вместо нее можно применять гибридный подход, реализующий 
      секционную интеграцию
  Сэндвич-интеграция
    Сначала вы объединяете высокоуровневые классы бизнес-объектов 
      на вершине иерархии. Затем добавляете классы, взаимодействующие 
      с аппаратной частью, и широко используемые вспомогательные классы 
      в низу иерархии. Эти высоко- и низкоуровневые классы — хлеб для 
      сэндвича.    
    При сэндвич%интеграции вы сначала объединяете верхний уровень
      и широко используемые классы нижнего уровня, оставив средний 
      уровень напоследок
  Риск-ориентированная интеграция
    Риск-ориентированную интеграцию, которую также называют «интеграцией, 
      начиная с самых сложных частей» (hard part first integration), 
      похожа на сэндвич#интеграцию тем, что пытается избежать проблем, 
      присущих нисходящей или восходящей интеграциям в чистом виде.
    Вы решаете, какие части системы будут самыми трудными, и реализуете 
      их первыми. Опыт показывает, что это относится к интерфейсам 
      верхнего уровня, поэтому они часто присутствуют в начале списка
      рисков.
  Функционально-ориентированная интеграция
    Еще один поход — интеграция одной функции в каждый момент времени. 
      Под «функцией» понимается не нечто расплывчатое, а какое#нибудь 
      поддающееся определению свойство системы, в которой выполняется 
      интеграция. 
    Вы можете использовать стратегии инкрементной интеграции рекурсивно, 
      сформировав сначала из небольших кусков отдельные свойства, а 
      затем инкрементно объединив их в систему
    Обычно процесс начинается с формирования скелета, поскольку он 
      способен поддерживать остальную функциональность
    Основные приемущества:
      1 позволяет обойтись без лесов практически везде, кроме
        низкоуровневых библиотечных классов
      2 каждая новая функция расширяет функциональность.
      3 можно легко провести соответствие между объектами и функциями, 
        что делает функционально#ориентированную интеграцию естественным 
        выбором для объектно#ориентированных систем
  Т-образная интеграция
    При Т-образной интеграции вы создаете и интегрируете вертикальный 
      срез системы, чтобы проверить архитектурные допущения.
      После этого вы создаете и интегрируете основную горизонталь 
      системы, чтобы предоставить каркас для разработки остальной 
      функциональности
  Краткий итог методик интеграции
    вместо того, чтобы безусловно следовать какой#то процедуре, вам 
      придется разработать свою уникальную стратегию, подходящую именно 
      вашему проекту.    
  |     
  № 29.4 Ежедневная сборка и дымовые тесты
  Общее:
    Ежедневно каждый файл компилируется, компонуется и собирается в
      выполняемую программу. После чего прогоняется «дымовой
      тест» — относительно простая проверка, определяющая,
      «дымится» ли продукт во время выполнения
  Советы:
    1 Создавайте сборку ежедневно
    2 Проверяйте правильность сборок
      «Хорошая» сборка должна как минимум:
        - успешно компилировать все файлы, библиотеки и другие компоненты;
        - успешно компоновать все файлы, библиотеки и другие компоненты;
        - не содержать серьезных дефектов, препятствующих запуску 
          программы или делающих ее выполнение непредсказуемым, — иначе 
          говоря, хорошая сборка должна проходить дымовой тест.
    3 Выполняйте дымовые тесты ежедневно
    4 Поддерживайте актуальность дымового теста
    5 Автоматизируйте ежедневную сборку и дымовой тест
    6 Организуйте группу, отвечающую за сборки
    7 Вносите исправления в сборку, только когда имеет смысл это делать…
    8 ...но не откладывайте внесение исправлений надолго
    9 Требуйте, чтобы разработчики проводили дымовое тестирование своего
      кода перед его добавлением в систему   
    10 Создайте область промежуточного хранения кода, который следует
       добавить к сборке
    11 Назначьте наказание за нарушение сборки
    12 Выпускайте сборки по утрам
    13 Создавайте сборку и проводите дымовой тест даже в экстремальных
       условиях 
  Для каких проектов применять ежедневную сборку?
    Полная сборка занимала 19 часов на нескольких машинах, но 
      разработчики Windows 2000 оказались в состоянии проводить сборки 
      каждый день. Они не стали помехой — напротив, команда Windows 2000 
      видит одну из причин успеха в еже-дневных сборках. 
  Непрерывная интеграция
    В средних и больших проектах иногда имеет смысл допустить 
      рассинхронизацию кода на короткое время. Разработчики часто 
      нарушают синхронизацию, когда делают масштабные изменения. Через 
      какое-то время они могут синхронизировать проект снова    


30)  [ Часть 6 ] Системные вопросы
     [ Часть 6 / Глава 30] Инструменты программирования
  |
  № 30.0 
  Если вы не знакомы с каким#то из наиболее полезных инструментов, 
    вы упускаете шанс облегчить себе жизнь
  |
  № 30.1 Инструменты для проектирования
  Средство проектирования позволяет перемещаться между уровнями 
    абстракции. Инструмент проверит целостность проекта, а некоторые 
    могут создавать код на основе разработанного проекта.
  |
  № 30.2 Инструменты для работы с исходным кодом
  Редактирование
    Интегрированные среды разработки (IDE)  
    Поиск и замена строк в нескольких файлах
    Инструменты для сравнения
    Инструменты для слияния
    Программы для украшения исходного кода
    Средства документирования интерфейса
    Шаблоны
      При работе над групповым проектом шаблоны могут стать простым 
        способом достижения согласованного стиля кодирования и 
        документирования
    Средства создания перекрестных ссылок
    Генераторы иерархии классов
    Анализаторы качества кода
    Программы углубленного контроля синтаксиса и семантики
    Генераторы отчетов о метриках
  Рефакторинг исходного кода
    Инструменты для рефакторинга
    Инструменты для реструктуризации
    Трансляторы кода           
  Управление версиями
  Словари данных  
    Так называются базы данных, которые описывают важную для проекта 
      информацию. Во многих случаях словарь связан преимущественно со
      схемами баз данных. В больших проектах такой словарь служит для
      отслеживания сотен или тысяч определений классов
  |
  № 30.3 Инструменты для работы с исполняемым кодом
  Создание кода
    Компиляторы и компоновщики
    Инструменты для сборки
    Библиотеки кода
    Мастера для генерации кода
      Наиболее распространенный недостаток кодовых генераторов в том, 
        что созданный ими код обычно практически нечитаем. Сопровождая 
        такой код, вы можете пожалеть о том, что сразу не написали 
        его вручную.    
    Программы установки
    Препроцессоры
  Отладка
    - предупреждающие сообщения компилятора;
    - тестовые леса;
    - инструменты для сравнения (позволяющие сравнивать различные 
      версии исходных файлов);
    - средства профилирования;
    - мониторы трассировки;
    - интерактивные отладчики — как программные, так и аппаратные.    
  Тестирование
    - автоматизированные системы тестирования, такие 
      как JUnit, NUnit, CppUnit и пр.;
    - автоматизированные генераторы тестов;
    - утилиты для записи и воспроизведения тестовых примеров;
    - мониторы покрытия (анализаторы логики и средства профилирования);
    - символьные отладчики;
    - программы для стрессового тестирования (заполняющие оперативную 
      память, перемешивающие содержимое памяти, генерирующие ошибки 
      при выборочных обращениях к памяти, проверяющие доступ к памяти);
    - средства сравнения (сравнивающие файлы данных, результаты работы 
      программы и экранные изображения);
    - тестовые леса;
    - инструменты для внесения дефектов;
    - ПО для отслеживания дефектов.
  Оптимизация кода
    Средства профилирования
    Ассемблерные листинги и дизассемблеры
  |
  № 30.4 Инструменты и среды
    Языки C и C++, тесно связанные с UNIX, воплощают ту же философию: 
      стандартная библиотека C++ состоит из небольших функций, из
      которых легко сформировать более сложные функции, потому что все 
      они хорошо работают в связке.
  |
  № 30.5 Создание собственного программного инструментария
  Общее:
    потратить 4 часа и 45 минут, лихорадочно создавая утилиту для выполнения  
      работы, а затем за 15 минут сделать работу с помощью этой утилиты.
  Инструментальные средства для отдельного проекта
    вам может понадобиться средство для генерации специальных видов 
      тестовых данных, чтобы проверить качество файлов данных, или 
      программа для эмуляции аппаратной части, которой пока нет в наличии.
  




















 perfect-code-book add new part of summery

  стр 698 в chrome











[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
