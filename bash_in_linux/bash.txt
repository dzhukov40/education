---
Ресурсы:

// оф сайт
- [ http://www.opennet.ru/docs/RUS/bash_scripting_guide/ ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [Shell] это командная оболочка. Но это не просто промежуточное звено 
  между пользователем и операционой системой, это еще и мощный язык 
  программирования. Программы на языке shell называют сценариями, или скриптами. 




1) пишем скриптик, определяющий кто его запустил 
  - [#bashRootMustRun]


2) скрипт с удобным переходом в директорию
  - тудобно вывести ошибку если перейти не удалось
  - [#bashCd]


3) как выводить время и ресурсы затраченные на команду
  - есть команда [ time ]
  - [!] используем ключ формат вывода, но есть особенность, надо указывать
    полный путь до бинарника чтобы работало форматирование 
    - [ -f: command not found ]
    - [ /usr/bin/time -f "- %C \n- %D \n- %E \n- %x " ls -lh ]


4) что означает [ . ] точка в скриптах
  - это может быть указание на текущую директорию
  - показатель что файл является скрымым
  - командой по добавлению текста как директива [ #include ] из [c]
    - пишем строчку [ . <файл> ] аналог [ source <файл> ]
  - в регулярных выражениях это одиночный символ

5) как можно круто использовать перенаправление во вложенных блоках
  - смотрим как элегантно прочитать из файла [#testForvardStream]


6) как работать с переменными в bash скриптах
  - крутой, комплексный пример [#varExample]
  - как произвести текстовую замену в переменной
    [
       a=2334           # переменная
       b=${a/23/BB}     # замена "23" на "BB".
       echo "b = $b"    # b = BB35
    ]
  - Каждый раз, когда запускается командный интерпретатор, для него 
    создаются переменные, соответствующие переменным окружения. Изменение 
    переменных или добавление новых переменных окружения заставляет оболочку 
    обновить свои переменные, и все дочерние процессы (и команды, исполняемые 
    ею) наследуют это окружение.
    - [*] экспортирует переменную, делая ее доступной дочерним процессам [ export <переменная> ]


7) Завершение и код завершения
  - Каждая команда возвращает код завершения (иногда код завершения называют 
    возвращаемым значением ). В случае успеха команда должна возвращать 0, а 
    в случае ошибки -- ненулевое значение, которое, как правило, интерпретируется 
    как код ошибки (число в диапазоне 0 - 255).
    - [*] Когда работа сценария завершается командой exit без параметров, 
      то код возврата сценария определяется кодом возврата последней 
      исполненной командой.
      - [*] переменная [ $? ] хранит возвращаемое значение последней команды


8) Проверка условий. Глава 7. Проверка условий
  - Оператор if/then проверяет -- является ли код завершения списка 
    команд 0 (поскольку 0 означает "успех"), и если это так, то выполняет 
    одну, или более, команд, следующие за словом then. [#ifExtention]
  - есть утилита проверки истинности [ test ]
    - [ test 1 -eq 1 ; echo $? ] вывод 0
    - [ test 1 -eq 2 ; echo $? ] вывод 1
  - [*] прикол в том что сделали синоним утилиты [test] в виде кавычки [ [ ]
    - [ [ 1 -eq 1 ] ; echo $? ] вывод 0
    - [ [ 1 -eq 2 ] ; echo $? ] вывод 1
  - [*] [расширенный вариант команды test]
    Конструкция [[ ... ]] более предпочтительна, нежели [ ... ], 
    поскольку поможет избежать некоторых логических ошибок. Например, 
    операторы &&, ||, < и > внутри [[ ]] вполне допустимы, в то время 
    как внутри [ ] порождают сообщения об ошибках.
  - [*] Круглые скобки (( ... )) и предложение let ... так же возвращают код 0, 
    если результатом арифметического выражения является ненулевое значение. 
    Таким образом, арифметические выражения могут учавствовать в операциях сравнения.
    - [ ((4 - 4)) ; echo $? ] вывод 0
    - [ ((4 + 4)) ; echo $? ] вывод 1
    - [*] посмотри на [ man let ]
  - [*] есть просто огромное количество ключей для различных проверок файлов


9) Глава 8. Операции и смежные темы
  - [ = ]   присвоение или сравнение
  - [ ** ]  возведение в степень
  - [ , ]   пишим несколько выражений
  - есть все побитовые и логические операторы из [ C ]
    - Bash производит проверку кода возврата КАЖДОГО из операндов в логических выражениях.
  - [*] Целые числа в Bash фактически являются знаковыми длинными целыми (32-бит), 
    с диапазоном изменений от -2147483648 до 2147483647. Если в результате какой 
    либо операции эти пределы будут превышены, то результат получится ошибочным
  - [*] Bash ничего не знает о существовании чисел с плавающей запятой. Такие 
    числа, из-за наличия символа десятичной точки, он воспринимает как строки.
    - есть какой-то хитрый калькулятор [ dc ]
  - числовые константы:
    - Интерпретатор командной оболочки воспринимает числа как десятичные
    - Числа, начинающиеся с символа 0, считаются восьмеричными
    - если числу предшествует префикс 0x, то число считается шестнадцатиричным. 
    - Число, в записи которого присутствует символ #, расценивается как запись 
      числа с указанием основы счисления в виде ОСНОВА#ЧИСЛО. [ let "bin = 2#1101" ]
      - [*] диапазоне основ счисления (от 2 до 64)


10) Глава 9. К вопросу о переменных
  - внутренние переменные
    - [ $BASH ] путь к исполняемому файлу Bash
    - [ $BASH_VERSINFO[n] ] это массив, состоящий из 6 элементов, и 
      содержащий информацию о версии Bash. 
    - [ $GROUPS ] группы, к которым принадлежит текущий пользователь
      - то список групп (массив) идентификационных номеров групп для текущего 
        пользователя, как эо записано в /etc/passwd.
      - [ echo $GROUPS ] и [ echo ${GROUPS[1]} ]
    - [ $PATH ] Когда командный интерпретатор получает команду, то он
      автоматически пытается отыскать соответствующий исполняемый файл в 
      указанном списке каталогов (в переменной $PATH). 
      - Инструкция [ PATH=${PATH}:/opt/bin ] добавляет каталог [ /opt/bin] в 
        конец текущего пути поиска.
    - [ $PPID ] Переменная $PPID хранит PID (идентификатор) родительского процесса.
    - [ $UID ] UID (идентификатор) текущего пользователя, в соответствии с [/etc/passwd]
      - [*] Это реальный UID текущего пользователя, даже если он временно приобрел 
        права другого пользователя с помощью su.
    - [ $PWD ] хранит рабочий каталог, хранит вывод [ $pwd ]
    - [ $REPLY ] переменная по-умолчанию, куда записывается ввод пользователя, 
      выполненный с помощью команды read если явно не задана другая переменная.
    - [ $SECONDS ] Время паботы сценария в секундах.
    - [ $TMOUT ] Если переменная окружения $TMOUT содержит ненулевое значение, 
      то интерпретатор будет ожидать ввод не более чем заданное число секунд
    - аргументы:
      - [ $0, $1, $2 ] аргументы передаются... из командной строки в сценарий, 
        функциям или команде set
      - [ getopts ] это мощный механизм позволяющий работать с ключами
      - [ $# ] количество аргументов командной строки
      - [ $* ] Все аргументы в виде одной строки (слова)
      - [ $@ ] То же самое, что и $*, но при этом каждый 
        параметр представлен как отдельная строка (слово)
      - [ $- ] Список флагов, переданных сценарию (командой set).
    - [ $! ] PID последнего, запущенного в фоне, процесса
    - [ $_ ] Специальная переменная, содержит последний аргумент предыдущей команды.
    - [ $? ] Код возврата команды, функции или скрипта
    - [ $$ ] PID самого процесса-сценария.
  - Работа со строками
    - определение длины строки
      - [
           #!/bin/bash

           myString="hello"
           len=${#myString}
           echo "$len"
        ]
    - извлечение подстроки
      - [ ${string:position} ] Извлекает подстроку из [$string], начиная 
        с позиции [$position].
      - [ ${string:position:length} ] Извлекает [$length] символов из [$string],
        начиная с позиции [$position].
      - [ match "abcABC123ABCabc" '.*\([A-C][A-C][A-C][a-c]*\)' ] Находит и 
        извлекает первое совпадение 
      - [ ${string#substring} ] Удаление самой короткой, из найденных, подстроки
      - [ ${string%substring} ] Удаление самой короткой, из найденных, подстроки
        - [*] Поиск ведется с конца строки
      - [ ${string##substring} ] Удаление самой длинной, из найденных, подстроки
      - [ ${string%%substring} ] Удаление самой длинной, из найденных, подстроки
        - [*] Поиск ведется с конца строки
    - Замена подстроки
      - [ ${string/substring/replacement} ] Замещает первое вхождение [ $substring ] 
        строкой [$replacement].
      - [ ${string/substring/replacement} ] Замещает все вхождения [ $substring ] 
  - Подстановка параметров
    - [ ${parameter-default} ] Если параметр отсутствует, то используется 
      значение по-умолчанию.
    - [ ${parameter+alt_value} ] Если параметр имеет какое либо значение, то 
      используется [alt_value], иначе -- [null] ("пустая" строка).
    - [ ${parameter?err_msg} ] Если parameter инициализирован, то используется его 
      значение, в противном случае -- выводится [err_msg].
    - [ ${var#Pattern} ${var##Pattern} ] Удаляет из переменной $var наименьшую/наибольшую 
      подстроку, совпадающую с шаблоном [$Pattern]. Поиск ведется с начала строки [$var].
    - [ ${var:pos} ] Подстанавливается значение переменной var, начиная с позиции pos.
    - [ ${var:pos:len} ] Подстанавливается значение переменной var, начиная с позиции pos, 
      не более len символов. 
    - [ ${var/Pattern/Replacement} ] Первое совпадение с шаблоном Pattern, в переменной 
      var замещается подстрокой Replacement.
    - [ ${var//Pattern/Replacement} ]  Все найденные совпадения с шаблоном Pattern, 
      в переменной var, будут замещены подстрокой Replacement.
  - Объявление переменных: declare и typeset
    - Инструкции declare и typeset являются встроенными инструкциями (они абсолютно 
      идентичны друг другу и являются синонимами) и предназначена для наложения 
      ограничений на переменные. Это очень слабая попытка контроля над типами, которая 
      имеется во многих языках программирования. Инструкция declare появилась в Bash, 
      начиная с версии 2.
  - Косвенные ссылки на переменные
    - Предположим, что значение одной переменной -- есть имя второй переменной. 
      Возможно ли получить значение второй переменной через обращение к первой? 
      Например, Пусть [a=letter_of_alphabet] и [letter_of_alphabet=z], тогда вопрос 
      будет звучать так: "Возможно ли получить значение [z], обратившись к 
      переменной [a]?". В действительности это возможно и это называется косвенной 
      ссылкой. Для этого необходимо прибегнуть к несколько необычной 
      нотации [eval var1=\$$var2].
  - $RANDOM: генерация псевдослучайных целых чисел
    - внутренняя функция Bash (не константа), которая возвращает псевдослучайные целые 
      числа в диапазоне 0 - 32767. Функция $RANDOM не должна использоваться для генераци 
      ключей шифрования.
  - Двойные круглые скобки
    - Эта конструкция во многом похожа на инструкцию let, внутри ((...)) вычисляются 
      арифметические выражения и возвращается их результат. В простейшем случае, 
      конструкция a=$(( 5 + 3 )) присвоит переменной "a" значение выражения "5 + 3", 
      или 8. Но, кроме того, двойные круглые скобки позволяют работать с переменными 
      в стиле языка C.


11) Глава 10. Циклы и ветвления
  - [*] Стандартное устройство ввода [stdin], для цикла [while], можно перенаправить на файл 
    с помощью команды перенаправления < в конце цикла.
  - [*] как внешний, так и внутренний циклы могут быть прерваны командой [break] или
    прервана текущая итерация [continue].
  - [for]
    - На каждом проходе цикла, переменная-аргумент цикла arg последовательно, одно за 
      другим, принимает значения из списка list.
      [
        for arg in [list]
        do
          команда(ы)...
        done
      ]
    - Есл ключевое слово do находится в одной строке со словом for, то после списка 
      аргументов (перед do) необходимо ставить точку с запятой.
      - [ for arg in [list] ; do ]
    - Оператор цикла for имеет и альтернативный синтаксис записи -- очень похожий на 
      синтаксис оператора for в языке C. Для этого используются двойные круглые скобки.
      - [
          LIMIT=10

          for ((a=1; a <= LIMIT ; a++))  # Двойные круглые скобки и "LIMIT" без "$".
          do
            echo -n "$a "
          done                           # Конструкция заимствована из 'ksh93'.
        ]
  - [while]
    - Оператор while проверяет условие перед началом каждой итерации и если условие 
      истинно (если код возврата равен 0), то управление передается в тело цикла.
      - 
        [
           while [condition]
           do
             command...
           done
        ]
      - Как и в случае с for, цикл while может быть записан в C-подобной нотации, 
        с использованием двойных круглых скобок
        [
           while (( a <= LIMIT ))   # В двойных скобках символ "$" перед переменными опускается.
           do
             echo -n "$a "
             ((a += 1))   # let "a+=1"
             # Двойные скобки позволяют наращивание переменной в стиле языка C.
           done
        ]
  - Операторы выбора
    - [ case (in) / esac ]
      - [*] Каждая строка с условием должна завершаться правой (закрывающей) круглой скобкой ).
      - [*] Каждый блок команд, отрабатывающих по заданному условию, должен завершаться двумя 
        символами точка-с-запятой ;;.
      - [*] Блок case должен завершаться ключевым словом esac (case записанное в обратном порядке).
      - [
           case "$variable" in

           "$condition1" )
             command...
           ;;

           "$condition2" )
             command...
           ;;

           esac
        ]
    - [ select ] Оператор select является еще одним инструментом, используемым при создании меню.
      - 
        [
          #!/bin/bash

          select vegetable in "бобы" "морковь" "картофель" "лук" "брюква"
          do
            echo
            echo "Вы предпочитаете $vegetable."
            echo ";-))"
            echo
            break  # если 'break' убрать, то получится бесконечный цикл.
          done
        ]


12) Глава 11. Внутренние команды
  - Внутренняя команда -- это команда, которая встроена непосредственно в Bash. Команды 
    делаются встроенными либо из соображений производительности -- встроенные команды 
    исполняются быстрее, чем внешние, которые, как правило, запускаются в дочернем процессе, 
    либо из-за необходимости прямого доступа к внутренним структурам командного интерпретатора.
    - [ printf ] форматированный вывод [ printf "%s %s \n" $Message1 $Message2 ]
    - [ read ] "Читает" значение переменной с устройства стандартного ввода -- stdin, в 
      интерактивном режиме это означает клавиатуру. Ключ -a позволяет записывать значения в массивы
      [
         #!/bin/bash

         echo -n "дите значение переменной 'var1': "
 
         read var1
         # Обратите внимание -- перед именем переменной отсутствует символ '$'.

         echo "var1 = $var1"
      ]
      - Чтение командой read из файла через перенаправление
        [
           while read line
           do
             echo "$line"
           done <data-file
        ]
    - [ let ] Команда let производит арифметические операции над переменными. 
    - [ eval ] Транслирует список аргументов, из списка, в команды.
    - [ set / unset ] Команда set изменяет значения внутренних переменных сценария. Она может 
      использоваться для переключения опций (ключей, флагов), определяющих поведение скрипта. 
      Еще одно применение -- сброс/установка позиционных параметров (аргументов), значения 
      которых будут восприняты как результат работы команды (set `command`).
    - [ export ] экспортирует переменную, делая ее доступной дочерним процессам.
    - [ source, . (точка) ] Когда эта команда вызывается из командной строки, то это приводит к 
      запуску указанного сценария. Внутри сценария, команда source file-name загружает файл file-name. 
      Таким образом она очень напоминает директиву препроцессора языка C/C++ -- "#include". Может 
      найти применение в ситуациях, когда несколько сценариев пользуются одним файлом с данными или 
      библиотекой функций.
    - [ exit ] Безусловное завершение работы сценария. Команде exit можно передать целое число, 
      которое будет возвращено вызывающему процессу как код завершения.
    - [ exec ] Это встроенная команда интерпретатора shell, заменяет текущий процесс новым процессом, 
      запускаемым командой exec. Обычно, когда командный интерпретатор встречает эту команду, то он 
      порождает дочерний процесс, чтобы исполнить команду. При использовании встроенной команды exec, 
      оболочка не порождает еще один процесс, а заменяет текущий процесс другим. Для сценария это 
      означает его завершение сразу после исполнения команды exec. По этой причине, если вам встретится 
      exec в сценарии, то, скорее всего это будет последняя команда в сценарии.
    - [ true ] Команда возвращает код завершения -- ноль, или успешное завершение
    - [ false ] Возвращает код завершения, свидетельствующий о неудаче
  - Команды управления заданиями
    - [ jobs ] Выводит список заданий, исполняющихся в фоне.
      - [*] Задания и процессы легко спутать. Некоторые внутренние команды, такие как kill, disown 
        и wait принимают в качестве параметра либо номер задания, либо номер процесса. Команды fg, 
        bg и jobs принимают только номер задания.
    - [ disown ] Удаляет задание из таблицы активных заданий командной оболочки.
    - [ fg, bg ] Команда fg переводит задание из фона на передний план. Команда bg перезапускает 
      приостановленное задание в фоновом режиме. Если эти команды были вызваны без указания номера 
      задания, то они воздействуют на текущее исполняющееся задание.
    - [ wait ] Останавливает работу сценария до тех пор пока не будут завершены все фоновые задания 
      или пока не будет завершено задание/процесс с указанным номером задания/PID процесса. Возвращает 
      код завершения указанного задания/процесса.
    - [ suspend ] Действует аналогично нажатию на комбинацию клавиш Control+-Z, за исключением того, 
      что она приостанавливает работу командной оболочки.
    - [ logout ] Завершает сеанс работы командной оболочки, можно указать необязательный код завершения.
    - [ kill ] Принудительное завершение процесса путем передачи ему соответствующего сигнала
      - [*] Команда kill -l выведет список всех сигналов.
    - [ enable ] Либо запрещает, либо разрешает вызов внутренних команд. Например, enable -n kill 
      запрещает использование внутренней команды kill, в результате, когда интерпретатор встретит 
      команду kill, то он вызовет внешнюю команду kill, т.е. /bin/kill.


13) Глава 12. Внешние команды, программы и утилиты
  - простые команды:
    - [ ls ] Команда вывода "списка" файлов.
      - есть bash обертка [ ll ]
      - с ключом [-R], рекурсивный обход дерева каталогов
      - [-S] -- сортировка по размеру файлов
      - [-t] -- сортировка по времени последней модификации файла
    - [ cat ] это акроним от concatenate, выводит содержимое списка файлов на stdout.
      - [*] Для объединения файлов в один файл может использоваться в комбинации с операциями 
        перенаправления (> или >>).
        [ cat filename cat file.1 file.2 file.3 > file.123 ]
      - [-n] ключ вставляет порядковые номера строк в выходном файле.
      - [-b] нумерут только не пустые строки.
      - [-s] заменяет несколько пустых строк, идущих подряд, одной пустой строкой.
      - [*] утилита [ tac ] выводит содержимое файлов в обратном порядке, от последней строки к первой.
      - [*] утилита [ rev ] Команда rev сохраняет порядок следования строк, но переворачивает каждую строку задом наперед.
    - [ cp ] Команда копирования файлов.
      - [-r] выполняет копирование дерева каталогов.
    - [ mv ] Команда перемещения файла. Эквивалентна комбинации команд [cp] и [rm].
      - [-f] этот ключ подавляет запрос подтверждения
    - [ rm ] Удаляет (remove) файл(ы). Ключ -f позволяет удалять даже файлы ТОЛЬКО-ДЛЯ-ЧТЕНИЯ и 
      подавляет запрос подтверждения на удаление.
      - [-r] удаляет все файлы в подкаталогах.
    - [ rmdir ] Удаляет каталог. Удаляемый каталог не должен содержать файлов, включая "скрытые файлы"
    - [ mkdir ] Создает новый каталог.
      - [-p] позволяет создавать промежуточные родительские каталоги.
    - [ chmod ] Изменяет атрибуты существующего файла
    - [ ln ] Создает ссылку на существующий файл.
      - [-s] создает символическую, или "мягкую" (symbolic или "soft") ссылку.
      - [ ln -s oldfile newfile ] создает ссылку, с именем newfile, на существующий файл oldfile, .
    - [ man, info ] Команды доступа к справочным и информационным страницам по системным командам и 
      установленным программам и утилитам. Как правило, страницы info содержат более подробную 
      информацию, чем man.
  - Более сложные команды:
    - [ find ] поиск))
      - [ -exec COMMAND \; ] Для каждого найденного файла, соответствующего заданному шаблону поиска, 
        выполняет команду COMMAND. Командная строка должна завершаться последовательностью символов \;
      - [ -name '*.txt' ] найти файлы с определенным именем
      - [ -mtime 1 ] найти файлы, которые изменялись в течение последних суток.
    - [ xargs ] Команда передачи аргументов указанной команде. Она разбивает поток аргументов на отдельные 
      составляющие и поочередно передает их заданной команде для обработки. Эта команда может рассматриваться 
      как мощная замена обратным одиничным кавычкам.
    - [ expr ] Универсальный обработчик выражений: вычисляет заданное выражение (аргументы должны отделяться 
      пробелами). Выражения могут быть арифметическими, логическими или строковыми.
      - [ expr 3 + 5 ] возвратит 8
      - [ expr 5 \* 3 ] возвратит 15
      - [  b=`expr $a match [0-9]*` ] можем посмотреть совпадает ли паттерн ( math == : )
  - Команды для работы с датой и временем
    - [ date ] выводит дату и время на стандартное устройство вывода stdout.
    - [ zdump ] Отображает время для указанной временной зоны.
    - [ time ] Выводит подробную статистику по исполнению некоторой команды.
      - [ time ls -l ] выведет затраченное время на выполнение
    - [ at ] используется для запуска заданий в заданное время. В общих чертах она напоминает [crond], 
      однако, [at] используется для однократного запуска набора команд.
    - [ batch ] Команда управляющая запуском заданий, напоминает команду [at], но запускает список команд 
      только тогда, когда загруженность системы упадет ниже [.8]. 
    - [ sleep ] Приостанавливает исполнение сценария на заданное количество секунд, ничего не делая.
      - есть в микросекундах [usleep]
  - Команды обработки текста:
    - [ sort ] Сортирует содержимое файла, часто используется как промежуточный фильтр в конвейерах.
    - [ tsort ] Топологическая сортировка, считывает пары строк, разделенных пробельными символами,
      и выполняет сортировку, в зависимости от заданного шаблона.
    - [ uniq ] Удаляет повторяющиеся строки из отсортированного файла.
    - [ expand, unexpand ] преобразует символы табуляции в пробелы и наоборот. 
    - [ cut ] Предназначена для извлечения отдельных полей из текстовых файлов.
      Напоминает команду print [$N] в [awk]
    - [ paste ] Используется для объединения нескольких файлов в один многоколоночный файл.
    - [ join ] Эта мощная утилита позволяет объединять два файла по общему полю, что представляет
      собой упрощенную версию реляционной базы данных.
    - [ head ] Выводит начальные строки из файла на stdout (по-умолчанию -- 10 строк, но это число можно задать иным).
    - [ tail ] Выводит последние строки из файла на stdout (по-умолчанию -- 10 строк). Обычно используется для
      мониторинга системных журналов. Ключ -f, позволяет вести непрерывное наблюдение за добавляемыми 
      строками в файл.
    - [ grep ] Многоцелевая поисковая утилита, использующая регулярные выражения.
    - [ look ] Команда look очень похожа на [grep], и предназначена для поиска по "словарям" -- отсортированным 
      файлам. По-умолчанию, поиск выполняется в файле [/usr/dict/words], но может быть указан и другой словарь.
    - [ sed ] Неинтерактивный "потоковый редактор". Широко используется в сценариях на языке командной оболочки.
    - [ awk ] Утилита контекстного поиска и преобразования текста, замечательный инструмент для извлечения 
      и/или обработки полей (колонок) в структурированных текстовых файлах. Синтаксис awk напоминает язык C.
    - [ wc ] счетчик слов в файле или в потоке (слов символов строк)
    - [ tr ] Замена одних символов на другие.
    - [ fold ] Выравнивает текст по ширине, разрывая, если это необходимо, слова. Особый интерес представляет 
      ключ [-s], который производит перенос строк по пробелам, стараясь не разрывать слова.
    - [ pr ] Подготовка файла к печати. Утилита производит разбивку файла на страницы, приводя его в вид 
      пригодный для печати или для вывода на экран.
  - Команды для работы с файлами и архивами:
    - [ tar ] Стандартная, для UNIX, утилита архивирования.
      - [-c] создать (create) новый архив
      - [-x] извлечь (extract) файлы из архива
    - [ rpm ] Red Hat Package Manager, или [rpm] -- набор утилит, предназначенных для построения и 
      обслуживания пакетов программного обеспечения как в исходном коде, так и в собранном (откомпилированном) 
      виде. Среди всего прочего, включает в себя утилиты, производящие установку ПО, проверку зависимостей 
      пакетов и проверку их целостности.
      - простой способ установить пакет [ rpm -i package_name.rpm ]
    - [ gzip ] Стандартная GNU/UNIX утилита сжатия, заменившая более слабую, и к тому же проприетарную, 
      утилиту [compress]. Соответствующая утилита декомпрессии (разжатия) -- [gunzip], которая является 
      эквивалентом команды [gzip -d].
    - [ file ] Утилита идентификации файлов.
    - [ which ] Очень полезна для того, чтобы узнать -- установлена ли та или иная утилита в системе.
    - [ whereis ] вернет полный путь к команде
    - [ locate ] оманда locate определяет местонахождение файла, используя свою базу данных, создаваемую 
      специально для этих целей.
    - [ diff ] очень гибкая утилита сравнения файлов.
    - [ patch ] гибкая утилита для "наложения заплат". С помощью файла различий, сгенерированного 
      утилитой [diff], утилита patch может использоваться для обновления устаревших версий файлов. 
      Это позволяет распространять относительно небольшие "diff"-файлы вместо целых пакетов.
    - [ cmp ] это упрощенная версия [diff].
    - [ basename ] Выводит только название файла, без каталога размещения.
    - [ dirname ] выводит только путь к файлу.
    - [ split ] Утилита разбивает файл на несколько частей.
    - [ sum, cksum, md5sum ] Эти утилиты предназначены для вычисления контрольных сумм.
    - [ make ] Утилита для компиляции и сборки программ. Но может использоваться для выполнения любых 
      других операций, основанных на анализе наличия изменений в исходных файлах.
      - [*] Команда make использует в своей работе Makefile, который содержит перечень зависимостей и 
        операций, которые необходимо выполнить для удовлетворения этих зависимостей.
    - [ more, less ] постраничный просмотр файлов
  - Команды для работы с сетью:
    - [ host ] Возвращает информацию об узле Интернета, по заданному имени или IP адресу, выполняя 
      поиск с помощью службы DNS.
    - [ ipcalc ] Производит поиск IP адреса.
    - [ nslookup ] Выполняет "поиск имени узла" Интернета по заданному IP адресу.
    - [ traceroute ] Утилита предназначена для исследования топологии сети посредством передачи 
      ICMP пакетов удаленному узлу. Эта программа может работать в LAN, WAN и в Интернет. Удаленный
      узел может быть указан как по имени, так и по IP адресу.
    - [ wget ] неинтерактивная утилита для скачивания файлов с Web или ftp сайтов.
    - [ mail ] отправка/получение электронного письма
      - [*] есть еще [mailto] позволяет отправлять MIME (multimedia) сообщения.
      - [*] есть еще [vacation] Эта утилита предназначена для автоматической передачи ответов на электронные письма
  - Команды выполнения математических операций:
    - [ factor ] Разложение целого числа на простые множители.
    - [ dc ] Утилита dc (desk calculator) -- это калькулятор, использующий "Обратную Польскую Нотацию", и 
      ориентированный на работу со стеком. Многие стараются избегать испоьзования dc, из-за непривычной 
      формы записи операндов и операций. 
    - [ bc ] Универсальная, выполняющая вычисления с произвольной точностью, утилита
  - Прочие команды: 
    - [ jot, seq ] Эти утилиты выводят последовательность целых чисел с шагом, заданным пользователем.
    - [ getopt ] служит для разбора командной строки, выделяя из нее ключи -- символы, с предшествующим 
      знаком дефис. Этой утилите имеется, встроенный в Bash, аналог -- getopts, более мощная и 
      универсальная команда.
    - [ run-parts ] запускает на исполнение все сценарии, в порядке возрастания имен файлов-сценариев, 
      в заданном каталоге.
    - [ yes ] выводит на stdout непрерывную последовательность символов y, разделенных символами перевода строки.
    - [ printenv ] Выводит все переменные окружения текущего пользователя.
    - [ tee ] Подобно водопроводным трубам, "tee" позволяет "направить поток" данных в несколько файлов и 
      на [stdout] одновременно, никак не влияя на сами данные.
    - [ objdump ] Отображает содержимое исполняемого или объектного файла либо в шестнадцатиричной форме, 
      либо в виде дизассемблерного листинга (с ключом -d).
 



14) Глава 13. Команды системного администрирования
  - [ users ] Выведет список всех зарегистрировавшихся пользователей.
  - [ groups ] Выводит список групп, в состав которых входит текущий пользователь.
    - есть [$GROUPS] выводит числовые индефикаторы групп
  - [ chown ] изменяет владельца файла или файлов.
  - [ chgrp ] изменяет группу, которой принадлежит файл или файлы.
  - [ useradd ] добавляет учетную запись нового пользователя в систему и создает домашний каталог 
    для данного пользователя.
    - [ userdel ] даляет учетную запись пользователя из системы. удалит соответствующие файлы.
  - [ id ] выводит идентификатор пользователя (реальный и эффективный) и идентификаторы групп, в состав 
    которых входит пользователь.
    - по сути это вывод из [ $UID, $EUID и $GROUPS ]
  - [ who ] Выводит список пользователей, работающих в настоящий момент в системе.
  - [ su ] Команда предназначена для запуска программы или сценария от имени другого пользователя. 
    - [ su rjones ] -- запускает командную оболочку от имени пользователя [rjones].
      Запуск команды [su] без параметров означает запуск командной оболочки от имени привилегированного 
      пользователя [root].
  - [ sudo ] Исполняет заданную команду от имени пользователя root (или другого пользователя).
    - [*] Имена пользователей, которым разрешено использовать команду [sudo], хранятся в файле [/etc/sudoers].
  - [ passwd ] Устанавливает или изменяет пароль пользователя.
  - [ tty ] Выводит имя терминала текущего пользователя. Обратите внимание: каждое отдельное окно [xterm] 
    считается отдельным терминалом.
  - [ uname ] Выводит на stdout имя системы. С ключом -a, выводит подробную информацию, содержащую имя системы, 
    имя узла (то есть имя, под которым система известна в сети), версию операционной системы, наименование 
    модификации операционной системы, аппаратную архитектуру
  - [ strace ] Диагностическая и отладочная утилита, предназначенная для трассировки системных вызовов и сигналов. 
    В простейшем случае, запускается как: [ strace COMMAND ].
  - [ nmap ] Сканер сетевых портов. Эта утилита сканирует сервер в поисках открытых портов и сервисов. 
    Это очень важный инструмент, используемый для поиска уязвимостей при настройке системы.
  - [ free ] Показывает информацию об использовании памяти, в табличной форме.
  - [ vmstat ] Выводит информацию о виртуальной памяти.
  - [ du ] Выводит сведения о занимаемом дисковом пространстве в каталоге и вложенных подкаталогах. 
    Если каталог не указан, то по-умолчанию выводятся сведения о текущем каталоге.
  - [ df ] Выводит в табличной форме сведения о смонтированных файловых системах.
  - [ stat ] Дает подробную информацию о заданном файле (каталоге или файле устройства) или наборе файлов.
  - [ netstat ] Показывает сведения о сетевой подсистеме, такие как: таблицы маршрутизации и активные соединения. 
  - [ logger ] Добавляет в системный журнал (/var/log/messages) сообщение от пользователя. 
    Для добавления сообщения пользователь не должен обладать привилегиями суперпользователя.
  - [ logrotate ] Эта утилита производит манипуляции над системным журналом: ротация, сжатие, удаление 
    и/или отправляет его по электронной почте, по мере необходимости. Как правило, утилита [logrotate] 
    вызывается демоном crond ежедневно.
    - [*] Добавляя соответствующие строки в [/etc/logrotate.conf], можно заставить [logrotate] обрабатывать 
      не только системный журнал, но и ваш личный.
  - [ ps ] Process Statistics: Список исполняющихся в данный момент процессов. Обычно вызывается с ключами [ax]
  - [ pstree ] Список исполняющихся процессов в виде "дерева". С ключом 
    [-p] -- вместе с именами процессов отображает их [PID].
  - [ top ] Выводит список наиболее активных процессов.
    - [-b] -- отображение ведется в обычном текстовом режиме, что дает возможность анализа вывода от 
      команды внутри сценария.
  - [ nohup ] Запуск команд в режиме игнорирования сигналов прерывания и завершения, что предотвращает 
    завершение работы команды даже если пользователь, запустивший ее, вышел из системы.
  - [ fuser ] Возвращает идентификаторы процессов, использующих указанный файл(ы) или каталог. 
    С ключом -k, завершает найденные процессы.
  - [ init ] предок (родитель) всех процессов в системе. Вызывается на последнем этапе загрузки системы и 
    определяет уровень загрузки (runlevel) из файла /etc/inittab.
  - [ ifconfig ] Утилита конфигурирования и запуска сетевых интерфейсов. Чаще всего используется в сценариях 
    начальной загрузки системы, для настройки и запуска сетевых интерфейсов или для их остановки перед 
    остановкой или перезагрузкой.
  - [ chkconfig ] Проверка сетевой конфигурации. Обслуживает список, запускаемых на этапе загрузки, сетевых 
    сервисов, список сервисов хранится в каталогах /etc/rc?.d (строго говоря, chkconfig работает не только 
    с сетевыми сервисами, а с сервисами вообще, не зависимо от того сетевые это службы или нет. прим. перев.).
  - [ tcpdump ] "Сниффер" ("sniffer") сетевых пакетов. Инструмент для перехвата и анализа сетевого трафика 
    по определенным критериям.
  - [ mount ] Выполняет монтирование файловой системы, обычно на устройстве со сменными носителями, такими 
    как дискеты или CDROM. Файл /etc/fstab содержит перечень доступных для монтирования файловых систем, 
    разделов и устройств, включая опции монтирования, благодаря этому файлу, монтирование может производиться 
    автоматически или вручеую. Файл /etc/mtab содержит список смонтированных файловых систем и разделов 
    (включая виртуальные, такие как /proc).
    - [*] отмантировать можно командой [unmount]
  - [ lockfile ] Она создает lock file, файл-семафор (или, если угодно, файл блокировки), который управляет 
    доступом к заданному файлу, устройству или ресурсу. Lock file служит признаком того, что данный файл, 
    устройство или ресурс "занят" некоторым процессом, и ограничивает (или вообще запрещает) доступ к ресурсу 
    другим процессам.
  - [ ulimit ] Устанавливает верхний предел для системных ресурсов. Как правило вызывается с ключом -f, 
    что означает наложение ограничений на размер файлов (ulimit -f 1000 ограничит размер вновь создаваемых
    файлов одним мегабайтом).
    - [*] Обычно, все ограничения прописываются в файле [/etc/profile] и/или [~/.bash_profile]
  - [ ldd ] Выводит список разделяемых библиотек, необходимых для исполняемого файла.
  - [ watch ] Периодически запускает указанную программу с заданным интервалом времени.




15) Глава 14. Подстановка команд
  - Классический пример подстановки команд -- использование обратных одиночных кавычек (`...`). 
    Команды внутри этих кавычек представляют собой текст командной строки.
  - Альтернативой обратным одиночным кавычкам, используемым для подстановки команд, можно считать 
    такую форму записи: $(COMMAND).
  - запись результата выполнения в переменную 
    - [ File_contents1=$(cat $file1) ]
    - [ File_contents2=$(<$file2) ]



16) Глава 15. Арифметические подстановки
  - Арифметические подстановки -- это мощный инструмент, предназначенный для выполнения арифметических 
    операций в сценариях. Перевод строки в числовое выражение производится с помощью обратных одиночных 
    кавычек, двойных круглых скобок или предложения let.
    - [ z=`expr $z + 3` ]
    - [ z=$(($z+3)) ]
    - [ let "z += 3" ]



17) Глава 16. Перенаправление ввода/вывода
  - [ 1>filename ] Перенаправление вывода (stdout) в файл "filename".
  - [ 2>filename ] Перенаправление stderr в файл "filename".
  - [ &>filename ] Перенаправление stdout и stderr в файл "filename".
  - [ 2>&1 ] Перенаправляется stderr на stdout.
  - [ i>&j ] Вывод в файл с дескриптором i передается в файл с дескриптором j.
  - [ [j]<>filename ] Файл "filename" открывается на чтение и запись, и связывается с дескриптором "j".
  - [
      # Как одно из применений этого -- запись в конкретную позицию в файле.
      echo 1234567890 > File    # Записать строку в файл "File".
      exec 3<> File       # Открыть "File" и связать с дескриптором 3.
      read -n 4 <&3             # Прочитать 4 символа.
      echo -n . >&3             # Записать символ точки.
      exec 3>&-                 # Закрыть дескриптор 3.
      cat File                  # ==> 1234.67890
      # Произвольный доступ, да и только!
    ]
  - [ n<&- ] Закрыть дескриптор входного файла n.
  - [ n>&- ] Закрыть дескриптор выходного файла n.
  - [*] Дочерние процессы наследуют дескрипторы открытых файлов. По этой причине и работают конвейеры. 
    Чтобы предотвратить наследование дескрипторов -- закройте их перед запуском дочернего процесса.
  - [ exec <filename ] перенаправляет ввод со stdin на файл. С этого момента весь ввод, вместо stdin 
    (обычно это клавиатура), будет производиться из этого файла. Это дает возможность читать содержимое
    файла, строку за строкой,
  - [*] Блоки кода, такие как циклы while, until и for, условный оператор if/then, так же могут смешиваться 
    с перенаправлением stdin. Даже функции могут использовать эту форму перенаправления. Оператор 
    перенаправления <, в таких случаях, ставится в конце блока.
    [
      do
        read name                 # Чтение из $Filename, не со stdin.
        echo $name
        let "count += 1"
      done <"$Filename"           # Перенаправление на ввод из файла $Filename.
    ]
























[?] как завершить выполнения скрипта ?
  - есть команда [ exit 0 ; ] [*] если ноль то все хорошо, все другое это код ошибки

[?] работа с входными аргументами
  - [ $# ] число полученных входных аргументов
  - [ $* и $@ ] содержат все позиционные параметры (аргументы командной строки)
  - Аргументы, следующие за $9, должны заключаться в фигурные скобки, например: ${10}.
  - вот шаблон проверки, что параметр есть, передан
    [
       if [ -z $1 ]
       then
         exit $POS_PARAMS_MISSING
       fi
    ]
  - Команда [shift] "сдвигает" позиционные параметры, в результате чего 
    парметры "сдвигаются" на одну позицию влево.
    - [*] Прежний аргумент $1 теряется, но аргумент $0 (имя файла сценария) 
      остается без изменений.
    - [*] использование [#shiftExample]

[?] изменить тароль пользователя
  - [ passwd <новый пароль> ]

[?] как посмотреть порты открытые - доступные [*] супер утилита
  - качаем утилиту [ sudo apt install nmap ]
  - эта утилита сканирует сервер по всем портам и определяет открытые
    и показывает дофига интересного о сервере
    - [ nmap -A -p1-65535 <ip> ] указали диапазон портов [ 1 - 65535 ] по умолчанию
      сканируются порты только [ 1 - 1000 ] 
    - [ nmap -A -p1-1000 -oN ./nmapOut.txt <ip> ] добавили вывод в файл [nmapOut.txt]

[?] как посмотреть свободную аперативку RAM
  - утилита [free] -> [ free | grep Mem | awk '{ print $4 }' ]

[?] посмотреть размер и занимаемое место в монтированых разделах
  - [ df -h ]

[?] как посмотреть различную информацию о файле / дириктории 
  - [ stat <файл> ]
  - [ stat --printf "- %a \n- %A \n- %s \n" ./.ssh ] [*] куууча параметров

[?] как задать удобную ротацию логов
  - [ logrotate ] прикольная утилитка в которой задаем какойнить файл
    и говорим как за ним следить архивировать его и удалять старые 
    файлы или отправлять это куда-нибудь
    - конфигурируем файл [ /etc/logrotate.conf ]
  - есть еще планировщик заданий [ crond ]
    - конфигурируем [ /etc/crontab ]
  - для анализа и мониторинга есть [ watch ]

[?] как удобно получить вывод информации от [top]
  - [ top -b -d 1 ] вывод как текст, каждую секунду

[?] как посмотреть кто кого запустил
  - [ pstree -p ]

[?] посмотреть все имеющиеся сетевые интерфейсы
  - [ netstat -a ]

[?] как посмотреть пакеты через сетевой интерфейс
  - у нас есть утилита [ tcpdump ] которая Сниффер -> [ sniffer ] нюхач
  - смотрим интерфейсы [ ifconfig ]
  - присасываемся нюхачем к интерфейсу [ sudo tcpdump -i vboxnet0 ]
  - посмотрим данные в передаваемых пакетах [ sudo tcpdump -i vboxnet0 -s 0 -A ]
    - тут указали лимит выводимых символов в пакете [ -s 0 ]
    - указали что хотим смотреть содержимое пакетов [ -A ]
  - [*] напоминаю вывод можно грепать например

[?] как примантировать файл к файловой системе
  - мы можем создать файловую систему в файле и примонтировать
    - [#createAndMount] 

[?] как вывести список разделяемых библиотек, необходимых для исполняемого файла.
  - [ ldd /bin/ls ]
 
[?] как разделить команды в одной строке между собой
  - [ echo hello; echo there ] разделяем
  - [*] в конструкциях [ switch-case ] видим экранирование [ ;; ] 
  - можно групировать команды [ (a=hello; echo $a) ]
    - [*] есть особенность, что команды в ковычках будут выполнены в дочернем 
      процечче что означает, что Переменные, создаваемые в дочернем процессе 
      не видны в "родительском" сценарии.

[?] как указать пустой оператор [ nop ] 
  - это двоеточие [ : ] всегда возвращает [ true ]
  - двоетоточие используется как разделитель для указания путей в переменных среды

[?] как получить код завершения последней команды
  - [ $? ] хранит возвращаемый результат последней команды

[?] как узнать [ id ] выполняемого скрипта ?
  - [ $$ ] хранит id этого сценария

[?] как намисать выполнение цикла в фоне в скрипте
  - смотрим демонстрацию [#backForProcess]
 
[?] крутая тема переходить в предыдущий каталог
  - [ cd - ] выполнит переход в предыдущий рабочий каталог, 
    путь к которому хранится в переменной окружения $OLDPWD.
  - [ cd ~ ] переход в домашний каталог, переменная $HOME.
  - [ ~+ ] текущий рабочий каталог. Переменная $PWD.
  - [ ~- ] предыдущий рабочий каталог. Переменная $OLDPWD.

[?] ковычки для выполнения команды в них
  - это кавычки от тильды [ ` ` ] например [` ls -l `]
  - Присваивание переменных с использованием $(...) (более современный метод)
    - [*] например пишем в скрипте [ R=$(cat /etc/redhat-release) ]




// #bashRootMustRun
#----------------------------------------------- 

#!/bin/bash

# определяем кто нас запускает!

ROOT_UID=0     # Только пользователь с $UID 0 имеет привилегии root.
E_NOTROOT=67   # Признак отсутствия root-привилегий. (завели такой код)


if [ "$UID" -ne "$ROOT_UID" ]
then
  echo "Для работы сценария требуются права root."
  exit $E_NOTROOT
else
  echo "Привет root"
fi

#----------------------------------------------- 


// #bashCd 
#-----------------------------------------------

 cd /var/log || {
   echo "Невозможно перейти в требуемый каталог." >&2
   exit $E_XCD;
 }

#----------------------------------------------- 


// #createAndMount
#-----------------------------------------------

SIZE=1048576  # 1 Мб

head -c $SIZE < /dev/zero > file  # Создается файл нужного размера.
losetup /dev/loop0 file           # Файл назначается как loopback-устройство.
mke2fs /dev/loop0                 # Создание файловой системы.
mount -o loop /dev/loop0 /mnt     # Монтирование только что созданной файловой системы.

#----------------------------------------------- 


// #testForvardStream
#-----------------------------------------------

#!/bin/bash
# Чтение строк из файла /etc/fstab.

File=/etc/fstab

{
  read line1
  read line2
} < $File    # в этом блоке чтение происходит из файла 

echo "Первая строка в $File :"
echo "$line1"
echo
echo "Вторая строка в $File :"
echo "$line2"

exit 0

#----------------------------------------------- 


// #backForProcess
#-----------------------------------------------

#!/bin/bash
# background-loop.sh

for i in 1 2 3 4 5 6 7 8 9 10            # Первый цикл.
do
  echo -n "$i "  # ключ [-n] вывод в той же строке
done & # Запуск цикла в фоне.
       # Иногда возможны случаи выполнения этого цикла после второго цикла.

echo "start"

for i in 11 12 13 14 15 16 17 18 19 20   # Второй цикл.
do
  echo -n "$i "
done

echo "end" 

#----------------------------------------------- 


// #varExample
#-----------------------------------------------

#!/bin/bash

# Присваивание значений переменным и подстановка значений переменных

a=375
hello=$a

#-------------------------------------------------------------------------
# Использование пробельных символов
# с обеих сторон символа "=" присваивания недопустимо.

#  Если записать "VARIABLE =value",
#+ то интерпретатор попытается выполнить команду "VARIABLE" с параметром "=value".

#  Если записать "VARIABLE= value",
#+ то интерпретатор попытается установить переменную окружения "VARIABLE" в ""
#+ и выполнить команду "value".
#-------------------------------------------------------------------------


echo hello    # Это не ссылка на переменную, выведет строку "hello".

echo $hello
echo ${hello} # Идентично предыдущей строке.

echo "$hello"
echo "${hello}"

echo

hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
# Здесь вы сможете наблюдать различия в выводе echo $hello и echo "$hello".
# Заключение ссылки на переменную в кавычки сохраняет пробельные символы.

echo

echo '$hello'  # $hello
# Внутри одинарных кавычек не производится подстановка значений переменных,
#+ т.е. "$" интерпретируется как простой символ.

# Обратите внимание на различия, существующие между этими типами кавычек.


hello=    # Запись пустого значения в переменную.
echo "\$hello (пустое значение) = $hello"
#  Обратите внимание: запись пустого значения -- это не то же самое,
#+ что сброс переменной, хотя конечный результат -- тот же (см. ниже).

# --------------------------------------------------------------

#  Допускается присваивание нескольких переменных в одной строке,
#+ если они отделены пробельными символами.
#  Внимание! Это может снизить читабельность сценария и оказаться непереносимым.

var1=variable1  var2=variable2  var3=variable3
echo
echo "var1=$var1   var2=$var2  var3=$var3"

# Могут возникнуть проблемы с устаревшими версиями "sh".

# --------------------------------------------------------------

echo; echo

numbers="один два три"
other_numbers="1 2 3"
# Если в значениях переменных встречаются пробелы,
# то использование кавычек обязательно.
echo "numbers = $numbers"
echo "other_numbers = $other_numbers"   # other_numbers = 1 2 3
echo

echo "uninitialized_variable = $uninitialized_variable"
# Неинициализированная переменная содержит "пустое" значение.
uninitialized_variable=   #  Объявление неинициализированной переменной
                          #+ (то же, что и присваивание пустого значения, см. выше).
echo "uninitialized_variable = $uninitialized_variable"
                          # Переменная содержит "пустое" значение.

uninitialized_variable=23       # Присваивание.
unset uninitialized_variable    # Сброс.
echo "uninitialized_variable = $uninitialized_variable"
                                # Переменная содержит "пустое" значение.

echo

exit 0

#----------------------------------------------- 


// #shiftExample
#-----------------------------------------------

#!/bin/bash
# Использование команды 'shift' с целью перебора всех аргументов командной строки.

#  Назовите файл с этим сценарием, например "shft",
#+ и вызовите его с набором аргументов, например:
#          ./shft a b c def 23 skidoo

until [ -z "$1" ]  # До тех пор пока не будут разобраны все входные аргументы...
do
  echo -n "$1 "
  shift
done

echo               # Дополнительная пустая строка.

exit 0

#----------------------------------------------- 


// #ifExtention
#-----------------------------------------------

#!/bin/bash

# есть еще [ elif ]

if echo "tort"
then
  echo "----------"
else
  echo "=========="
fi

#----------------------------------------------- 

