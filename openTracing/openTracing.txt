---
Ресурсы:

// оф сайт
- [ https://opentracing.io/ ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ opentracing ] Текущий стандарт де-факто для распределенной трассировки


1) Вводная
  - [ https://habr.com/ru/post/489552/ ]
  - Что такое Span 
    - Это элементарная сущность трейсинга
    - компоненты спана:
      - [ Tags ] пары ключ:значение для конкретного спана
      - [ Logs ] пары ключ:значение для конкретного спана (*) добавляется "timestamp"
      - [ SpanContext ] переносит данные между процессами
        - остоит из spanId + traceID и Baggage Items
      - [ Baggage items ] пары ключ:значение для всего трейса, 
        значения будут передоваться дочерним спанам.
  - потоки и спаны в opentracing 
    - в одном потоке в один момент может быть активен только один "Span".
      это контролируется "Scope" происходит менеджемент по активации/деактиваци спанов
    - если Scope существует, когда разработчик создает новый спан,
      он будет действовать как его родительский элемент, если только
      программист не вызовет "ignoreActiveSpan()" вовремя "buildSpan()" 
    - передачей активного спана от метода к методу занимается "Scope Manager".
      Разработчик может получить доступ к любому активному Span через Scope.
    - используя "Scope Manager" разработчик может переносить "Span" между разными потокам


2) The OpenTracing Semantic Specification
  - [ The OpenTracing Data Model ]
    - [Trace] это набор спанов "Span". Все спаны имеют одинаковый "traceid"
    - есть корневой спан "Span" в него как бы вложены все другие спаны
  - [ References between Spans ] 
    - Связи между спанами могут быть двух Типов
      - [ ChildOf ] один спан вложен в другой спан, означает ждем завершения.
        Для завершения родительского span'a требуется завершение дочернего.
      - [ FollowsFrom ] один спан идет за другим спаном, не ждем завершения.
        Родительский "span" запустил другой "span", но на завершение текущего он не влияет.
  - [ The OpenTracing API ]
    - [Trace]
      - [Start a new Span] создать новый спан "Span"
      - [Inject a SpanContext into a carrier] засовываем SpanContext в запрос 
        или сообщение для передачи в другой процесс
      - [Extract a SpanContext from a carrier] высовываем SpanContext из запроса 
        или сообщения полученного из другого запроса
    - [Span]
      - Описание: При создании интервала обязательным полем является 
        имя (например название функции), также неявно в "Span" записывается "timestamp" 
        создания интервала и идентификатор spanId. Каждый интервал содержит "traceId", 
        если span является дочерним, то в него записывается "traceId" родительского интервала, 
        если родительского "span"'а нет, генерируется новый. Когда функция завершила свою работы, 
        у объекта span мы должны вызвать метод "finish". Этот метод запишет в "Span" "timestamp" 
        завершения работы, а так же отправит получившийся "span" в Трассировщик
      - [Retrieve the Spans SpanContext] получить "SpanContext" этого спана
      - [Overwrite the operation name] Перезаписать название операции
      - [Finish the Span] закончить "Span"
      - [Set a Span tag] записать тег (ключ:значение) в спан "spam"
      - [Log structured data] записать лог (ключ:значение) в спан "span"
      - [Set a baggage item] установить багажный элемент (ключ:значение) в спан "span"
        Значение прикрепляется к "Span", к его контексту "SpanContext" ко всем "Span",
        которые прямо или транзитвно ссылаются на этот спан.
      - [Get a baggage item] получить багажное значение по ключу
   - [SpanContext]
     - Это больше концепт, определяющий некий слой.
       Можем представить как набор ссылок, когда мы создаем новый "Span" или
       достаем "Span" из запроса/сообщения или кладем туда.
   - [Carrier]
     - Описание: Этот простой объект типа key:value содержит информацию, 
       с помощью которой можно создать "SpanContext".
     - есть два типа "carrier"
       - [FORMAT_TEXT_MAP] текстовая мапа, можно передавать вместе с запросами
       - [FORMAT_BINARY] трансформирует контекст в бинарный вид
       - (*) не в стандарте [FORMAT_HTTP_HEADERS] преобразует в HHTP заголовки
   - [NoopTracer]
     - Обычно есть в языках имплементация этой сущности для флагов, настроек, отладки    


3) Best Practices
  - [ https://opentracing.io/docs/best-practices/ ]
  - Как добавить трассировку в функцию
  - 



4) OpenTracing Java API
  - [https://github.com/opentracing/opentracing-java]
  - подключение для maven
    [
      <dependency>
          <groupId>io.opentracing</groupId>
          <artifactId>opentracing-api</artifactId>
          <version>VERSION</version>
      </dependency>
    ]
  - получить доступ до активного в данный момент спана "Span"
    [
      io.opentracing.Tracer tracer = ...;
      ...
      Span span = tracer.scopeManager().activeSpan();
      if (span != null) {
          span.log("...");
      }
    ]
  - Стартануть новый спан "Span"
    Мы должны создать "Span", а потом сделать его активным при помощи "ScopeManager"
    Если уже был какойто спан активным, то новый станед дочерним.
    Мы можем все методы завернуть в такую конструкцию и 
    тогда при вызове таких методов будет один "traceID" и уникальный "spanID"
    [
      io.opentracing.Tracer tracer = ...;
      ...
      Span span = tracer.buildSpan("someWork").start();
      try (Scope scope = tracer.scopeManager().activate(span)) {
          // Do things.
      } finally {
          span.finish();
      }
    ]
  - Стартуем новый спан, когда уже есть активный "Span", 
    тогда наш "Span" автоматически станет дочерним для активного "span", 
    но можно избежать этого, добавив "ignoreActiveSpan()"
    [
      io.opentracing.Tracer tracer = ...;
      ...
      Span span = tracer.buildSpan("someWork").ignoreActiveSpan().start();
    ]
  








 

[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
