---
Ресурсы:

// оф сайт
- [ https://golang.org/ ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ golang ] это язык программирования. Очень простой, компилируемый.




1) Устанавливаем на ubuntu
  - [ https://golang.org/dl/ ] качаем архив
  - [ sudo tar -C /usr/local -xzf go1.14.6.linux-amd64.tar.gz ] распаковываем
  - [ export PATH=$PATH:/usr/local/go/bin ] добавляем в PATH
  - [ go ] проверяем


2) первые приложения
  - создадим файл [ main.go ] 
    - [ go run main.go ] запуск
    - [ go build main.go ] скомпилировать бинарный файл
  - [ hello.go ] первый пример "hello"
  - [ http_server.go ] второй пример  "web service"  


3) пакеты
  - [ package main ] объявили новый пакет, в любом проекте должен быть обязательно пакет main. 
    Запуск программы начинается именно с этого пакета.
    - (*) [ func main(){} ] обязательная ф-я, запускается при старте программы
  - [ import "fmt" ] импортировали пакет ввода/вывода.


4) Типы данных
  - [ uint8 , uint16, uint32, uint64	] Беззнаковые целые числа 
  - [ int8 , int16, int32, int64	] Знаковые целые числа 
  - [ byte ] то же самое, что "uint8"
  - [ rune ] то же самое, что "int32"
  - [ uint, int, uintptr ] Машинно-зависимых целочисленных типы
  - [ float32, float64 ] Числа с плавающей точкой
  - [ complex64, complex128 ] Комплексные числа 
  - [ "Hello", `Hello` ] Cтроки. Cтроки в двойных кавычках не могут содержать 
    новые строки и они позволяют использовать особые управляющие последовательности символов. Например, \n будет заменена символом новой строки, а \t - символом табуляции.
  - [ bool ] логический тип. (truе или false)


5) Переменные
  - [ var ] ключевое слово для определения переменной
    - [ var <имя_переменной> <тип_данных> ] определение переменной
    - [ var hello string ] переменная называется "hello" и представляет тип "string"
    - [ var hello = "Hello" ] тут мы сразу задаем значение, тип выведется из значения
    - [ a := 5 ] короткая запись обьявления переменной, можно использовать только в функциях
    - (*) можно обявить несколько переменных в одном "var"
      [
        var (
          name string = "Dima"
          age int = 23
        )
      ]
    - (*) Go - регистрозависимый язык


6) Минитемы:
  - Арифметические операции
    - [ +, -, *, /, %, ++, -- ]
  - коментарии
    - [ /*  */ ] многострочные
    - [ // ] однострочный коментарий
  - константы
    - значения устанавливаем один раз и потом не можем менять
    - [ const PI float64 = 3.1415 ]
    - [ iota ] используется в объявлениях констант для определений увеличивающихся чисел
      - [
          const (
          	Sunday = iota
          	Monday
          	Tuesday
          )
      ]

 
7) Консоль
  - [ import "fmt" ] пакет для работы с консолью
  - [ fmt.Println("Hello") ] вывод
  - [ fmt.Printf("%q", a) ] форматированный вывод
    - (*) [ %v ] универсальный спецификатор
      - который для типа boolean аналогичен %t, 
        для целочисленных типов - %d, 
        для чисел с плавающей точкой - %g, для строк - %s
    - [ %t ] для вывода значений типа boolean (true или false)
    - [ %b ] для вывода целых чисел в двоичной системе
    - [ %c ] для вывода символов, представленных числовым кодом
    - [ %d ] для вывода целых чисел в десятичной системе
    - [ %o ] для вывода целых чисел в восьмеричной системе
    - [ %q ] для вывода символов в одинарных кавычках
    - [ %x ] для вывода целых чисел в шестнадцатеричной системе, нижний регистр a-f
    - [ %X ] для вывода целых чисел в шестнадцатеричной системе, верхний регистр A-F
    - [ %U ] для вывода символов в формате кодов Unicode, например, U+1234
    - [ %e ] для вывода чисел с плавающей точкой в экспоненциальном представлении
    - [ %E ] тоже самое что %e но в верхнем регистре, например, -1.234456E+78
    - [ %f ] для вывода чисел с плавающей точкой, например, 123.456
    - [ %F ] то же самое, что и %f
    - [ %g, %e ] для огромных экспонент, %f в противном случае
    - [ %G, %E ] для огромных экспонент, %F в противном случае
    - [ %s ] для вывода строки
    - [ %p ] для вывода значения указателя - адреса в шестнадцатеричном представлении
    - [ %T ] для вывода типа переменной
  - ...
  - [ fmt.Scan(&name) ] ввод (*) значение кладем в  переменную "var name string"
  - [ fmt.Scanf("%f", &a) ] форматированный ввод


8) управля.щие конструкции
  - [ ==, >, <, <=, >=, != ] операции возвращающие "bool"
  - [ !, &&, || ] логические операции
  - [ if ]
    - классический пример:
      [
         if a < b {     
           // ...
         } else if a > b {
           // ...
         } else {
           // ...
         }
      ]
    - можно обьявлять переменные, которые будут видны только в этом блоке:
      [
        if v := math.Pow(x, n); v < lim {
           // ...
        }
      ]
  - [ switch ]
    - классический пример:
      [
        switch i {
        case 0: fmt.Println("Zero")
        case 1: fmt.Println("One")
        default: fmt.Println("Unknown Number")
        }
      ]
    - можно в каждом кейсе писать свое условие:
      [
        var c uint32
        switch {
        case 1 <= c && c <= 9: fmt.Println("от 1 до 9")
        case 100 <= c && c <= 250: fmt.Println("от 100 до 250")
        case 1000 <= c && c <= 6000: fmt.Println("от 1000 до 6000")
        }
      ] 


7) Циклы
  - (*) в Go есть только "for" Цикл
  - (*) части цикла "for" опциональны
  - шаблон:
    [
      for [инициализация счетчика]; [условие]; [изменение счетчика]{
          // действия
      }
    ]
  - пример:
    [
    	var count int
    	for i := 0; i < count; i++ {
    	    fmt.Print(i)
    	}
    ]
  - [ break ] выход из цикла
  - [ continue ] прекращение итерации


7) Массивы
  - (*) Это последовательность элементов одного типа фиксированной длины. 
  - примеры:
    [
      var a [3]int
      var b [3]int = [3]int{1, 2, 3}
      c := [3]int{1, 2, 3}
      d := [...]int{1, 2, 3}
      e := [3]int{1: 12}

    	for index, element := range workArray {
    		fmt.Printf("workArray[%d]: %d\n",index, element)
    	}  
    ]
  - есть встроенная поддержка сравнения массивов 
    - последоватьельно сравниваються значения, массивы должны быть одного типа
  - [ len(a) ] встроенная ф-ия возвращает длину массива



7) Срезы (слайсы, slices)
  - (*) Это последовательность элементов одного типа переменной длины.
  - Срез состоит из трех компонентов:
    - [ указатель ] - указатель указывает на первый элемент
    - [ длина ] - "len()" это количество элементов среза
    - [ емкость ] - "cap()" количество элементов между началом среза и концом
  - примеры:
    [
      var a []int
      var b []int = []int{1, 2, 3}
      c := []int{1, 2, 3}
      d := []int{1: 12}
      
      // make([]T, length, capacity)
      e := make([]int, 10, 10)

      initialUsers := [8]string{"Bob", "Alice", "Mike", "Robert"} // базовый массив
      users1 := initialUsers[1:2] // с 2-го по 2-й
      users2 := initialUsers[:3] // с 1-го по 3-й
      users3 := initialUsers[2:] // с 2-го до конца
    ]
  - [ append ] - добавление элементов в срез
    - [ func append(slice []Type, elems ...Type) []Type ]
      [
        a := []int{1, 2, 3}
        a = append(a, 4, 5) 
        fmt.Println(a) // [1 2 3 4 5]
      ]
    - (*) В Go отсутствует встроенная функция для удаления элемента из среза
      
        a := []int{1, 2, 3, 4, 5, 6, 7}
        a = append(a[0:2], a[3:]...)
        fmt.Println(a) // [1 2 4 5 6 7]
      ]
  - [ copy ] копирование элементов среза
    - [ func copy(dst, src []Type) int ]
      [
        a := []int{1, 2, 3}
        b := make([]int, 3, 3)
        n := copy(b, a)
      ]















[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
