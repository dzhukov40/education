---
Ресурсы:

// book: System Design Interview
  - [ https://www.amazon.de/-/en/System-Design-Interview-insiders-guide/dp/B08CMF2CQF ]
// web site:
  - [ https://bytebytego.com/ ]



---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ System Design Interview ] это одна из лучших книг по системному дизайну для интервью.



1) [ Chapter 1 ] SCALE FROM ZERO TO MILLIONS OF USERS
   [ Single server setup ] 
   - We can start with one server where all components will be inside.
     (web app, database, cache, etc.)
 
                                                                                       
  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |-------|------------------|--------|
          |                  |                                                          
          |                  |
          |                  |                                                          
         \ /                \ /                                                                                                                                                
  |-------x------------------x--------|                                                                                                                                                               
  |                                   |                                                                                                                                                                                                                                                                         
  |            Web server             |                                                                                                                                     
  |                                   |                                                                                                                                     
  |-----------------------------------|                                                                                                                                       
                                                                                                                                                                            
                                                                                                                                                                            
   [ Database ]                                                                                                                                                                          
   - With the growth of the user base we need another server with database.


  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |-------|------------------|--------|
          |                  |                                                          
          |                  |
          |                  |                                                          
         \ /                \ /                                                                                                                                                
  |-------x------------------x--------|      |------------|                                                                                                                                                         
  |                                   |----->|            |                                                                                                                                                                                                                                                             
  |            Web server             |      |  Database  |                                                                                                                            
  |                                   |<-----|            |                                                                                                                         
  |-----------------------------------|      |------------|


   [ Which databases to use? ]                                                                                                                                                                          
   -           database
              /        \ 
             /          \
            /            \
          SQL             \
(Relational database)    NoSql
- postgresql             - key-value 
                         - graph 
                         - column
                         - document
                         - timeseries


   [ Vertical scaling vs horizontal scaling ]                                                                                                                                                                          
   - Vertical
     - add to one server CPU, RAM, DISCK, etc.
     - pros: simple
       cons: 1. impossible add millions of CPU, RAM, DISC, etc.
             2. does not have failover and redundancy.
   - horizontal   
     - add more servers.
     - pros: 1. failover
             2. fault-tolerance  
             3. scalable
       cons: 1. difficult
             2. dublication
             3. not efficient useage of resources




   [ Load balancer ]   
   - we can add more servers for handeling more requests.
   - we can balance load.

  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |---------------|-------------------|
                  |                                                                    
                 \ /          
            |-----x------|
            |            | 
            |    Load    |
            |  balancer  |
            |--|------|--| 
               |      |
          |----|      |------|
          |                  |
         \ /                \ /                                                                                                                                                
  |-------x-------|  |-------x-------|                                                                                                                                                        
  |               |  |               |                                                                                                                                                                                                                                                            
  | Web server 1  |  | Web server 2  |                                                                                                                           
  |               |  |               |                                                                                                                       
  |---------------|  |---------------|



   [ Database replication ]   
   - usually we have master and slave pattern
     master for modefy operations (update/insert)
     slave for not modefying operations (read)
   -...
   - Advantages of database replication:
     - Better performance: (more servers can handle more requests)
     - Reliability: If one of your database servers is destroyed it is not a problem.
     - High availability: replicating data across different locations
     - 

            |------------|
            |            | 
            |     Web    |
            |   servers  |
            |--|------|--| 
               |      |
       |-------|      |--------------x----x----x
       |                             |    |    |
       |                          reads   |    |
       |                             |    |    |
       |              |---------|    |    |    |
     writes           |         |    |    |    |
       |        |---->| Slave   |<---|    |    |
       |        |     |   DB 1  |         |    |
       |        |     |---------|         |    |                      
       |        |                         |    |
      \ /       |                         |    |                                                                                                                                                                   
  |----x----|   |     |---------|       reads  |                                                                                                                                                        
  |         |   |     |         |         |    |                                                                                                                                                                                                                                                           
  | Mastrer |<--x---->| Slave   |<--------|    |                                                                                                                               
  |   DB    |   |     |   DB 2  |              |                                                                                                                 
  |---------|   |     |---------|              |  
                |                              |
                |                            reads
                |     |---------|              |      
                |     |         |              |       
                |---->| Slave   |<-------------|                     
                      |   DB 3  |                     
                      |---------|                     



  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |---------------|-------------------|
                  |                                                                    
                 \ /          
            |-----x------|
            |            | 
            |    Load    |
            |  balancer  |
            |--|------|--| 
               |      |
          |----|      |--------|
          |                    |
         \ /                  \ /                                                                                                                                                
  |-------x-------|    |-------x-------|                                                                                                                                                        
  |               |    |               |                                                                                                                                                                                                                                                            
  | Web server 1  |    | Web server 2  |                                                                                                                           
  |               |    |               |                                                                                                                       
  |-|---------|---|    |--|----------|-|
    |         |           |        read
  write       |-read------|----|     |
    |    |----------write-|    |     |
   \ /  \ /                    \ /   \ /
|---x----x|                  |-x-----x-|                      
|         |    Replicate     |         |                    
| Mastrer |<---------------->| Slave   |                    
|   DB    |                  |   DB    |                    
|---------|                  |---------|                    
  



   [ Cache ]  
   - A cache is a temporary storage area that stores 
     the result of expensive responses or frequently
     accessed data in memory so that subsequent requests 
     are served more quickly

   [ Cache tier ]
   - The cache tier is a temporary data store layer, 
     much faster than the database.



    1. if data exists in cache, read data from cache
              |  
              |
|--------|   \ /              |-------|          |----------|
|        |<---x---------------| Cache |          |          |
| Web    |                    |       |          | Database |
| server |<---x---------------|       |<--x------|          |
|--------|   / \              |-------|  / \     |----------|
              |                           |
              |                2.1 if date doesn't exist in cache,           
              |                    save data to cache.
              |
    2.2 Return data to the web server



   [ Considerations for using cache ]
   - Decide when to use cache.
     Consider using cache when data is read frequently but modified infrequently.
   -...
   - Expiration policy.
     It is a good practice to implement an expiration policy.
     Once cached data is expired, it is removed from the cache.  
   -...
   - Consistancy.
     This involves keeping the data store and the cache in sync.
   -...
   - Mitigating failures
     A single cache server represents a potential single point of failure.
   -...
   - Eviction Policy
     Least-recently-used (LRU) is the most popular cache eviction policy.



   [ Content delivery network (CDN) ]
   - A CDN is a network of geographically 
     dispersed servers used to deliver static content.
   - CDN servers cache static content like images, 
     videos, CSS, JavaScript files, etc.
   - when a user visits a website, a CDN server closest
     to the user will deliver static content. 
     Intuitively, the further users are from CDN servers, 
     the slower the website loads.



   [ Considerations of using a CDN ]
   - Cost:
     CDNs are run by third-party providers, 
     and you are charged for data transfers in and out of the CDN
   - Setting an appropriate cache expiry:
     The cache expiry time should neither be too long nor too short.
   - CDN fallback:
     If there is a temporary CDN outage, clients should be able to detect the problem
     and request resources from the origin.
   - Invalidating files:
     You can remove a file from the CDN before it expires



   [ Stateless web tier ]
   - A good practice is to store session data in
     the persistent storage such as relational database or NoSQL 
   

   [ Stateful architecture ]
   - A stateful server and stateless server has some key differences. 
     A stateful server remembers client data (state) from one request to the next. 
     A stateless server keeps no state information.


   [ Stateless architecture ]
   - In this stateless architecture, 
     HTTP requests from users can be sent to any web servers, which
     fetch state data from a shared data store.
   - A stateless system is simpler, more robust, and scalable.


|--------|        |--------|        |--------|
|        |        |        |        |        |
| User A |        | User B |        | User C |
|        |        |        |        |        |
|---|----|        |---|----|        |---|----|
    |                 |                 |
    |                 |                 |
   \ /               \ /               \ /
|---x-----------------x-----------------x----|
|                                            |
|                 Web servers                |
|                                            |
|---------------------|----------------------|
                      |
                      |
                     \ /
                 |----x----|
                 | Shared  |
                 | Storage |   
                 |---------| 



   [ Data centers ]
   - Several technical challenges must be resolved to achieve multi-data center setup:
     1. Traffic redirection 
        Effective tools are needed to direct traffic to the correct data center.
     2. Data synchronization
        A common strategy is to replicate data across multiple data centers. 
     3. Test and deployment
        With multi-data center setup, it is important to test your
        website/application at different locations



   [ Message queue ]
   - It serves as a buffer and distributes asynchronous requests. 




|----------|           |-----------|     consume   |-----------|
|          |  publish  | Message   |-------------->|           |
| Producer |---------->| Queue     |   subscribe   | Consumer  |
|          |           |           |<-- - - - - - -|           |
|----------|           |-----------|               |-----------|



   [ Logging, metrics, automation ]
   - Logging
    Monitoring error logs is important because 
    it helps to identify errors and problems in the system
  - Metrics
    1. Host level metrics: CPU, Memory, disk I/O, etc.
    2. Aggregated level metrics: for example, the performance of the entire database tier, 
       cache tier, etc.
    3. Key business metrics: daily active users, retention, revenue, etc.
  - Automation
    Continuous integration is a good practice, in which each code
    check-in is verified through automation, allowing teams to detect problems early



   [ Database scaling ]
   - There are two broad approaches for database scaling: 
     vertical scaling and horizontal scaling.

   [ Vertical scaling ]
   - You can add more CPU, RAM, etc. to your database server, 
     but there are hardware limits. 
     If you have a large user base, a single server is not enough.
   - Greater risk of single point of failures.
   - The overall cost of vertical scaling is high. 
     Powerful servers are much more expensive


   [ Horizontal scaling ]
   - Horizontal scaling, also known as sharding, is the practice of adding more servers.
   (*) Sharding separates large databases into smaller, 
       more easily managed parts called shards.
       Each shard shares the same schema, 
       though the actual data on each shard is unique to the shard.
    -...
    - The most important factor to consider when implementing a sharding strategy 
      is the choice of the sharding key
    -...
    - Problems:
      1. Resharding data
         When shard exhaustion happens, it requires
         updating the sharding function and moving data around
      2. Celebrity problem
         This is also called a hotspot key problem.
         Imagine data for Katy Perry, Justin Bieber, 
         and Lady Gaga all end up on the same shard.
      3. Join and de-normalization.
         A common workaround is to denormalize the database 
         so that queries can be performed in a single table.



                |-------------|
                |             |
   |------------| user_id % 4 |-----------|
   |            |             |           |
   |            |-------------|           |
   |              |         |             |                    
   |              |         |             |                    
   |              |         |             |  
  \ /            \ /       \ /           \ /  
|--x--|      |----x|      |-x---|      |--x--|
|     |      |     |      |     |      |     |
|  0  |      |  1  |      |  2  |      |  3  |
|     |      |     |      |     |      |     |
|-----|      |-----|      |-----|      |-----|






   [ Millions of users and beyond ]
   - Scaling a system is an iterative process.
   - To conclude this chapter, we provide a summary of how we scale
     our system to support millions of users:
     1 Keep web tier stateless
     2 Build redundancy at every tier
     3 Cache data as much as you can
     4 Support multiple data centers
     5 Host static assets in CDN
     6 Scale your data tier by sharding
     7 Split tiers into individual services
     8 Monitor your system and use automation tools
     




2) [ Chapter 2 ] BACK-OF-THE-ENVELOPE ESTIMATION
   - In a system design interview, 
     sometimes you are asked to estimate system capacity or performance requirements 
     using a back-of-the-envelope estimation. 
   - You need to have a good sense of scalability basics 
     to effectively carry out back-of-theenvelope estimation.



   [ Power of two ]
   - Although data volume can become enormous when dealing with distributed systems,
     calculation all boils down to the basics. 
   - To obtain correct calculations, it is critical to know 
     the data volume unit using the power of 2.



   [ Latency numbers every programmer should know ]
   - those numbers should still be able to give us an idea of the fastness 
     and slowness of different computer operations.
   - By analyzing the numbers, we get the following conclusions:
     1. Memory is fast but the disk is slow.
     2. Avoid disk seeks if possible.
     3. Simple compression algorithms are fast.
     4. Compress data before sending it over the internet if possible.
     5. Data centers are usually in different regions, 
        and it takes time to send data between them.  


     *   | Operation name                     |   Time
         |------------------------------------|------------------------------------  
                                              |
          L1 cache reference ---------------- | -> 0.5 ns
                                              |
          Branch mispredict ----------------- | -> 5 ns
                                              |
          L2 cache reference ---------------- | -> 7 ns
                                              |
          Mutex lock/unlock ----------------- | -> 100 ns
                                              |
          Main memory reference ------------- | -> 100 ns
                                              |
          Compress 1K bytes with Zippy ------ | -> 10,000 ns = 10 us
                                              |
          Send 2K bytes --------------------- | -> 20,000 ns = 20 us
          over 1 Gbps network                 |
                                              |
          Read 1 MB ------------------------- | -> 250,000 ns = 250 us
          sequentially from memory            |
                                              |
          Round trip within ----------------- | -> 500,000 ns = 500 us
          the same datacenter                 |
                                              |
          Disk seek ------------------------- | -> 10,000,000 ns = 10 ms
                                              |
          Read 1 MB sequentially ------------ | -> 10,000,000 ns = 10 ms
          from the network                    |
                                              |
          Read 1 MB sequentially from disk -- | -> 30,000,000 ns = 30 ms
                                              |
          Send packet CA (California) ------- | -> 150,000,000 ns = 150 ms
          to Netherlands to CA                |




   [ Availability numbers ]
   - High availability is the ability of a system to be continuously operational 
     for a desirably long period of time.
   - High availability is measured as a percentage, 
     with 100% means a service that has 0 downtime. 
   - Most services fall between 99% and 100%.
   
  
     *   | Availability %     | Downtime per day       | Downtime per year 
         |--------------------|------------------------|-----------  
                              |                        |
           99% -------------- | 14.40 minutes          | 3.65 days
                              |                        |
           99.9% ------------ | 1.44 minutes           | 8.77 hours
                              |                        |
           99.99% ----------- | 8.64 seconds           | 52.60 minutes
                              |                        |
           99.999% ---------- | 864.00 milliseconds    | 5.26 minutes
                              |                        |
           99.9999% --------- | 86.40 milliseconds     | 31.56 seconds
                              |                        |



   [ Example: Estimate Twitter QPS and storage requirements ]
   Assumptions:
     • 300 million monthly active users.
     • 50% of users use Twitter daily.
     • Users post 2 tweets per day on average.
     • 10% of tweets contain media.
     • Data is stored for 5 years.
   Estimations:
   Query per second (QPS) estimate:
     • Daily active users (DAU) = 300 million * 50% = 150 million
     • Tweets QPS = 150 million * 2 tweets / 24 hour / 3600 seconds = ~3500
     • Peek QPS = 2 * QPS = ~7000
   We will only estimate media storage here.
     • Average tweet size:
     • tweet_id 64 bytes
     • text 140 bytes
     • media 1 MB
     • Media storage: 150 million * 2 * 10% * 1 MB = 30 TB per day
     • 5-year media storage: 30 TB * 365 * 5 = ~55 PB



   [ Tips ]
   - Back-of-the-envelope estimation is all about the process. 
   - Solving the problem is more important than obtaining results. 
   - Interviewers may test your problem-solving skills. 
   - Here are a few tips to follow:
     1. Rounding and Approximation.
        Use round numbers and approximation to your advantage.
     2. Write down your assumptions.
        It is a good idea to write down your assumptions to be referenced later.
     3. Label your units.
        When you write down “5”, does it mean 5 KB or 5 MB?
     4. Commonly asked back-of-the-envelope estimations. 
        QPS, peak QPS, storage, cache, number of servers, etc. 
        You can practice these calculations when preparing for an interview. 
        Practice makes perfect




3) [ Chapter 3 ] A FRAMEWORK FOR SYSTEM DESIGN INTERVIEWS
   - The system design interview simulates real-life problem solving 
     where two co-workers collaborate on an ambiguous problem 
     and come up with a solution that meets their goals. 
   - This allows you to demonstrate your design skill, 
     defend your design choices, and respond to feedback in a constructive manner. 


   [ A 4-step process for effective system design interview ]
   - Every system design interview is different. 
   - A great system design interview is open-ended 
     and there is no one-size-fits-all solution. 
   - However, there are steps and common ground to cover 
     in every system design interview.


   [ Step 1 - Understand the problem and establish design scope ]
   - Slow down. 
   - Think deeply and ask questions to clarify requirements and assumptions.
   - Here is a list of questions to help you get started:
     1. What specific features are we going to build?
     2. How many users does the product have?
     3. How fast does the company anticipate to scale up? 
        What are the anticipated scales in 3 months, 6 months, and a year?
     4. What is the company’s technology stack? 
        What existing services you might leverage to simplify the design?


  
   [ Example ]
   - If you are asked to design a news feed system, 
     you want to ask questions that help you clarify the requirements.
   - questions:
     1. Is this a mobile app? Or a web app? Or both?
     2. What are the most important features for the product?
     3. How many friends can a user have? 
     4. What is the traffic volume?
     5. Can feed contain images, videos, or just text?


   [ Step 2 - Propose high-level design and get buy-in ]
   - In this step, we aim to develop a high-level design 
     and reach an agreement with the interviewer on the design.
     1. Come up with an initial blueprint for the design.
        Ask for feedback.
        Treat your interviewer as a teammate and work together.
     2. Draw box diagrams with key components on the whiteboard or paper.
        This might include clients (mobile/web), 
        APIs, web servers, data stores, cache, CDN, message queue, etc.
     3. Do back-of-the-envelope calculations to evaluate 
        if your blueprint fits the scale constraints.
   - Should we include API endpoints and database schema here? 
     This depends on the problem.
     For large design problems like “Design Google search engine”, 
     this is a bit of too low level.
  
   [ Example ]
   - Let us use “Design a news feed system” to demonstrate 
     how to approach the high-level design.
   - At the high level, the design is divided into two flows: 
     1. feed publishing.
     2. news feed building.




  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |---------------|-------------------|
                  |                                                                    
                 \ /          
            |-----x------|
            |            | 
            |    Load    |
            |  balancer  |
            |-----|------| 
                  |   
                  |
                 \ /                                                                                                                                                          
          |-------x-------|                                                                                                                                                         
          |               |                                                                                                                                                                                                                                                       
          | Web server 1  |                                                                                                                      
          |               |                                                                                                                 
          |-|-------|---|-|  
            |       |   |---------|
    |-------|       |             |
   \ /             \ /           \ /
|---x-----|    |----x----|    |---x----------|                       
|         |    |         |    |              |           
| Post    |    | Fanout  |    | Notification |                     
| Service |    | Service |    | Service      |                     
|---|-----|    |---|-----|    |--------------|   
    |              |
    |              |
   \ /            \ /
|---x-----|    |---x-----|
|         |    |         |
| Post    |    | Post    |
| Cache   |    | Cache   |
|---|-----|    |---------|
    |
    |
   \ /
|---x-----|
|         |
| Post    |
| DB      |
|---------|




   [ Step 3 - Design deep dive ]
   At this step, you and your interviewer should have already achieved 
   the following objectives:
   1. Agreed on the overall goals and feature scope
   2. Sketched out a high-level blueprint for the overall design
   3. Obtained feedback from your interviewer on the high-level design
   4. Had some initial ideas about areas to focus on 
      in deep dive based on her feedback
   -...
   - Try notto get into unnecessary details. 
     For example, talking about the EdgeRank algorithm of Facebook feed 
     ranking in detail is not ideal during a system design interview as this takes
     much precious time and does not prove your ability in designing a scalable system.



   [ Step 4 - Wrap up ]
   - In this final step, the interviewer might ask you a few follow-up questions 
     or give you the freedom to discuss other additional points. 
     Here are a few directions to follow:
     1. The interviewer might want you to identify the system bottlenecks 
        and discuss potential improvements.
        Never say your design is perfect and nothing can be improved 
     2. It could be useful to give the interviewer a recap of your design.
     3. Error cases (server failure, network loss, etc.) are interesting to talk about.
     4. Operation issues are worth mentioning. How do you monitor metrics and error logs?
        How to roll out the system?
     5. How to handle the next scale curve is also an interesting topic. 
        For example, if your current design supports 1 million users, 
        what changes do you need to make to support 10 million users?
     6. Propose other refinements you need if you had more time.
  -...
  - To wrap up, we summarize a list of the Dos and Don’ts.
    Dos:
    1. Always ask for clarification. Do not assume your assumption is correct.
    2. Understand the requirements of the problem.
    3. There is neither the right answer nor the best answer.
    4. Let the interviewer know what you are thinking. 
       Communicate with your interview.
    5. Suggest multiple approaches if possible. 
    6. Once you agree with your interviewer on the blueprint, 
       go into details on each component. 
       Design the most critical components first.
    7. Bounce ideas off the interviewer. 
       A good interviewer works with you as a teammate
    8. Never give up.
    -...
    Donts:
    1. Don't be unprepared for typical interview questions
    2. Don’t jump into a solution without clarifying the requirements and assumptions.
    3. Don’t go into too much detail on a single component in the beginning. 
       Give the highlevel design first then drills down.
    4. If you get stuck, don't hesitate to ask for hints.
    5. Again, communicate. Don't think in silence.
    6. Don’t think your interview is done once you give the design. 
       You are not done until your interviewer says you are done. 
       Ask for feedback early and often.


   [ Time allocation on each step ]
   - System design interview questions are usually very broad, 
     and 45 minutes or an hour is not enough to cover the entire design.
     - Step 1 Understand the problem and establish design scope: 3 - 10 minutes
     - Step 2 Propose high-level design and get buy-in: 10 - 15 minutes
     - Step 3 Design deep dive: 10 - 25 minutes
     - Step 4 Wrap: 3 - 5 minutes





4) [ Chapter 4 ] DESIGN A RATE LIMITER

   [ Step 1 - Understand the problem and establish design scope ]
   - Rate limiting can be implemented using different algorithms, 
     each with its pros and cons. 
   - The interactions between an interviewer and a candidate help 
     to clarify the type of rate limiters we are trying to build.
   -...
   - questions:
     - What kind of rate limiter are we going to design? 
       Is it a client-side rate limiter or server-side API rate limiter?  
     - Does the rate limiter throttle API requests based on IP, 
       the user ID, or other properties?
     - What is the scale of the system? 
       Is it built for a startup or a big company with a large user base?
     - Will the system work in a distributed environment?
     - Is the rate limiter a separate service 
       or should it be implemented in application code?
     - Do we need to inform users who are throttled?
 
   [ Requirements ]
   - Here is a summary of the requirements for the system:
     - Accurately limit excessive requests.
     - Low latency. 
       The rate limiter should not slow down HTTP response time.
     - Use as little memory as possible.
     - Distributed rate limiting. 
       The rate limiter can be shared across multiple servers or processes.
     - Exception handling. 
       Show clear exceptions to users when their requests are throttled.
     - High fault tolerance. 
       If there are any problems with the rate limiter 
       (for example, a cacheserver goes offline), it does not affect the entire system.




   [ Step 2 - Propose high-level design and get buy-in ]
   - Let us keep things simple and use a basic client and server model for communication.

   [ Where to put the rate limiter? ]
   - We have three options client-side, middleware, server-side.
    
    1. on client side

|-------------------|                                        |-------------|
|         |         |                                        |             |
| Client  | Rate    |--------------------------------------> | API Servers |
|         | limiter |                                        |             |
|-------------------|                                        |-------------|


    2. on middleware

|-------------------|           |-------------|              |-------------|
|                   |           |             |              |             |
| Client            |---------->| Raye        |------------> | API Servers |
|                   |           | limiter     |              |             |
|-------------------|           |-------------|              |-------------|


    3. on server side

|-------------------|                                        |-----------------------|
|                   |                                        |         |             |
| Client            |--------------------------------------->| Rate    | API Servers |
|                   |                                        | limiter |             |
|-------------------|                                        |-----------------------|

  - (*) API gateway
    - Cloud microservices have become widely popular 
      and rate limiting is usually implemented within a component called API gateway.
    - API gateway is a fully managedservice that supports:
      rate limiting, 
      SSL termination, 
      authentication, 
      IP whitelisting, 
      servicing static content, 
      etc. 
    - For now, we only need to know that the API gateway is a middleware 
      that supports rate limiting.
  -...  
  - While designing a rate limiter, an important question to ask ourselves is: 
    where should the rater limiter be implemented, on the server-side or in a gateway?
    Here are a few general guidelines:
    1. Evaluate your current technology stack, such as programming language, 
       cache service, etc. 
       Make sure your current programming language is efficient 
       to implement rate limiting on the server-side.
    2. Identify the rate limiting algorithm that fits your business needs.
    3. If you have already used microservice architecture 
       and included an API gateway in the design to perform authentication, 
       IP whitelisting, etc., you may add a rate limiter to the API gateway.
    4. Building your own rate limiting service takes time. 
       If you do not have enough engineering resources to implement a rate limiter, 
       a commercial API gateway is a better option. 



   [ Algorithms for rate limiting ]
   - Rate limiting can be implemented using different algorithms, 
     and each of them has distinct pros and cons.
     Here is a list of popular algorithms:
     1. Token bucket
     2. Leaking bucket
     3. Fixed window counter
     4. Sliding window log
     5. Sliding window counter



   [ High-level architecture ]
   - The basic idea of rate limiting algorithms is simple. 
     At the high-level, we need a counter to keep track of how many requests 
     are sent from the same user, IP address, etc. 
     If the counter is larger than the limit, the request is disallowed.
   -...
   - Where shall we store counters? 
     Using the database is not a good idea due to slowness of disk access. 
     In-memory cache is chosen because it is fast 
     and supports time-based expiration strategy. 
     For instance, Redis  is a popular option to implement rate limiting. 
     It is an inmemory store.




|-------------------|           |-------------|              |-------------|
|                   |           |             |              |             |
| Client            |---------->| Raye        |------------> | API Servers |
|                   |           | limiter     |              |             |
|-------------------|           |-------x-----|              |-------------|
                                       / \
                                        |
                                        |
                                       \ /
                                |-------x-----|
                                |             |
                                | Redis       |
                                |             |
                                |-------------|


   (*)
   - The client sends a request to rate limiting middleware.
   - Rate limiting middleware fetches the counter from the corresponding bucket in Redis and
     checks if the limit is reached or not.
   - If the limit is reached, the request is rejected.
   - If the limit is not reached, the request is sent to API servers. 
     Meanwhile, the system increments the counter and saves it back to Redis.




   [ Step 3 - Design deep dive ]
   - The high-level design in Figure does not answer the following questions:
     1. How are rate limiting rules created? 
        Where are the rules stored?
     2. How to handle requests that are rate limited?
   -...
   - In this section, we will first answer the questions regarding rate limiting rules 
     and then go over the strategies to handle rate-limited requests. 
   - Finally, we will discuss rate limiting in distributed environment, 
     a detailed design, performance optimization and monitoring.

   [ Rate limiting rules ]
   - We will peek inside of the component 
     and look at some examples of rate limiting rules:
   - excample:
       domain: messaging
       descriptors:
        - key: message_type
        Value: marketing
        rate_limit:
        unit: day
        requests_per_unit: 5 
   

   [ Exceeding the rate limit ]
   - In case a request is rate limited, 
     APIs return a HTTP response code 429 (too many requests) to the client.

   [ Rate limiter headers ]
   - How does a client know whether it is being throttled? 
     And how does a client know the number of allowed remaining requests 
     before being throttled? 
     The answer lies in HTTP response headers. 



   [ Detailed design ]
                                                                                                                                                               
                                                             |-------------|                    
                                                             |             |                    
                                                             | Rules       |                    
                                                             |             |                    
                                                             |------x------|                    
                                                                   / \            
                                                                    |                                                                             
                                |-------------|              |------|------|                                  
                                |             |              |             |                                  
                                | Cahed rules |<-------------| Workers     |                                  
                                |             |              |             |                                  
                                |-------|-----|              |-------------|                                  
                                        |                                     
                                        |                                      
                                       \ /                                                                              
|-------------------|           |-------x-----|              |-------------|
|                   |           |             |              |             |
| Client            |---------->| Raye        |------------> | API Servers |
|                   |           | limiter     |              |             |
|-------------------|           |-|-----x-----|              |-------------|
                                  |    / \
                                  |     |
                                  |     |----------------------------|
                                  |                                 \ /
                                  |                          |-------x-----|
                                  |                          |             |
                             2 options:                      | Redis       |
                             - request dropped               |             |
                             - send to message queue         |-------------|



   (*)
   - Rules are stored on the disk. Workers frequently pull rules 
     from the disk and store them in the cache.
   - When a client sends a request to the server, 
     the request is sent to the rate limiter middleware first.
   - Rate limiter middleware loads rules from the cache. 
     It fetches counters and last request timestamp from Redis cache. 
     Based on the response, the rate limiter decides:
     - if the request is not rate limited, it is forwarded to API servers.
     - if the request is rate limited, 
       the rate limiter returns 429 too many requests error to the client. 
       In the meantime, the request is either dropped or forwarded to the queue.



   [ Rate limiter in a distributed environment ]
   - Building a rate limiter that works in a single server environment is not difficult. 
     However, scaling the system to support multiple servers 
     and concurrent threads is a different story.
     There are two challenges:
       1. Race condition
       2. Synchronization issue


   [ Race condition ]
   - As discussed earlier, rate limiter works as follows at the high-level:
     1. Read the counter value from Redis.
     2. Check if ( counter + 1 ) exceeds the threshold.
     3. If not, increment the counter value by 1 in Redis
   -...
   - Locks are the most obvious solution for solving race condition. 
     However, locks will significantly slow down the system. 
     Two strategies are commonly used to solve the problem: ...
     

   [ Synchronization issue ]
   - Synchronization is another important factor to consider in a distributed environment. 
     To support millions of users, 
     one rate limiter server might not be enough to handle the traffic.
     When multiple rate limiter servers are used, synchronization is required.



|----------|           |-------------|             |----------|           |-------------|
|          |           |             |             |          |           |             |
| Client 1 |---------->| Raye        |             | Client 1 |------|    | Raye        |
|          |           | limiter     |             |          |  |---x--->| limiter     |
|----------|           |-------------|             |----------|  |   |    |-------------|
                                                                 |   |                         
|----------|           |-------------|             |----------|  |   |    |-------------|
|          |           |             |             |          |  |   |--->|             |
| Client 2 |---------->| Raye        |             | Client 2 |--|        | Raye        |
|          |           | limiter     |             |          |           | limiter     |
|----------|           |-------------|             |----------|           |-------------|



   (*)
   - approach is to use centralized data stores like Redis


|----------|           |-------------|         |--------| 
|          |           |             |         |        |
| Client 1 |---------->| Raye        |-------->|        |
|          |           | limiter     |         |        |
|----------|           |-------------|         |        |
                                               | Redis  |
|----------|           |-------------|         |        | 
|          |           |             |         |        | 
| Client 2 |---------->| Raye        |-------->|        | 
|          |           | limiter     |         |        |    
|----------|           |-------------|         |--------| 




   [ Performance optimization ]
   - Performance optimization is a common topic in system design interviews. 
    We will cover two areas to improve.
    1. First, multi-data center setup is crucial for a rate limiter 
       because latency is high for users located far away from the data center. 
       Most cloud service providers build many edge server locations around the world. 
    2. Second, synchronize data with an eventual consistency model. 



   [ Monitoring ]
   - After the rate limiter is put in place, 
     it is important to gather analytics data to check whether the rate limiter is effective. 
     Primarily, we want to make sure:
     - The rate limiting algorithm is effective.
     - The rate limiting rules are effective


   [ Step 4 - Wrap up ]
   - In this chapter, we discussed different algorithms of rate limiting and their pros/cons.
     Algorithms discussed include:
     - Token bucket
     - Leaking bucket
     - Fixed window
     - Sliding window log
     - Sliding window counter
   -...
   - Then, we discussed the system architecture, rate limiter in a distributed environment,
     performance optimization and monitoring. 
     Similar to any system design interview questions, 
    there are additional talking points you can mention if time allows:
    - Hard vs soft rate limiting.
    - Hard: The number of requests cannot exceed the threshold.
    - Soft: Requests can exceed the threshold for a short period.
    - Rate limiting at different levels. In this chapter, 
      we only talked about rate limiting at the application level (HTTP: layer 7). 
      It is possible to apply rate limiting at other layers. 
      For example, you can apply rate limiting by IP addresses using Iptables [15] (IP: layer 3).
      Note: The Open Systems Interconnection model (OSI model) has 7 layers [16]: 
      Layer 1: Physical layer, 
      Layer 2: Data link layer, 
      Layer 3: Network layer, 
      Layer 4: Transport layer,
      Layer 5: Session layer, 
      Layer 6: Presentation layer, 
      Layer 7: Application layer.
    -...
    - Avoid being rate limited. Design your client with best practices:
      1. Use client cache to avoid making frequent API calls.
      2. Understand the limit and do not send too many requests in a short time frame.
      3. Include code to catch exceptions or errors 
         so your client can gracefully recover from exceptions.
      4. Add sufficient back off time to retry logic.






5) [ Chapter 5 ] DESIGN CONSISTENT HASHING
   - To achieve horizontal scaling, 
     it is important to distribute requests/data efficiently and evenly across servers. 
     Consistent hashing is a commonly used technique to achieve this goal.
 
    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         #

6) [ Chapter 6 ] DESIGN A KEY-VALUE STORE

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         #

7) [ Chapter 7 ] DESIGN A UNIQUE ID GENERATOR IN DISTRIBUTED SYSTEMS

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         #

8) [ Chapter 8 ] DESIGN A URL SHORTENER
   - In this chapter, 
     we will tackle an interesting and classic system design interview question:
     designing a URL shortening service like tinyurl.


   [ Step 1 - Understand the problem and establish design scope ]
   - questions:
     1. Can you give an example of how a URL shortener work?
     2. What is the traffic volume?
     3. How long is the shortened URL?
     4. What characters are allowed in the shortened URL?
     5. Can shortened URLs be deleted or updated?
   - Here are the basic use cases:
     1. URL shortening: given a long URL => return a much shorter URL
     2. URL redirecting: given a shorter URL => redirect to the original URL
     3. High availability, scalability, and fault tolerance considerations


   [ Back of the envelope estimation ]
   - Write operation: 100 million URLs are generated per day.
   - Write operation per second: 100 million / 24 /3600 = 1160
   - Read operation: 
     Assuming ratio of read operation to write operation is 10:1, 
     read operation per second: 1160 * 10 = 11,600
   - Assuming the URL shortener service will run for 10 years, 
     this means we must support 100 million * 365 * 10 = 365 billion records.
   - Assume average URL length is 100.
   - Storage requirement over 10 years: 365 billion * 100 bytes * 10 years = 365 TB


   [ Step 2 - Propose high-level design and get buy-in ]

   [ API Endpoints ]
   - API endpoints facilitate the communication between clients and servers.
   - A URL shortener primary needs two API endpoints.
     1. URL shortening. 
        To create a new short URL, a client sends a POST request, 
        which contains one parameter: 
        the original long URL. The API looks like this:
        
          POST api/v1/data/shorten
          • request parameter: {longUrl: longURLString}
          • return shortURL 
     ...
     2. URL redirecting. 
        To redirect a short URL to the corresponding long URL, 
        a client sends a GET request. 
        The API looks like this:

          GET api/v1/shortUrl
          • Return longURL for HTTP redirection
          (*)
            we can return 301 - statuse code
            and put original url to header "location"


   [ URL shortening ]
   - To support the URL shortening use case, 
     we must find a hash function fx that maps a long URL to the hashValue.
   - The hash function must satisfy the following requirements:
     - Each longURL must be hashed to one hashValue.
     - Each hashValue can be mapped back to the longURL 


   [ Step 3 - Design deep dive ]
   - In this section, we dive deep into the following: 
     data model, hash function, URL shortening and URL redirecting.

   [ Data model ]
   - we should store shortURL and longURL in database.
     url table:
      PK id (auto increment)
         shortURL
         longURL 


   [ Hash function ]
   - Hash function is used to hash a long URL to a short URL, also known as hashValue.

   [ Hash value length ]
   - The hashValue consists of characters 
     from [0-9, a-z, A-Z], containing 10 + 26 + 26 = 62 possible characters.

     lengthOfHash        Maximum number or URLs
       1                   62^1 = 62   
       2                   62^2 = 3,844
                ...
       7                   62^7 = 3,521,614,606,208 = ~ 3.5 trillion
      
      (*) When n = 7, 62 ^ n = ~3.5 trillion, 
          3.5 trillion is more than enough to hold 365 billion URLs, 
          so the length of hashValue is 7



   [ Hash + collision resolution ]
   - To shorten a long URL, 
     we should implement a hash function 
     that hashes a long URL to a 7- character string. 
     A straightforward solution is to use well-known hash functions 
     like CRC32, MD5, or SHA-1.
   - even the shortest hash value (from CRC32) is too long (more than 7characters). 
     How can we make it shorter?
     To resolve hash collisions, we can recursively append a new predefined string 
     until no more collision is discovered.


|-------|     |---------|     |----------|     |----------|                                                         
|       |     |         |     |          |     |          |                                                         
| Start |---->| input:  |---->| hash     |---->| ShortUrl |                                                         --->
|       |     | longURL |     | function |     |          |                                                          
|-------|     |---x-----|     |----------|     |-----|----|                                                         
                 / \                                 |           
                  |                                  |            
                  |                                  |            
                  |                                  |            
                  |                                 \ /            
          |-------|-----|                    |-------x-------|  
          | LongUrl +   |       yes          |               |  
          | predefined  |<-------------------| Exist in DB ? |  
          | string      |   has collision    |               |  
          |-------------|                    |-------|-------|  
                                                     |       
                                                     | no       
                                                     |       
                                                    \ /       
                                               |-----x-------|
                                               |             |
                                               | Save to DB  |
                                               |             |
                                               |-----|-------|                                                             
                                                     |       
                                                     |       
                                                    \ /       
                                                 |---x---|
                                                 |       |
                                                 | End   |
                                                 |       |
                                                 |-------|                                                              
                                                             
   - This method can eliminate collision; 
     however, it is expensive to query the database to check 
     if a shortURL exists for every request. 
     A technique called bloom filters can improve performance. 
     A bloom filter is a space-efficient probabilistic technique to test 
     if an element is a member of a set.                                                              
                                                                 
                                                                 
   [ Base 62 conversion ] 
   - Base conversion is another approach commonly used for URL shorteners.
     Let us use an example to explain how the conversion works: 
     convert 1115710 to base 62 representation
     1. From its name, base 62 is a way of using 62 characters for encoding. 
        The mappings are:
        0-0, ..., 9-9, 10-a, 11-b, ..., 35-z, 36-A, ..., 61-Z, 
        where ‘a’ stands for 10, ‘Z’ stands for 61, etc.


        base 62 representation:               
                        2         1          0
     2. 11157   = 2 x 62 + 55 x 62  + 59 x 62 = [2, 55, 59] -> [2, T, X] in base 62
             10


   [ Comparison of the two approaches ] 

   Hash + collision resolution      |   Base 62 conversion
                                    |
    Fixed short URL length          |     The short URL length is not fixed. 
                                          It goes up with the ID.
    
    It does not need a unique ID          This option depends on a unique ID
    generator.                            generator.

    
    Collision is possible                 Collision is impossible because ID 
    and must be resolved.                 is unique.
    
    
    It is impossible to figure out        It is easy to figure out the next available
    the next available short URL          short URL if ID increments by 1 for a new entry.
    because it does                       This can be a security concern.
    not depend on ID.


   [ URL shortening deep dive ] 
   As one of the core pieces of the system, 
   we want the URL shortening flow to be logically simple and functional.
   Base 62 conversion is used in our design.
 

|------------|              |--------------------|        |--------------------|                                                         
|            |              |                    |  yes   |                    |                                                         
| 1. input:  |------------->| 2. longURL in DB ? |------->| 3. return shortURL |                                                         --->
|    longURL |              |                    |        |                    |                                                          
|------------|              |---------|----------|        |--------------------|                                                         
                                 |           
                                 |  no                     
                                 |            
                                \ /            
                         |-------x-------|  
                         |               |  
                         | 4. Generate a |  
                         |    new ID     |  
                         |-------|-------|  
                                 |           
                                 |       
                                \ /       
                           |-----x------------|
                           |                  |
                           | 5. Convert ID to |
                           |    shortURL      |
                           |-----|------------|                                                             
                                 |       
                                 |       
                                \ /       
                             |---x--------------|
                             |                  |
                             | 6. Save ID,      |
                             |    shortURL,     |
                             |    longURL in DB |
                             |------------------| 



   [ URL redirect deep dive ] 



  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |---------------|-------------------|
                  |                                                                    
                 \ /          
            |-----x------|
            |            | 
            |    Load    |
            |  balancer  |
            |--|------|--| 
               |      |
          |----|      |------|
          |                  |
         \ /                \ /                                                                                                                                                
  |-------x-------|  |-------x-------|         |-------x-------|                                                                                                                                                        
  |               |  |               |         |               |                                                                                                                                                                                                                                                            
  | Web server 1  |  | Web server 2  |  .....  | Web server n  |                                                                                                                          
  |               |  |               |         |               |                                                                                                                       
  |---------------|  |---------------|         |---------------|
   

                   |
                   |
          |--------|---------|
         \ /                \ /
  |-------x-------|  |-------x-------|                                                                                                                                                        
  |               |  |               |                                                                                                                                                                                                                                                            
  |    Cache      |  |      DB       |                                                                                                                           
  |               |  |               |                                                                                                                       
  |---------------|  |---------------|




   [ Step 4 - Wrap up ] 
   - If there is extra time at the end of the interview, 
     here are a few additional talking points.
     1. Rate limiter: 
        A potential security problem 
        we could face is that malicious users send 
        an overwhelmingly large number of URL shortening requests. 
     2. Web server scaling: 
        Since the web tier is stateless, 
        it is easy to scale the web tier by adding or removing web servers.
     3. Database scaling: 
        Database replication and sharding are common techniques.
     4. Analytics: 
        Data is increasingly important for business success. 
        Integrating an analytics solution to the URL shortener could help 
        to answer important questions like how many people click on a link? 
        When do they click the link? etc.
     5. Availability, consistency, and reliability. 
        These concepts are at the core of any large system’s success. 
 



9) [ Chapter 9 ] DESIGN A WEB CRAWLER

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         #


10) [ Chapter 10 ] DESIGN A NOTIFICATION SYSTEM
    - A notification alerts a user with important information 
      like breaking news, product updates, events, offerings, etc. 
      It has become an indispensable part of our daily life.
    
    - A notification is more than just mobile push notification. 
      Three types of notification formats are: 
      mobile push notification, SMS message, and Email.


   [ Step 1 - Understand the problem and establish design scope ] 
   - Building a scalable system that sends out 
     millions of notifications a day is not an easy task. 
     It requires a deep understanding of the notification ecosystem.
   
   - questions:
     - What types of notifications does the system support?
     - Is it a real-time system? 
     - What are the supported devices?
     - What triggers notifications?
     - Will users be able to opt-out?   
     - How many notifications are sent out each day?



   [ Step 2 - Propose high-level design and get buy-in ] 
   - This section shows the high-level design 
     that supports various notification types: 
     iOS push notification, Android push notification, SMS message, and Email. 
     It is structured as follows:
     - Different types of notifications
     - Contact info gathering flow
     - Notification sending/receiving flow


   [ Different types of notifications ] 
   - We start by looking at how each notification type works at a high level.

   [ iOS push notification ] 
    
|------------|              |--------------------|        |--------------------|                                                         
|            |              |                    |        |                    |                                                         
| Provider   |------------->| APNs               |------->| IOS                |                                                         --->
|            |              |                    |        |                    |                                                          
|------------|              |--------------------|        |--------------------|   

   
   - We primary need three components to send an iOS push notification:
     1. Provider
     - Device token:
       This is a unique identifier used for sending push notifications.
     - Payload:  
       This is a JSON dictionary that contains a notification’s payload.

     2. APNS:    
     - This is a remote service provided by Apple 
       to propagate push notifications to iOS devices.

     3. iOS Device: 
     - It is the end client, which receives push notifications. 


   [ Android push notification ] 
   - Android adopts a similar notification flow. 
     Instead of using APNs, Firebase Cloud Messaging(FCM) 
     is commonly used to send push notifications to android devices.

|------------|              |--------------------|        |--------------------|                                                         
|            |              |                    |        |                    |                                                         
| Provider   |------------->| FMC                |------->| Android            |                                                         --->
|            |              |                    |        |                    |                                                          
|------------|              |--------------------|        |--------------------|   


   [ SMS message ] 
   - For SMS messages, third party SMS services like Twilio, Nexmo, 
     and many others are commonly used.


|------------|              |--------------------|        |--------------------|                                                         
|            |              |                    |        |                    |                                                         
| Provider   |------------->| SMS Service        |------->| Sms                |                                                         --->
|            |              |                    |        |                    |                                                          
|------------|              |--------------------|        |--------------------|  


   [ Email ] 
   - Although companies can set up their own email servers, 
     many of them opt for commercial email services. 
     Sendgrid and Mailchimp.


|------------|              |--------------------|        |--------------------|                                                         
|            |              |                    |        |                    |                                                         
| Provider   |------------->| Email Service      |------->| Email              |                                                         --->
|            |              |                    |        |                    |                                                          
|------------|              |--------------------|        |--------------------|  


   [ Contact info gathering flow ] 
   - To send notifications, we need to gather mobile device tokens, 
     phone numbers, or emailaddresses. 
     When a user installs our app or signs up for the first time,
     API servers collect user contact info and store it in the database. 


|------|     |---------------|     |--------------------|     |---------------|                                                                                         
|      |     |               |     |                    |     |               |                                                                                         
| User |---->| Load balancer |---->| API servers        |---->| DB            |                                                                                         --->
|      |     |               |     |                    |     |               |                                                                                          
|------|     |---------------|     |--------------------|     |---------------|                                  









|---------|
|         |
| Service |-------|
|    1    |       |
|---------|       |
                  |
                  |
                 \ /
|---------|     |-x-------------|     |--------------------|     |---------------|                                                                                         
|         |     |               |     |                    |     |               |                                                                                         
| Service |---->| Notification  |---->| Third Party        |---->| Device        |                                                                                         --->
|    2    |     | System        |     | Services           |     |               |                                                                                          
|---------|     |-x-------------|     |--------------------|     |---------------|   
                 / \
                  |
                  |
|---------|       |
|         |       |
| Service |-------|
|    n    |
|---------|


   [ Service 1 to N ] 
   - A service can be a micro-service, a cron job, or a distributed system that
     triggers notification sending events.

   [ Notification system ] 
   - The notification system is the centerpiece of sending/receiving notifications. 
   - Starting with something simple, only one notification server is used. 
     It provides APIs for services 1 to N, 
     and builds notification payloads for third party services. 

   [ Third-party services ] 
   - Third party services are responsible for delivering notifications to users.

   [ iOS, Android, SMS, Email ] 
   - Users receive notifications on their devices. 
     Three problems are identified in this design:
     1. Single point of failure (SPOF): 
        A single notification server means SPOF.
     2. Hard to scale: 
        The notification system handles everything related 
        to push notifications in one server. 
        It is challenging to scale databases, caches, 
        and different notification processing components independently.
     3. Performance bottleneck:
        Processing and sending notifications can be resource intensive. 

   [ High-level design (improved) ] 
   - After enumerating challenges in the initial design, 
     we improve the design as listed below:
     1. Move the database and cache out of the notification server.
     2. Add more notification servers and set up automatic horizontal scaling.
     3. Introduce message queues to decouple the system components.



                                  |---------|   |---------|                    
|---------|                       |         |   |         |                         
|         |                    |->| IOS     |-->| Workers |--|               
| Service |----|               |  | queue   |   |         |  |                    
|    1    |    |               |  |---------|   |---------|  |                                                  
|---------|    |               |                             |               
               |               |  |---------|   |---------|  |          
               |               |  |         |   |         |  |        
              \ /              |->| Android |-->| Workers |--|           
|---------|   |-x------------| |  | queue   |   |         |  |   |-------------|                                                                                         
|         |   |              | |  |---------|   |---------|  |   |             |                                                                                         
| Service |-->| Notification |-X                             |-->| Third Party |          
|    2    |   | System       | |  |---------|   |---------|  |   | Services    |                                                                                          
|---------|   |-x------|-----| |  |         |   |         |  |   |-----|-------|   
              / \      |       |->| SMS     |-->| Workers |--|         |        
               |       |       |  | queue   |   |         |  |         |            
               |       |       |  |---------|   |---------|  |        \ /              
|---------|    |       |       |                             |   |-----x-------|                                 
|         |    |       |       |  |---------|   |---------|  |   |             |                                           
| Service |----|       |       |  |         |   |         |  |   | Devices     |               
|    n    |            |       |->| Email   |-->| Workers |--|   |             |               
|---------|            |          | queue   |   |         |      |-------------|           
                       |          |---------|   |---------|                  
                      \ /                                                                     
                  |----x----|
                  |         |
                  | Cache   |
                  |         |
                  |----|----|                                                                              
                       |                                       
                      \ /                                      
                  |----x----|                                                             
                  |         |                                                             
                  | DB      |                                                             
                  |         |                                                             
                  |---------|                                                             
                                                              
                                                              

   [ Service 1 to N ] 
   - They represent different services that send notifications via APIs 
     provided by notification servers.

   [ Notification servers ] 
   - They provide the following functionalities:
     1. Provide APIs for services to send notifications. 
        Those APIs are only accessible internally 
        or by verified clients to prevent spams.
     2. Carry out basic validations to verify emails, phone numbers, etc.
     3. Query the database or cache to fetch data needed to render a notification.
     4. Put notification data to message queues for parallel processing.

   [ Cache ] 
   - User info, device info, notification templates are cached.

   [ DB ] 
   - It stores data about user, notification, settings, etc.

   [ Message queues ]
   - They remove dependencies between components. 
     Message queues serve as buffers 
     when high volumes of notifications are to be sent out. 

   [ Workers ]
   - Workers are a list of servers that pull notification events 
     from message queues and send them to the corresponding third-party services. 

   [ Third-party services ]
   - Already explained in the initial design.

   [ iOS, Android, SMS, Email ]
   - Already explained in the initial design.

   (*)
   - Next, 
     let us examine how every component works together to send a notification:
     1. A service calls APIs provided by notification servers to send notifications.
     2. Notification servers fetch metadata such as user info, 
        device token, and notification setting from the cache or database.
     3. A notification event is sent to the corresponding queue for processing. 
        For instance, an iOS push notification event is sent to the iOS PN queue.
     4. Workers pull notification events from message queues.
     5. Workers send notifications to third party services.
     6. Third-party services send notifications to user devices. 


   [ Step 3 - Design deep dive ] 
   - In the high-level design, we discussed different types of notifications, 
     contact info gathering flow, and notification sending/receiving flow. 
     We will explore the following in deep dive:
     1. Reliability
     2. Additional component and considerations: 
        notification template, notification settings, 
        rate limiting, retry mechanism, security in push notifications, 
        monitor queued notifications and event tracking.
     3. Updated design


   [ Reliability ] 
   - We must answer a few important reliability questions 
     when designing a notification system in distributed environments.


   [ How to prevent data loss? ] 
   - One of the most important requirements 
     in a notification system is that it cannot lose data.
   - Notifications can usually be delayed or re-ordered, but never lost. 
     To satisfy this requirement, 
     the notification system persists notification data in a database 
     and implements a retry mechanism. 
     The notification log database is included for data persistence.



|---------|     |---------------|     |----------- -|                                                                                         
|         |     |               |     |             |                                                                                         
| Queue   |---->| Workers       |---->| APNs        |                                                                                         --->
|         |     |               |     |             |                                                                                          
|---------|     |-----|---------|     |-------------|   
                      |
                      |
                     \ /
                 |----x---------|        
                 |              |        
                 | Notification | 
                 | log          |
                 |--------------|



   [ Will recipients receive a notification exactly once? ] 
   - The short answer is no. 
     Although notification is delivered exactly once most of the time, 
     the distributed nature could result in duplicate notifications. 
     To reduce the duplication occurrence, 
     we introduce a dedupe mechanism and handle each failure case carefully. 



   [ Additional components and considerations ] 
   - We have discussed how to collect user contact info, 
     send, and receive a notification. 
     A notification system is a lot more than that. 
     Here we discuss additional components including template reusing, 
     notification settings, event tracking, system monitoring, rate limiting, etc.


   [ Notification template ] 
   - A large notification system sends out millions of notifications per day, 
     and many of these notifications follow a similar format. 
     Notification templates are introduced to avoid building 
     every notification from scratch.


   [ Notification setting ] 
   - Users generally receive way too many notifications daily 
     and they can easily feel overwhelmed. 
     Thus, many websites and apps give users fine-grained control 
     over notification settings. 


   [ Rate limiting ] 
   - To avoid overwhelming users with too many notifications, 
     we can limit the number of notifications a user can receive. 
     This is important because receivers could turn off 
     notifications completely if we send too often.


   [ Retry mechanism ] 
   - When a third-party service fails to send a notification, 
     the notification will be added to the message queue for retrying. 
     If the problem persists, an alert will be sent out to developers.


   [ Security in push notifications ] 
   - For iOS or Android apps, appKey 
     and appSecret are used to secure push notification APIs. 
     Only authenticated or verified clients 
     are allowed to send push notifications using our APIs. 
     Interested users should refer to the reference material.


   [ Monitor queued notifications ] 
   - A key metric to monitor is the total number of queued notifications. 
     If the number is large, the notification events 
     are not processed fast enough by workers. 
     To avoid delay in the notification delivery, more workers are needed. 



   [ Events tracking ] 
   - Notification metrics, such as open rate, click rate, 
     and engagement are important in understanding customer behaviors. 
     Analytics service implements events tracking. 
     Integration between the notification system 
     and the analytics service is usually required.



   [ Updated design ] 

   ...

   (*)
   - In this design, 
     many new components are added in comparison with the previous design.
     1. The notification servers are equipped with two more critical features: 
        authentication and rate-limiting.
     2. We also add a retry mechanism to handle notification failures. 
        If the system fails to send notifications, 
        they are put back in the messaging queue 
        and the workers will retry for a predefined number of times.
     3. Furthermore, notification templates provide a consistent 
        and efficient notification creation process.
     4. Finally, monitoring 
        and tracking systems are added for system health checks 
        and future improvements 


   [ Step 4 - Wrap up ] 
   - Besides the high-level design, 
     we dug deep into more components and optimizations.
     1. Reliability: 
        We proposed a robust retry mechanism to minimize the failure rate.
     2. Security: 
        AppKey/appSecret pair is used to ensure only verified clients 
        can send notifications.
     3. Tracking and monitoring: 
        These are implemented in any stage of a notification flow 
        to capture important stats.
     4. Respect user settings: 
        Users may opt-out of receiving notifications. 
        Our system checks user settings first before sending notifications.
     5. Rate limiting: 
        Users will appreciate a frequency capping 
        on the number of notifications they receive.











11) [ Chapter 11 ] DESIGN A NEWS FEED SYSTEM

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         #




12) [ Chapter 12 ] DESIGN A CHAT SYSTEM

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         #



13) [ Chapter 13 ] DESIGN A SEARCH AUTOCOMPLETE SYSTEM

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         #


14) [ Chapter 14 ] DESIGN YOUTUBE

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         # 


15) [ Chapter 15 ] DESIGN GOOGLE DRIVE

    #         #
    #         #
    #         # 
    #         #
    #  Skip   #
    #         #
    #         #
    #         #
    #         # 





                                                                                                                                                                            
system-design-interview-book add summery



119th page in chrome











[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
