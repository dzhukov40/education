---
Ресурсы:

// book: System Design Interview
  - [ https://www.amazon.de/-/en/System-Design-Interview-insiders-guide/dp/B08CMF2CQF ]
// web site:
  - [ https://bytebytego.com/ ]



---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ System Design Interview ] это одна из лучших книг по системному дизайну для интервью.



1) [ Chapter 1 ] SCALE FROM ZERO TO MILLIONS OF USERS
   [ Single server setup ] 
   - We can start with one server where all components will be inside.
     (web app, database, cache, etc.)
 
                                                                                       
  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |-------|------------------|--------|
          |                  |                                                          
          |                  |
          |                  |                                                          
         \ /                \ /                                                                                                                                                
  |-------x------------------x--------|                                                                                                                                                               
  |                                   |                                                                                                                                                                                                                                                                         
  |            Web server             |                                                                                                                                     
  |                                   |                                                                                                                                     
  |-----------------------------------|                                                                                                                                       
                                                                                                                                                                            
                                                                                                                                                                            
   [ Database ]                                                                                                                                                                          
   - With the growth of the user base we need another server with database.


  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |-------|------------------|--------|
          |                  |                                                          
          |                  |
          |                  |                                                          
         \ /                \ /                                                                                                                                                
  |-------x------------------x--------|      |------------|                                                                                                                                                         
  |                                   |----->|            |                                                                                                                                                                                                                                                             
  |            Web server             |      |  Database  |                                                                                                                            
  |                                   |<-----|            |                                                                                                                         
  |-----------------------------------|      |------------|


   [ Which databases to use? ]                                                                                                                                                                          
   -           database
              /        \ 
             /          \
            /            \
          SQL             \
(Relational database)    NoSql
- postgresql             - key-value 
                         - graph 
                         - column
                         - document
                         - timeseries


   [ Vertical scaling vs horizontal scaling ]                                                                                                                                                                          
   - Vertical
     - add to one server CPU, RAM, DISCK, etc.
     - pros: simple
       cons: 1. impossible add millions of CPU, RAM, DISC, etc.
             2. does not have failover and redundancy.
   - horizontal   
     - add more servers.
     - pros: 1. failover
             2. fault-tolerance  
             3. scalable
       cons: 1. difficult
             2. dublication
             3. not efficient useage of resources




   [ Load balancer ]   
   - we can add more servers for handeling more requests.
   - we can balance load.

  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |---------------|-------------------|
                  |                                                                    
                 \ /          
            |-----x------|
            |            | 
            |    Load    |
            |  balancer  |
            |--|------|--| 
               |      |
          |----|      |------|
          |                  |
         \ /                \ /                                                                                                                                                
  |-------x-------|  |-------x-------|                                                                                                                                                        
  |               |  |               |                                                                                                                                                                                                                                                            
  | Web server 1  |  | Web server 2  |                                                                                                                           
  |               |  |               |                                                                                                                       
  |---------------|  |---------------|



   [ Database replication ]   
   - usually we have master and slave pattern
     master for modefy operations (update/insert)
     slave for not modefying operations (read)
   -...
   - Advantages of database replication:
     - Better performance: (more servers can handle more requests)
     - Reliability: If one of your database servers is destroyed it is not a problem.
     - High availability: replicating data across different locations
     - 

            |------------|
            |            | 
            |     Web    |
            |   servers  |
            |--|------|--| 
               |      |
       |-------|      |--------------x----x----x
       |                             |    |    |
       |                          reads   |    |
       |                             |    |    |
       |              |---------|    |    |    |
     writes           |         |    |    |    |
       |        |---->| Slave   |<---|    |    |
       |        |     |   DB 1  |         |    |
       |        |     |---------|         |    |                      
       |        |                         |    |
      \ /       |                         |    |                                                                                                                                                                   
  |----x----|   |     |---------|       reads  |                                                                                                                                                        
  |         |   |     |         |         |    |                                                                                                                                                                                                                                                           
  | Mastrer |<--x---->| Slave   |<--------|    |                                                                                                                               
  |   DB    |   |     |   DB 2  |              |                                                                                                                 
  |---------|   |     |---------|              |  
                |                              |
                |                            reads
                |     |---------|              |      
                |     |         |              |       
                |---->| Slave   |<-------------|                     
                      |   DB 3  |                     
                      |---------|                     



  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |---------------|-------------------|
                  |                                                                    
                 \ /          
            |-----x------|
            |            | 
            |    Load    |
            |  balancer  |
            |--|------|--| 
               |      |
          |----|      |--------|
          |                    |
         \ /                  \ /                                                                                                                                                
  |-------x-------|    |-------x-------|                                                                                                                                                        
  |               |    |               |                                                                                                                                                                                                                                                            
  | Web server 1  |    | Web server 2  |                                                                                                                           
  |               |    |               |                                                                                                                       
  |-|---------|---|    |--|----------|-|
    |         |           |        read
  write       |-read------|----|     |
    |    |----------write-|    |     |
   \ /  \ /                    \ /   \ /
|---x----x|                  |-x-----x-|                      
|         |    Replicate     |         |                    
| Mastrer |<---------------->| Slave   |                    
|   DB    |                  |   DB    |                    
|---------|                  |---------|                    
  



   [ Cache ]  
   - A cache is a temporary storage area that stores 
     the result of expensive responses or frequently
     accessed data in memory so that subsequent requests 
     are served more quickly

   [ Cache tier ]
   - The cache tier is a temporary data store layer, 
     much faster than the database.



    1. if data exists in cache, read data from cache
              |  
              |
|--------|   \ /              |-------|          |----------|
|        |<---x---------------| Cache |          |          |
| Web    |                    |       |          | Database |
| server |<---x---------------|       |<--x------|          |
|--------|   / \              |-------|  / \     |----------|
              |                           |
              |                2.1 if date doesn't exist in cache,           
              |                    save data to cache.
              |
    2.2 Return data to the web server



   [ Considerations for using cache ]
   - Decide when to use cache.
     Consider using cache when data is read frequently but modified infrequently.
   -...
   - Expiration policy.
     It is a good practice to implement an expiration policy.
     Once cached data is expired, it is removed from the cache.  
   -...
   - Consistancy.
     This involves keeping the data store and the cache in sync.
   -...
   - Mitigating failures
     A single cache server represents a potential single point of failure.
   -...
   - Eviction Policy
     Least-recently-used (LRU) is the most popular cache eviction policy.



   [ Content delivery network (CDN) ]
   - A CDN is a network of geographically 
     dispersed servers used to deliver static content.
   - CDN servers cache static content like images, 
     videos, CSS, JavaScript files, etc.
   - when a user visits a website, a CDN server closest
     to the user will deliver static content. 
     Intuitively, the further users are from CDN servers, 
     the slower the website loads.



   [ Considerations of using a CDN ]
   - Cost:
     CDNs are run by third-party providers, 
     and you are charged for data transfers in and out of the CDN
   - Setting an appropriate cache expiry:
     The cache expiry time should neither be too long nor too short.
   - CDN fallback:
     If there is a temporary CDN outage, clients should be able to detect the problem
     and request resources from the origin.
   - Invalidating files:
     You can remove a file from the CDN before it expires



   [ Stateless web tier ]
   - A good practice is to store session data in
     the persistent storage such as relational database or NoSQL 
   

   [ Stateful architecture ]
   - A stateful server and stateless server has some key differences. 
     A stateful server remembers client data (state) from one request to the next. 
     A stateless server keeps no state information.


   [ Stateless architecture ]
   - In this stateless architecture, 
     HTTP requests from users can be sent to any web servers, which
     fetch state data from a shared data store.
   - A stateless system is simpler, more robust, and scalable.


|--------|        |--------|        |--------|
|        |        |        |        |        |
| User A |        | User B |        | User C |
|        |        |        |        |        |
|---|----|        |---|----|        |---|----|
    |                 |                 |
    |                 |                 |
   \ /               \ /               \ /
|---x-----------------x-----------------x----|
|                                            |
|                 Web servers                |
|                                            |
|---------------------|----------------------|
                      |
                      |
                     \ /
                 |----x----|
                 | Shared  |
                 | Storage |   
                 |---------| 



   [ Data centers ]
   - Several technical challenges must be resolved to achieve multi-data center setup:
     1. Traffic redirection 
        Effective tools are needed to direct traffic to the correct data center.
     2. Data synchronization
        A common strategy is to replicate data across multiple data centers. 
     3. Test and deployment
        With multi-data center setup, it is important to test your
        website/application at different locations



   [ Message queue ]
   - It serves as a buffer and distributes asynchronous requests. 




|----------|           |-----------|     consume   |-----------|
|          |  publish  | Message   |-------------->|           |
| Producer |---------->| Queue     |   subscribe   | Consumer  |
|          |           |           |<-- - - - - - -|           |
|----------|           |-----------|               |-----------|



   [ Logging, metrics, automation ]
   - Logging
    Monitoring error logs is important because 
    it helps to identify errors and problems in the system
  - Metrics
    1. Host level metrics: CPU, Memory, disk I/O, etc.
    2. Aggregated level metrics: for example, the performance of the entire database tier, 
       cache tier, etc.
    3. Key business metrics: daily active users, retention, revenue, etc.
  - Automation
    Continuous integration is a good practice, in which each code
    check-in is verified through automation, allowing teams to detect problems early



   [ Database scaling ]
   - There are two broad approaches for database scaling: 
     vertical scaling and horizontal scaling.

   [ Vertical scaling ]
   - You can add more CPU, RAM, etc. to your database server, 
     but there are hardware limits. 
     If you have a large user base, a single server is not enough.
   - Greater risk of single point of failures.
   - The overall cost of vertical scaling is high. 
     Powerful servers are much more expensive


   [ Horizontal scaling ]
   - Horizontal scaling, also known as sharding, is the practice of adding more servers.
   (*) Sharding separates large databases into smaller, 
       more easily managed parts called shards.
       Each shard shares the same schema, 
       though the actual data on each shard is unique to the shard.
    -...
    - The most important factor to consider when implementing a sharding strategy 
      is the choice of the sharding key
    -...
    - Problems:
      1. Resharding data
         When shard exhaustion happens, it requires
         updating the sharding function and moving data around
      2. Celebrity problem
         This is also called a hotspot key problem.
         Imagine data for Katy Perry, Justin Bieber, 
         and Lady Gaga all end up on the same shard.
      3. Join and de-normalization.
         A common workaround is to denormalize the database 
         so that queries can be performed in a single table.



                |-------------|
                |             |
   |------------| user_id % 4 |-----------|
   |            |             |           |
   |            |-------------|           |
   |              |         |             |                    
   |              |         |             |                    
   |              |         |             |  
  \ /            \ /       \ /           \ /  
|--x--|      |----x|      |-x---|      |--x--|
|     |      |     |      |     |      |     |
|  0  |      |  1  |      |  2  |      |  3  |
|     |      |     |      |     |      |     |
|-----|      |-----|      |-----|      |-----|






   [ Millions of users and beyond ]
   - Scaling a system is an iterative process.
   - To conclude this chapter, we provide a summary of how we scale
     our system to support millions of users:
     1 Keep web tier stateless
     2 Build redundancy at every tier
     3 Cache data as much as you can
     4 Support multiple data centers
     5 Host static assets in CDN
     6 Scale your data tier by sharding
     7 Split tiers into individual services
     8 Monitor your system and use automation tools
     




2) [ Chapter 2 ] BACK-OF-THE-ENVELOPE ESTIMATION
   - In a system design interview, 
     sometimes you are asked to estimate system capacity or performance requirements 
     using a back-of-the-envelope estimation. 
   - You need to have a good sense of scalability basics 
     to effectively carry out back-of-theenvelope estimation.



   [ Power of two ]
   - Although data volume can become enormous when dealing with distributed systems,
     calculation all boils down to the basics. 
   - To obtain correct calculations, it is critical to know 
     the data volume unit using the power of 2.



   [ Latency numbers every programmer should know ]
   - those numbers should still be able to give us an idea of the fastness 
     and slowness of different computer operations.
   - By analyzing the numbers, we get the following conclusions:
     1. Memory is fast but the disk is slow.
     2. Avoid disk seeks if possible.
     3. Simple compression algorithms are fast.
     4. Compress data before sending it over the internet if possible.
     5. Data centers are usually in different regions, 
        and it takes time to send data between them.  


     *   | Operation name                     |   Time
         |------------------------------------|------------------------------------  
                                              |
          L1 cache reference ---------------- | -> 0.5 ns
                                              |
          Branch mispredict ----------------- | -> 5 ns
                                              |
          L2 cache reference ---------------- | -> 7 ns
                                              |
          Mutex lock/unlock ----------------- | -> 100 ns
                                              |
          Main memory reference ------------- | -> 100 ns
                                              |
          Compress 1K bytes with Zippy ------ | -> 10,000 ns = 10 us
                                              |
          Send 2K bytes --------------------- | -> 20,000 ns = 20 us
          over 1 Gbps network                 |
                                              |
          Read 1 MB ------------------------- | -> 250,000 ns = 250 us
          sequentially from memory            |
                                              |
          Round trip within ----------------- | -> 500,000 ns = 500 us
          the same datacenter                 |
                                              |
          Disk seek ------------------------- | -> 10,000,000 ns = 10 ms
                                              |
          Read 1 MB sequentially ------------ | -> 10,000,000 ns = 10 ms
          from the network                    |
                                              |
          Read 1 MB sequentially from disk -- | -> 30,000,000 ns = 30 ms
                                              |
          Send packet CA (California) ------- | -> 150,000,000 ns = 150 ms
          to Netherlands to CA                |




   [ Availability numbers ]
   - High availability is the ability of a system to be continuously operational 
     for a desirably long period of time.
   - High availability is measured as a percentage, 
     with 100% means a service that has 0 downtime. 
   - Most services fall between 99% and 100%.
   
  
     *   | Availability %     | Downtime per day       | Downtime per year 
         |--------------------|------------------------|-----------  
                              |                        |
           99% -------------- | 14.40 minutes          | 3.65 days
                              |                        |
           99.9% ------------ | 1.44 minutes           | 8.77 hours
                              |                        |
           99.99% ----------- | 8.64 seconds           | 52.60 minutes
                              |                        |
           99.999% ---------- | 864.00 milliseconds    | 5.26 minutes
                              |                        |
           99.9999% --------- | 86.40 milliseconds     | 31.56 seconds
                              |                        |



   [ Example: Estimate Twitter QPS and storage requirements ]
   Assumptions:
     • 300 million monthly active users.
     • 50% of users use Twitter daily.
     • Users post 2 tweets per day on average.
     • 10% of tweets contain media.
     • Data is stored for 5 years.
   Estimations:
   Query per second (QPS) estimate:
     • Daily active users (DAU) = 300 million * 50% = 150 million
     • Tweets QPS = 150 million * 2 tweets / 24 hour / 3600 seconds = ~3500
     • Peek QPS = 2 * QPS = ~7000
   We will only estimate media storage here.
     • Average tweet size:
     • tweet_id 64 bytes
     • text 140 bytes
     • media 1 MB
     • Media storage: 150 million * 2 * 10% * 1 MB = 30 TB per day
     • 5-year media storage: 30 TB * 365 * 5 = ~55 PB



   [ Tips ]
   - Back-of-the-envelope estimation is all about the process. 
   - Solving the problem is more important than obtaining results. 
   - Interviewers may test your problem-solving skills. 
   - Here are a few tips to follow:
     1. Rounding and Approximation.
        Use round numbers and approximation to your advantage.
     2. Write down your assumptions.
        It is a good idea to write down your assumptions to be referenced later.
     3. Label your units.
        When you write down “5”, does it mean 5 KB or 5 MB?
     4. Commonly asked back-of-the-envelope estimations. 
        QPS, peak QPS, storage, cache, number of servers, etc. 
        You can practice these calculations when preparing for an interview. 
        Practice makes perfect




3) [ Chapter 3 ] A FRAMEWORK FOR SYSTEM DESIGN INTERVIEWS
   - The system design interview simulates real-life problem solving 
     where two co-workers collaborate on an ambiguous problem 
     and come up with a solution that meets their goals. 
   - This allows you to demonstrate your design skill, 
     defend your design choices, and respond to feedback in a constructive manner. 


   [ A 4-step process for effective system design interview ]
   - Every system design interview is different. 
   - A great system design interview is open-ended 
     and there is no one-size-fits-all solution. 
   - However, there are steps and common ground to cover 
     in every system design interview.


   [ Step 1 - Understand the problem and establish design scope ]
   - Slow down. 
   - Think deeply and ask questions to clarify requirements and assumptions.
   - Here is a list of questions to help you get started:
     1. What specific features are we going to build?
     2. How many users does the product have?
     3. How fast does the company anticipate to scale up? 
        What are the anticipated scales in 3 months, 6 months, and a year?
     4. What is the company’s technology stack? 
        What existing services you might leverage to simplify the design?


  
   [ Example ]
   - If you are asked to design a news feed system, 
     you want to ask questions that help you clarify the requirements.
   - questions:
     1. Is this a mobile app? Or a web app? Or both?
     2. What are the most important features for the product?
     3. How many friends can a user have? 
     4. What is the traffic volume?
     5. Can feed contain images, videos, or just text?


   [ Step 2 - Propose high-level design and get buy-in ]
   - In this step, we aim to develop a high-level design 
     and reach an agreement with the interviewer on the design.
     1. Come up with an initial blueprint for the design.
        Ask for feedback.
        Treat your interviewer as a teammate and work together.
     2. Draw box diagrams with key components on the whiteboard or paper.
        This might include clients (mobile/web), 
        APIs, web servers, data stores, cache, CDN, message queue, etc.
     3. Do back-of-the-envelope calculations to evaluate 
        if your blueprint fits the scale constraints.
   - Should we include API endpoints and database schema here? 
     This depends on the problem.
     For large design problems like “Design Google search engine”, 
     this is a bit of too low level.
  
   [ Example ]
   - Let us use “Design a news feed system” to demonstrate 
     how to approach the high-level design.
   - At the high level, the design is divided into two flows: 
     1. feed publishing.
     2. news feed building.




  |-----------------------------------| 
  | User                              |
  |                                   |
  |    Web browser       Mobile app   |
  |                                   |                                                
  |---------------|-------------------|
                  |                                                                    
                 \ /          
            |-----x------|
            |            | 
            |    Load    |
            |  balancer  |
            |-----|------| 
                  |   
                  |
                 \ /                                                                                                                                                          
          |-------x-------|                                                                                                                                                         
          |               |                                                                                                                                                                                                                                                       
          | Web server 1  |                                                                                                                      
          |               |                                                                                                                 
          |-|-------|---|-|  
            |       |   |---------|
    |-------|       |             |
   \ /             \ /           \ /
|---x-----|    |----x----|    |---x----------|                       
|         |    |         |    |              |           
| Post    |    | Fanout  |    | Notification |                     
| Service |    | Service |    | Service      |                     
|---|-----|    |---|-----|    |--------------|   
    |              |
    |              |
   \ /            \ /
|---x-----|    |---x-----|
|         |    |         |
| Post    |    | Post    |
| Cache   |    | Cache   |
|---|-----|    |---------|
    |
    |
   \ /
|---x-----|
|         |
| Post    |
| DB      |
|---------|




   [ Step 3 - Design deep dive ]
   At this step, you and your interviewer should have already achieved 
   the following objectives:
   1. Agreed on the overall goals and feature scope
   2. Sketched out a high-level blueprint for the overall design
   3. Obtained feedback from your interviewer on the high-level design
   4. Had some initial ideas about areas to focus on 
      in deep dive based on her feedback
   -...
   - Try notto get into unnecessary details. 
     For example, talking about the EdgeRank algorithm of Facebook feed 
     ranking in detail is not ideal during a system design interview as this takes
     much precious time and does not prove your ability in designing a scalable system.



   [ Step 4 - Wrap up ]
   - In this final step, the interviewer might ask you a few follow-up questions 
     or give you the freedom to discuss other additional points. 
     Here are a few directions to follow:
     1. The interviewer might want you to identify the system bottlenecks 
        and discuss potential improvements.
        Never say your design is perfect and nothing can be improved 
     2. It could be useful to give the interviewer a recap of your design.
     3. Error cases (server failure, network loss, etc.) are interesting to talk about.
     4. Operation issues are worth mentioning. How do you monitor metrics and error logs?
        How to roll out the system?
     5. How to handle the next scale curve is also an interesting topic. 
        For example, if your current design supports 1 million users, 
        what changes do you need to make to support 10 million users?
     6. Propose other refinements you need if you had more time.
  -...
  - To wrap up, we summarize a list of the Dos and Don’ts.
    Dos:
    1. Always ask for clarification. Do not assume your assumption is correct.
    2. Understand the requirements of the problem.
    3. There is neither the right answer nor the best answer.
    4. Let the interviewer know what you are thinking. 
       Communicate with your interview.
    5. Suggest multiple approaches if possible. 
    6. Once you agree with your interviewer on the blueprint, 
       go into details on each component. 
       Design the most critical components first.
    7. Bounce ideas off the interviewer. 
       A good interviewer works with you as a teammate
    8. Never give up.
    -...
    Donts:
    1. Don't be unprepared for typical interview questions
    2. Don’t jump into a solution without clarifying the requirements and assumptions.
    3. Don’t go into too much detail on a single component in the beginning. 
       Give the highlevel design first then drills down.
    4. If you get stuck, don't hesitate to ask for hints.
    5. Again, communicate. Don't think in silence.
    6. Don’t think your interview is done once you give the design. 
       You are not done until your interviewer says you are done. 
       Ask for feedback early and often.


   [ Time allocation on each step ]
   - System design interview questions are usually very broad, 
     and 45 minutes or an hour is not enough to cover the entire design.
     - Step 1 Understand the problem and establish design scope: 3 - 10 minutes
     - Step 2 Propose high-level design and get buy-in: 10 - 15 minutes
     - Step 3 Design deep dive: 10 - 25 minutes
     - Step 4 Wrap: 3 - 5 minutes

























                                                                                                                                                                            
system-design-interview-book add summery



51th page in chrome











[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
