#!/bin/bash

msg1="http://www.opennet.ru/docs/RUS/zlp/index.html
!-!  копирование каталога с содержимым [ cp -r ./test_8 ./test_9 ]"

msg2=" Одни процессы могут порождать другие процессы, образовывая 
древовидную структуру. Порождающие процессы называются родителями 
или родительскими процессами, а порожденные - потомками или дочерними 
процессами. На вершине этого [дерева] находится процесс [init], который 
порождается автоматически ядром в процесссе загрузки системы.

К каждому процессу в системе привязана пара целых неотрицательных чисел: 
идентификатор процесса [PID (Process IDentifier)] и идентификатор 
родительского процесса [PPID (Parent Process IDentifier)]. Для каждого 
процесса [PID] является уникальным (в конкретный момент времени), а [PPID]
равен идентификатору процесса-родителя.

Процесс в Linux - это нечто, выполняющее программный код. Этот код называют 
образом процесса (process image). Рассмотрим простой пример, когда вы 
находитесь в оболочке [bash] и выполняете команду [ls]. В этом случае 
происходит следующее. Образ программы-оболочки [bash] выполняется в 
процессе [#1]. Затем вы вводите команду [ls], и оболочка определяет, 
что нужно запустить внешнюю программу (/bin/ls). Тогда процесс [#1] 
создает свою почти точную копию, процесс [#2], который выполняет тот же самый 
программный код. После этого процесс [#2] заменяет свой текущий образ (оболочку) 
другим образом (программой /bin/ls). В итоге получаем отдельный процесс, 
выполняющий отдельную программу.

   начитая с этой точки [pid_t pid = fork ();] 
   дальше выполняется код двумя прочессами
   определить кто есть кто помогает [pid]
   для [child] он [0] 
   для [parent] получит индификатор [child]

Что же происходит с данными при [клонировании] процесса. Итак, каждый процесс 
хранит в своей памяти различные данные (переменные, файловые дескрипторы и проч.). 
При порождении нового процесса, потомок получает точную копию данных родителя. 
Но как только новый процесс создан, родитель и потомок уже распоряжаются своими 
копиями по своему усмотрению. Это позволяет распараллелить программу, заставив 
ее выполнять какой-нибудь трудоемкий алгоритм в отдельном процессе. "

msg3='
  Процесс может узнать свой идентификатор (PID), а также 
  родительский идентификатор (PPID) при помощи системных 
  вызовов [getpid()] и [getppid()]. 
  Для использования [getpid()] и [getppid()] в программу 
  должны быть включены директивой [#include] заголовочные 
  файлы [unistd.h] и [sys/types.h] (для типа [pid_t]).
  [pid_t getpid (void);]
  [pid_t getppid (void);]
'

echo "$msg1"
echo ""
echo "$msg2"
echo ""
echo "$msg3"
