---
Ресурсы:

// оф сайт
- [ https://swagger.io]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ TLS/SSL/mTLS ] протоколы безопасной передачи данных



1) протоколы
  - [ SSL ]: Secure Socket Layer, уровень защиты сокетов, устарел
  - [ TLS ]: Transport Layer Security, протокол защиты транспортного уровня
  - [ mTLS ]: Mutant Transport Layer Security


2) шифрование
  - можно разделить на два типа
    - [ симетричное ] для шифрования/расшифрования нужен один и тот же ключ
    - [ асиметричное ] для шифрования используем публичный ключ, для расшифрования приватный
    - (*) асиметричное шифрование работает очень медленно, 
      поэтому устанавливается соединение по асиметричному шифрованию, потом генерится 
      секрет на сессию и он используется уже для симетричного шифравания сообщений.


3) целостность данных (защита от изменений)
  - [ MD5, SHA-1, SHA-512 ] хеш функции позволяют убедиться что данные не изменены
  - [ Message Authentification Code ] (хеш) код аутентификации сообщений, имитовставка,
    расчитывается на основе сообщения и разделяемого ключа.


4) Аутентификация (как проверить что мы не подключились к злоумышленику)
  - [ Электронная подпись ] в электронной подписи все наоборот, мы шифруем сообщение
    закрытым ключем а расшифровать может любой у кого есть открытый ключ,
    так мы можем сказать что именно обладатель закрытого ключа передал нам данные.
  - [ PKI (public key infrastructure) ] инфраструктура открытых ключей представляет
    подход с третьей стороной в виде удоставеряющих центров.
    Сервер создает сертификат, кладет туда свой публичный ключ, отдает в удостоверяющий центр,
    который подписывает этот сертификат своим закрытым ключем, теперь клиент, 
    получив такой сертификат, может его проверить открытым ключем удоставеряющего центра
  - [ certificate ] сертификат это файл спецального вида, состоящий из нескольких компонентов,
    основной компонент это открытый ключ сервера.
    - возможное содержание сертификата, зависит от формата, сейчас используется [ X.509 ]
      - (*) можно посмотреть сертификат сайта вытащив его в браузере через замочек.
      - [ Серийный номер ]
      - [ Алгоритм подписи ]
      - [ Издатель ] это удоставеряющий центр
      - [ Действителен с ]
      - [ Действителен по ]
      - [ Субьект ] домен сайта
      - [ Открытый ключ ]
    - самоподписанный сертификат - это когда сервер создает сертификат 
      и не отдает в удоставеряющий центр а сам его подписывает своим приватным ключем.


5) Установка соединения TLS/mTLS
  - клиент делает запрос на сервер включая список алгоритмов шифрования которые поддерживает
  - сервер отвечает указывая алгоритмы по которым будет шифрование. Выбирает из поддерживаемых клиентом
  - также сервер передает свой сертификат, в котором лежит открытый ключ
    - (*) для mTLS сервер просит у клиента сертификат, чтобы удостовериться что клиент тот, за кого себя выдает
  - клиент должен проверить сертификат
    - если это не самоподписанный сертификат, надо проверить открытым ключем удоставеряющего центра
    - проверить соответствия домена в сертификате и домена сервера
    - проверить срок действия сертификата
  - сервер и клиент обменивается сгенеренным симетричным ключем
  - обмениваются сообщениями о переходе на общение по переданным симетричным ключам
  - начинается обмен данными, зашифрованными симетричным ключем


6) OpenSSL
  - [ openssl ] утилита позволяет работать с сертификатами и ключами
  - [ openssl gen<алгоритм> ]  создаем только приватный ключ
    - [ openssl genrsa -out ca.key 2048  ] создаст приватный ключ RSA (*) длина по дефолту 512 бит
    - [ openssl gendsa ] тут надо еще указать файл с параметрами как создать пару ключей
  - [ openssl req -new -x509 -subj "/C=RU/ST=Moscow/O=DONEATHOME, Inc./CN=doneathome.ru" -key ca.key -out ca.crt -days 365 ] 
    - [ -x509 ] позволяет сразу получит самоподписанный сертификат !!!
    - делаем сразу сертификат из приватного ключа, тоесть вычислится публичный ключ и создастся сертификат
    - (*)[ CN=doneathome.ru ] очень важно указать корректный домен, так как он проверяется при проверке сертификатов
  -...
  - TLS
    - в серверном приложении указываем путь до 
      - [ ca.key ] приватный ключ
      - [ ca.crt ] сертификат с публичным ключем, сертификат подписан приватным ключем + удостоверяющем центром
  -...
  - Форматы сертификатов
    - [ PEM ] Основные расширения этого типа .pem, .crt, .cer, .key. 
      - В файлах содержатся строки вида:
        [
           -----BEGIN CERTIFICATE-----
           -----END CERTIFICATE-----
           -----BEGIN PRIVATE KEY-----
           -----END PRIVATE KEY ------
        ]
    - [ DER ] это бинарная форма сертификата PEM. Основные расширения этого типа  сертификата .der .cer.
    - [ P7B ] Файлы P7B кодируются в формате Base64 и имеют расширение .p7b или .p7c.
      - В файлах содержатся строки вида:
        [
          -----BEGIN PKCS7-----
          -----END PKCS7-----
        ]    
    - [ PFX ] это сертификат в бинарном формате, выданный для домена, включающий в себя сертификат, 
      цепочку сертификатов (корневые сертификаты) и приватный ключ. Имеют расширение .pfx или .p12.
  -...
  - конвертация сертификатов
    - (*) если мы в текстовом редакторе можем открыть сертификат то это BASE64  
      и он начинается на [ -----BEGIN CERTIFICATE----- ] то это  PEM формат.
      - !! если не можем прочитать может это DER - бинарный формат PEM. 
        - Можно преобразовать: [ openssl x509 -inform DER -outform PEM -in server.crt -out server.crt.pem ]
    - [ openssl ] можно нагуглить преобразование любого формата ключа в любой.
  
  
7) mTLS
  - [ openssl genrsa -out сa.key 2048 ] создаем приватный ключ
  - [ openssl req -new -x509 -subj "/C=RU/ST=Moscow/O=DONEATHOME, Inc./" -key ca.key -out ca.crt -days 365 ] \
    - [ -x509 ] позволяет сразу получит самоподписанный сертификат !!
    - делаем сразу сертификат из приватного ключа, тоесть вычислится публичный ключ и создастся сертификат
  - [ ll ] показывает что у нас теперь приватный ключ и сертификат [ ca.key, ca.crt ]
  -...
  - создаем клиентский сертификат
    - [ openssl genrsa -out user.key 2048 ] создаем приватный ключ 
    - [ openssl req -new -key user.key -subj "/C=RU/ST=Moscow/O=DONEATHOME, Inc."  -out user.csr ]
      - (*) нет ключика "-x509" поэтому сертификат надо будет подписать корневым сертификатом
    - [ openssl x509 -req -days 365 -in user.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out user.crt ]
      - [ -in ] сертификат который хотим подписать
      - [ -CA ] сертификат удостоверяющего центра (корневой)
      - [ -CAkey ] приватный ключ удостоверяющего центра (корневой)
      - [ -set_serial ] серийный номер, при истечении срока, перегенерируя сертификат можно увеличить значение, 
        чтобы знать сколько раз перевыпущен.
    - [ openssl verify -verbose -CAfile ca.crt user.crt ] проверяем что клиентский сертификат подписан корневым
    - [ ll ] показывает что у нас теперь приватный ключ и сертификат [ ca.key, ca.crt, user.crt, user.csr, user.key ]
  - создаем серверный сертификат
    - [ openssl genrsa -out doneathome.ru.key 2048 ]
    - [ openssl req -new -key doneathome.ru.key -subj "/C=RU/ST=Moscow/O=DONEATHOME, Inc./CN=doneathome.ru" -out doneathome.ru.csr ]
    - [ openssl x509 -req -days 365 -in doneathome.ru.csr -CA ca.crt -CAkey ca.key -set_serial 1 -out doneathome.ru.crt ]
    - [ ll ] показывает [ ca.key, ca.crt, user.crt, user.csr, user.key, doneathome.ru.crt, doneathome.ru.csr, doneathome.ru.key ]


8) как конвертнуть сертификаты в .jks
  - ИНФО [ https://docs.oracle.com/cd/E35976_01/server.740/es_admin/src/tadm_ssl_convert_pem_to_jks.html ]
  - создаем пустой кейстор
    - [ keytool -genkey -keyalg RSA -alias endeca -keystore keystore.jks ] 
  - удаляем созданный сертификат в хранилище
    - [ keytool -delete -alias endeca -keystore keystore.jks ]
  - обьединяем сертификат и приватный ключ
    - [ cat client-certificate.pem client-key.pem > combined.pem ]
  - конвертим
    - [ openssl pkcs12 -export -in combined.pem  -out combined.pkcs12 ]
  - засовываем
    - [ keytool -v -importkeystore -srckeystore combined.pkcs12  -srcstoretype PKCS12 -destkeystore keystore.jks -deststoretype JKS ]

8a) добавляем серверный сертификат в truststore.jks
  - [ keytool  -import  -trustcacerts -alias ecm-new-dev  -file dso-st.os-root-ca.cer  -keystore truststore.jks ]


9) как вытащить сертификаты из .jks и положить в другой
  - [ https://www.sslshopper.com/article-most-common-java-keytool-keystore-commands.html]
  - смотрим что внутри jks файла
    - [ keytool -list -v -keystore ./ecm-truststore.jks ]
  - экспортируем сертификат из jks
    - [ keytool -export -alias 1 -file ecm-dev.crt -keystore ./ecm-truststore.jks ]
      [ keytool -export -alias 1 -keystore ecm-truststore.jks -rfc -file ecm-dev.cert ] (*) эксморт в формате X.509
  - кладев в другой jks сертификат
    - [ keytool  -import  -trustcacerts -alias ecm-dev  -file ecm-dev.cert  -keystore truststore.jks ]




[?] как сделать запрос на сервер https
  - [ curl -v --cacert ca.pem https://localhost:8443/ ] указываем сертификат для запросаъ
  - [ curl -v https://localhost:8443/ --insecure ] флаг позволяет не проверять сертификат сервера
  -...
  - mTLS
    - [ curl -v --cacert ca.pem --cert localhost.cert.pem --key localhost.key.pem https://localhost:8443/ ]
      - (*) тут мы еще указываем клиентский ключ + клиентский сертификат


[?] как посмотреть информацию о сертификате
  - [ openssl x509 -noout -text -in <файл сертификата> ]
 

[?] nop
  - nop

  https://ts-ecm.ss1-genr01-tsec-omnitech-rb-ift.apps.ss1-genr01.test.vtb.ru/swagger-ui/
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 



15:04
openssl s_client -showcerts -servername https://esign-ts.ss1-genr01-tses-omnitech-rb-ift.apps.ss1-genr01.test.vtb.ru -connect https://esign-ts.ss1-genr01-tses-omnitech-rb-ift.apps.ss1-genr01.test.vtb.ru:443