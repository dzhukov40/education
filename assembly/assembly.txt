---
Ресурсы:

// оф сайт
- [  ]
 


---
элементы документа 

[?] - информация потенциально для многократного использования
[!] - была ошибка, недочет, нашли решение 
[*] - важное контекстное примечание 
[#<имяТега>] - так можим выносить различного рода информацию, оставляя ссылку 

---
краткое описание 

- [ assembly ] машинно-ориентированный язык программирования низкого уровня.


 

1) установка IDE
  - [ http://dman95.github.io/SASM/ ] качаем 
  - качаем файл [ sasm_3.10.1_amd64.deb ] 
    - [ sudo apt install ./sasm_3.10.1_amd64.deb -y ] устанавливаем 
  - [ sasm ] запускаем
  - Заходим в окне программы в Settings. Там - ставим 64 битный GAS.
  - Создаём новый проект. Всё обрамление кода создастся автоматически.
  -  (*) пишем саой код
  - Запускаем это дело с помощью "Build and run" в верхней панели.
  - Если хотим пошаговый дебаг, то жмём F5 - произойдёт запуск с дебагом.

2) команды
- [ mov ] копирование
  - [ movq <src>, <dst> ] копирование байта
    - примеры
      - [ movq %RAX, %RBX ] копирование из регистра в регистр
      - [ movq (%RAX), %RBX ] (*) скобочки это разыменование
      - [ movq $42, %RBX ] положить константу в регистр
      - [ movq 42, %RBX ] (*) не указав $ будет разыменование
...
- [ add ] сложение (прибавление)
  - (*) результат будет во втором аргументе
  - [ addq <src>, <dst> ] прибавление байта
    - примеры
      - [ addq %RAX, %RBX ] прибавляем к RBX байт из RAX
      - [ addq $42, %RBX ] прибавляем к RBX число 42
...
- [ sub ] вычитание
  - (*) результат будет во втором аргументе
  - [ sub <src>, <dst> ] вычитание байта
    - примеры
      - [ sub %RAX, %RBX ] вычитаем из RBX байт из RAX
      - [ sub $42, %RBX ] вычитаем из RBX число 42
...
- [ cmp ] вычитание без изменения значений регистров
  - (*) применяется для условий/проверок
  - (*) результатом будут флаги в регистре RFLAGS
  - [ cmp <src>, <dst> ] вычисляет разность, но не изменяет dst
...
- [ incq ] инкремент
  - [ incq <op> ] увеличить на единицу
    - примеры
      - [ incq %RAX ] инкрементируем число в регистре
...
- [ decq ] декремент
  - [ decq <op> ] уменьшить на единицу
    - примеры
      - [ decq %RAX ] декрементируем число в регистре
...
- [ mulq ] беззнаковое умножение
  - (*) число из регистра %RAX умножить на аргумент
  - (*) результат: %RAX и %RDX
  - [ mulq <op> ] число из регистра %RAX умножить на аргумент
    - примеры
      - [ mulq %RСX ] умножить число из %RСX на число из регистра %RAX
...
- [ div ] деление
  - (*) число из регистра %RAX поделить на аргумент
  - (*) результат: %RAX (часное) и %RDX (остаток от деления)
  - [ divq <op> ] число из регистра %RAX поделить на <op>
    - примеры
      - [ divq %RСX ] поделить число из %RСX на число из регистра %RAX
...
- [ push ] положить значение на стек
  - (*) регистр RSP указывает на верхушку стека
  - [ pushq <src> ] уменьшает RSP на 8 и сохраняет по полуженному адресу "src"
    - примеры
      - [ pushq $42 ] положить число 42 в стек
      - [ pushq %RAX ] положить значение из регистра в стек
...
- [ pop ] lдостать значение из стека
  - (*) регистр RSP указывает на верхушку стека
  - (*) прочитать значение из стека не удаляя [ movq (%RSP), %RAX ]
  - [ popq <dst> ] увеличит RSP на 8 и достанет значение из стека по адресу "dst"
    - примеры
      - [ popq %RAX ] положить значение из стекаьв регистр "%RAX"


3) инструкции
- [ метка ] это имя некоторого адреса
  - [ <name>: ] пишем имя метки перед местом на которое хотим ссылаться
    - примеры
      - [  
             .data
          value:
             .quad 42
             
             .text
          add42:
             movq %RDI, %RAX
             addq value, %RAX
             retq
       ] пример использования метки для ссылки на значение и место в коде
...
- [ jmp ] инструкция безусловного перехода
  - (*) регистр RIP указывает на выполняемый код
  - (*) команда "jmp" меняет значение в RIP
  - [ jmp <label> ] перейти на выполнение кода по метке
...
- [ call ] инструкция вызова функции
  - (*) регистр RIP указывает на выполняемый код
  - (*) команда "call" меняет значение в RIP
  - (*) для возвращения из функции используется инструкция "retq"
  - (*) при вызове call и retq адрес возврата сохраняется на стек а потом берется
  - [ call <label> ] вызвать функцию по метке
...
- [ jcc ] инструкция условного перехода
  - (*) регистр RIP указывает на выполняемый код
  - [ jcc <label> ] выполняет переход если условие "cc" истино
    - [ jz <label> / je <label> ] перейти если флаг ZF = 1
    - [ jne <label> / jnz <label> ] перейти если флаг ZF = 0
    - [ jg <label> ] перейти если больше (знаковый вариантт)
    - [ jge <label> ] перейти если больше или равно (знаковый вариантт)           
    - [ ja <label> ] перейти если больше (беззнаковый вариантт)
    - [ jae <label> ] перейти если больше или равно (беззнаковый вариантт)





5) регистры
- [ RFLAGS ] флаговый регистр
  - (*) арифметические команды устанавливают/сбрасывают биты
  - [ ZF ] результат операции 0
  - [ CF ] произошло беззнаковое переполнение
  - [ OF ] произошло знаковое переполнение












/* написать функцию, озведения в степень
   аргумены: два беззнаковых числа x и p (в регистрах RDI и RSI соответственно)
   результат: "x степени p", ответ положить в регистр RAX
*/
// #getMin 
#----------------------------------------------

pow:
  
  # проверить что значение в регистре RDI == 0, результат 0
  # проверить что значение в регистре RSI == 0, результат 1

  # нужжно организовать цикл с умножением и накоплением результата

 

#----------------------------------------------

/* написать функцию, которая определит минимум из двух чисел 
   аргументы передаются в регистрах RDI и RSI 
   результат RAX 
*/
// #getMin 
#----------------------------------------------

min:
  movq %RDI, %RAX
  cmpq %RSI, %RDI
  jl min_exit
  movq %RSI, %RAX
min_exit:
  ret

#----------------------------------------------

/* поменять значения в двух регистрах RSI и RDX местами */
// #swap 
#----------------------------------------------

# кладем в стек
pushq %RSI
pushq %RDX

# достаем из стека
popq %RSI
popq %RDX

#----------------------------------------------

/* В регистре RSI вам дано целое число - градусы по шкале 
Фаренгейта (TF). Напишите код, который получит в регистре RSI 
сответствующее значение по шкале Цельсия (TC). 
Формула для перевода из шкалы Фаренгейта в шкалу Цельсия:
       
       5 * (Tf - 32)
  Tc = --------------
             9
*/
// #tempConvert 
#----------------------------------------------

# вычмтаем 32
sub $32, %RSI

# умножаем на 5
movq $5, %RAX
mulq %RSI

# делим на 9
movq $9, %RCX
divq %RCX

# переносим ответ
movq %RAX, %RSI

#----------------------------------------------


[?] nop
  - nop

 
 
// #c 
#----------------------------------------------- 

 

#----------------------------------------------- 
 
